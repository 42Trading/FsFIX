module Fix44.FieldReadWriteFuncs


open System
open Fix44.Fields
open Conversions
open StreamUtils
open FieldFuncs


let ReadAccount (pos:int) (bs:byte[]) : (int*Account) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Account.Account


let WriteAccount (dest:byte []) (nextFreeIdx:int) (valIn:Account) : int = 
   let tag = "1="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAdvId (pos:int) (bs:byte[]) : (int*AdvId) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AdvId.AdvId


let WriteAdvId (dest:byte []) (nextFreeIdx:int) (valIn:AdvId) : int = 
   let tag = "2="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAdvRefID (pos:int) (bs:byte[]) : (int*AdvRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AdvRefID.AdvRefID


let WriteAdvRefID (dest:byte []) (nextFreeIdx:int) (valIn:AdvRefID) : int = 
   let tag = "3="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAdvSide (pos:int) (bs:byte[]) : (int * AdvSide) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"B"B -> AdvSide.Buy
        |"S"B -> AdvSide.Sell
        |"X"B -> AdvSide.Cross
        |"T"B -> AdvSide.Trade
        | x -> failwith (sprintf "ReadAdvSide unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAdvSide (dest:byte array) (nextFreeIdx:int) (xxIn:AdvSide) : int =
    match xxIn with
    | AdvSide.Buy ->
        let tag = "4=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Sell ->
        let tag = "4=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Cross ->
        let tag = "4=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Trade ->
        let tag = "4=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAdvTransType (pos:int) (bs:byte[]) : (int * AdvTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"N"B -> AdvTransType.New
        |"C"B -> AdvTransType.Cancel
        |"R"B -> AdvTransType.Replace
        | x -> failwith (sprintf "ReadAdvTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAdvTransType (dest:byte array) (nextFreeIdx:int) (xxIn:AdvTransType) : int =
    match xxIn with
    | AdvTransType.New ->
        let tag = "5=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvTransType.Cancel ->
        let tag = "5=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvTransType.Replace ->
        let tag = "5=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAvgPx (pos:int) (bs:byte[]) : (int*AvgPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AvgPx.AvgPx


let WriteAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:AvgPx) : int = 
   let tag = "6="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBeginSeqNo (pos:int) (bs:byte[]) : (int*BeginSeqNo) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) BeginSeqNo.BeginSeqNo


let WriteBeginSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:BeginSeqNo) : int = 
   let tag = "7="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBeginString (pos:int) (bs:byte[]) : (int*BeginString) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BeginString.BeginString


let WriteBeginString (dest:byte []) (nextFreeIdx:int) (valIn:BeginString) : int = 
   let tag = "8="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBodyLength (pos:int) (bs:byte[]) : (int*BodyLength) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) BodyLength.BodyLength


let WriteBodyLength (dest:byte []) (nextFreeIdx:int) (valIn:BodyLength) : int = 
   let tag = "9="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCheckSum (pos:int) (bs:byte[]) : (int*CheckSum) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CheckSum.CheckSum


let WriteCheckSum (dest:byte []) (nextFreeIdx:int) (valIn:CheckSum) : int = 
   let tag = "10="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadClOrdID (pos:int) (bs:byte[]) : (int*ClOrdID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ClOrdID.ClOrdID


let WriteClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:ClOrdID) : int = 
   let tag = "11="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCommission (pos:int) (bs:byte[]) : (int*Commission) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Commission.Commission


let WriteCommission (dest:byte []) (nextFreeIdx:int) (valIn:Commission) : int = 
   let tag = "12="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCommType (pos:int) (bs:byte[]) : (int * CommType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> CommType.PerUnit
        |"2"B -> CommType.Percentage
        |"3"B -> CommType.Absolute
        |"4"B -> CommType.PercentageWaivedCashDiscount
        |"5"B -> CommType.PercentageWaivedEnhancedUnits
        |"6"B -> CommType.PointsPerBondOrOrContract
        | x -> failwith (sprintf "ReadCommType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCommType (dest:byte array) (nextFreeIdx:int) (xxIn:CommType) : int =
    match xxIn with
    | CommType.PerUnit ->
        let tag = "13=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.Percentage ->
        let tag = "13=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.Absolute ->
        let tag = "13=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PercentageWaivedCashDiscount ->
        let tag = "13=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PercentageWaivedEnhancedUnits ->
        let tag = "13=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PointsPerBondOrOrContract ->
        let tag = "13=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCumQty (pos:int) (bs:byte[]) : (int*CumQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) CumQty.CumQty


let WriteCumQty (dest:byte []) (nextFreeIdx:int) (valIn:CumQty) : int = 
   let tag = "14="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCurrency (pos:int) (bs:byte[]) : (int*Currency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Currency.Currency


let WriteCurrency (dest:byte []) (nextFreeIdx:int) (valIn:Currency) : int = 
   let tag = "15="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEndSeqNo (pos:int) (bs:byte[]) : (int*EndSeqNo) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) EndSeqNo.EndSeqNo


let WriteEndSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:EndSeqNo) : int = 
   let tag = "16="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExecID (pos:int) (bs:byte[]) : (int*ExecID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExecID.ExecID


let WriteExecID (dest:byte []) (nextFreeIdx:int) (valIn:ExecID) : int = 
   let tag = "17="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExecInst (pos:int) (bs:byte[]) : (int * ExecInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ExecInst.NotHeld
        |"2"B -> ExecInst.Work
        |"3"B -> ExecInst.GoAlong
        |"4"B -> ExecInst.OverTheDay
        |"5"B -> ExecInst.Held
        |"6"B -> ExecInst.ParticipateDontInitiate
        |"7"B -> ExecInst.StrictScale
        |"8"B -> ExecInst.TryToScale
        |"9"B -> ExecInst.StayOnBidside
        |"0"B -> ExecInst.StayOnOfferside
        |"A"B -> ExecInst.NoCross
        |"B"B -> ExecInst.OkToCross
        |"C"B -> ExecInst.CallFirst
        |"D"B -> ExecInst.PercentOfVolume
        |"E"B -> ExecInst.DoNotIncrease
        |"F"B -> ExecInst.DoNotReduce
        |"G"B -> ExecInst.AllOrNone
        |"H"B -> ExecInst.ReinstateOnSystemFailure
        |"I"B -> ExecInst.InstitutionsOnly
        |"J"B -> ExecInst.ReinstateOnTradingHalt
        |"K"B -> ExecInst.CancelOnTradingHalt
        |"L"B -> ExecInst.LastPeg
        |"M"B -> ExecInst.MidPrice
        |"N"B -> ExecInst.NonNegotiable
        |"O"B -> ExecInst.OpeningPeg
        |"P"B -> ExecInst.MarketPeg
        |"Q"B -> ExecInst.CancelOnSystemFailure
        |"R"B -> ExecInst.PrimaryPeg
        |"S"B -> ExecInst.Suspend
        |"T"B -> ExecInst.FixedPegToLocalBestBidOrOfferAtTimeOfOrder
        |"U"B -> ExecInst.CustomerDisplayInstruction
        |"V"B -> ExecInst.Netting
        |"W"B -> ExecInst.PegToVwap
        |"X"B -> ExecInst.TradeAlong
        |"Y"B -> ExecInst.TryToStop
        |"Z"B -> ExecInst.CancelIfNotBest
        |"a"B -> ExecInst.TrailingStopPeg
        |"b"B -> ExecInst.StrictLimit
        |"c"B -> ExecInst.IgnorePriceValidityChecks
        |"d"B -> ExecInst.PegToLimitPrice
        |"e"B -> ExecInst.WorkToTargetStrategy
        | x -> failwith (sprintf "ReadExecInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExecInst (dest:byte array) (nextFreeIdx:int) (xxIn:ExecInst) : int =
    match xxIn with
    | ExecInst.NotHeld ->
        let tag = "18=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Work ->
        let tag = "18=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.GoAlong ->
        let tag = "18=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OverTheDay ->
        let tag = "18=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Held ->
        let tag = "18=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ParticipateDontInitiate ->
        let tag = "18=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StrictScale ->
        let tag = "18=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TryToScale ->
        let tag = "18=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StayOnBidside ->
        let tag = "18=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StayOnOfferside ->
        let tag = "18=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.NoCross ->
        let tag = "18=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OkToCross ->
        let tag = "18=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CallFirst ->
        let tag = "18=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PercentOfVolume ->
        let tag = "18=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.DoNotIncrease ->
        let tag = "18=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.DoNotReduce ->
        let tag = "18=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.AllOrNone ->
        let tag = "18=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ReinstateOnSystemFailure ->
        let tag = "18=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.InstitutionsOnly ->
        let tag = "18=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ReinstateOnTradingHalt ->
        let tag = "18=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelOnTradingHalt ->
        let tag = "18=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.LastPeg ->
        let tag = "18=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.MidPrice ->
        let tag = "18=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.NonNegotiable ->
        let tag = "18=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OpeningPeg ->
        let tag = "18=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.MarketPeg ->
        let tag = "18=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelOnSystemFailure ->
        let tag = "18=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PrimaryPeg ->
        let tag = "18=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Suspend ->
        let tag = "18=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.FixedPegToLocalBestBidOrOfferAtTimeOfOrder ->
        let tag = "18=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CustomerDisplayInstruction ->
        let tag = "18=U"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Netting ->
        let tag = "18=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PegToVwap ->
        let tag = "18=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TradeAlong ->
        let tag = "18=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TryToStop ->
        let tag = "18=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelIfNotBest ->
        let tag = "18=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TrailingStopPeg ->
        let tag = "18=a"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StrictLimit ->
        let tag = "18=b"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.IgnorePriceValidityChecks ->
        let tag = "18=c"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PegToLimitPrice ->
        let tag = "18=d"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.WorkToTargetStrategy ->
        let tag = "18=e"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecRefID (pos:int) (bs:byte[]) : (int*ExecRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExecRefID.ExecRefID


let WriteExecRefID (dest:byte []) (nextFreeIdx:int) (valIn:ExecRefID) : int = 
   let tag = "19="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHandlInst (pos:int) (bs:byte[]) : (int * HandlInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> HandlInst.AutomatedExecutionOrderPrivate
        |"2"B -> HandlInst.AutomatedExecutionOrderPublic
        |"3"B -> HandlInst.ManualOrder
        | x -> failwith (sprintf "ReadHandlInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteHandlInst (dest:byte array) (nextFreeIdx:int) (xxIn:HandlInst) : int =
    match xxIn with
    | HandlInst.AutomatedExecutionOrderPrivate ->
        let tag = "21=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HandlInst.AutomatedExecutionOrderPublic ->
        let tag = "21=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HandlInst.ManualOrder ->
        let tag = "21=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityIDSource (pos:int) (bs:byte[]) : (int * SecurityIDSource) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SecurityIDSource.Cusip
        |"2"B -> SecurityIDSource.Sedol
        |"3"B -> SecurityIDSource.Quik
        |"4"B -> SecurityIDSource.IsinNumber
        |"5"B -> SecurityIDSource.RicCode
        |"6"B -> SecurityIDSource.IsoCurrencyCode
        |"7"B -> SecurityIDSource.IsoCountryCode
        |"8"B -> SecurityIDSource.ExchangeSymbol
        |"9"B -> SecurityIDSource.ConsolidatedTapeAssociation
        |"A"B -> SecurityIDSource.BloombergSymbol
        |"B"B -> SecurityIDSource.Wertpapier
        |"C"B -> SecurityIDSource.Dutch
        |"D"B -> SecurityIDSource.Valoren
        |"E"B -> SecurityIDSource.Sicovam
        |"F"B -> SecurityIDSource.Belgian
        |"G"B -> SecurityIDSource.Common
        |"H"B -> SecurityIDSource.ClearingHouseClearingOrganization
        |"I"B -> SecurityIDSource.IsdaFpmlProductSpecification
        |"J"B -> SecurityIDSource.OptionsPriceReportingAuthority
        | x -> failwith (sprintf "ReadSecurityIDSource unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityIDSource) : int =
    match xxIn with
    | SecurityIDSource.Cusip ->
        let tag = "22=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Sedol ->
        let tag = "22=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Quik ->
        let tag = "22=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsinNumber ->
        let tag = "22=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.RicCode ->
        let tag = "22=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsoCurrencyCode ->
        let tag = "22=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsoCountryCode ->
        let tag = "22=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ExchangeSymbol ->
        let tag = "22=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ConsolidatedTapeAssociation ->
        let tag = "22=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.BloombergSymbol ->
        let tag = "22=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Wertpapier ->
        let tag = "22=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Dutch ->
        let tag = "22=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Valoren ->
        let tag = "22=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Sicovam ->
        let tag = "22=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Belgian ->
        let tag = "22=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Common ->
        let tag = "22=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ClearingHouseClearingOrganization ->
        let tag = "22=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsdaFpmlProductSpecification ->
        let tag = "22=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.OptionsPriceReportingAuthority ->
        let tag = "22=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIid (pos:int) (bs:byte[]) : (int*IOIid) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) IOIid.IOIid


let WriteIOIid (dest:byte []) (nextFreeIdx:int) (valIn:IOIid) : int = 
   let tag = "23="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIOIQltyInd (pos:int) (bs:byte[]) : (int * IOIQltyInd) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"L"B -> IOIQltyInd.Low
        |"M"B -> IOIQltyInd.Medium
        |"H"B -> IOIQltyInd.High
        | x -> failwith (sprintf "ReadIOIQltyInd unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteIOIQltyInd (dest:byte array) (nextFreeIdx:int) (xxIn:IOIQltyInd) : int =
    match xxIn with
    | IOIQltyInd.Low ->
        let tag = "25=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQltyInd.Medium ->
        let tag = "25=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQltyInd.High ->
        let tag = "25=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIRefID (pos:int) (bs:byte[]) : (int*IOIRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) IOIRefID.IOIRefID


let WriteIOIRefID (dest:byte []) (nextFreeIdx:int) (valIn:IOIRefID) : int = 
   let tag = "26="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIOIQty (pos:int) (bs:byte[]) : (int*IOIQty) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) IOIQty.IOIQty


let WriteIOIQty (dest:byte []) (nextFreeIdx:int) (valIn:IOIQty) : int = 
   let tag = "27="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIOITransType (pos:int) (bs:byte[]) : (int * IOITransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"N"B -> IOITransType.New
        |"C"B -> IOITransType.Cancel
        |"R"B -> IOITransType.Replace
        | x -> failwith (sprintf "ReadIOITransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteIOITransType (dest:byte array) (nextFreeIdx:int) (xxIn:IOITransType) : int =
    match xxIn with
    | IOITransType.New ->
        let tag = "28=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOITransType.Cancel ->
        let tag = "28=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOITransType.Replace ->
        let tag = "28=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastCapacity (pos:int) (bs:byte[]) : (int * LastCapacity) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> LastCapacity.Agent
        |"2"B -> LastCapacity.CrossAsAgent
        |"3"B -> LastCapacity.CrossAsPrincipal
        |"4"B -> LastCapacity.Principal
        | x -> failwith (sprintf "ReadLastCapacity unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteLastCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:LastCapacity) : int =
    match xxIn with
    | LastCapacity.Agent ->
        let tag = "29=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.CrossAsAgent ->
        let tag = "29=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.CrossAsPrincipal ->
        let tag = "29=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.Principal ->
        let tag = "29=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastMkt (pos:int) (bs:byte[]) : (int*LastMkt) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LastMkt.LastMkt


let WriteLastMkt (dest:byte []) (nextFreeIdx:int) (valIn:LastMkt) : int = 
   let tag = "30="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastPx (pos:int) (bs:byte[]) : (int*LastPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastPx.LastPx


let WriteLastPx (dest:byte []) (nextFreeIdx:int) (valIn:LastPx) : int = 
   let tag = "31="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastQty (pos:int) (bs:byte[]) : (int*LastQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastQty.LastQty


let WriteLastQty (dest:byte []) (nextFreeIdx:int) (valIn:LastQty) : int = 
   let tag = "32="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLinesOfText (pos:int) (bs:byte[]) : (int*LinesOfText) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LinesOfText.LinesOfText


let WriteLinesOfText (dest:byte []) (nextFreeIdx:int) (valIn:LinesOfText) : int = 
   let tag = "33="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMsgSeqNum (pos:int) (bs:byte[]) : (int*MsgSeqNum) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MsgSeqNum.MsgSeqNum


let WriteMsgSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:MsgSeqNum) : int = 
   let tag = "34="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMsgType (pos:int) (bs:byte[]) : (int * MsgType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MsgType.Heartbeat
        |"1"B -> MsgType.TestRequest
        |"2"B -> MsgType.ResendRequest
        |"3"B -> MsgType.Reject
        |"4"B -> MsgType.SequenceReset
        |"5"B -> MsgType.Logout
        |"6"B -> MsgType.IndicationOfInterest
        |"7"B -> MsgType.Advertisement
        |"8"B -> MsgType.ExecutionReport
        |"9"B -> MsgType.OrderCancelReject
        |"A"B -> MsgType.Logon
        |"B"B -> MsgType.News
        |"C"B -> MsgType.Email
        |"D"B -> MsgType.OrderSingle
        |"E"B -> MsgType.OrderList
        |"F"B -> MsgType.OrderCancelRequest
        |"G"B -> MsgType.OrderCancelReplaceRequest
        |"H"B -> MsgType.OrderStatusRequest
        |"J"B -> MsgType.AllocationInstruction
        |"K"B -> MsgType.ListCancelRequest
        |"L"B -> MsgType.ListExecute
        |"M"B -> MsgType.ListStatusRequest
        |"N"B -> MsgType.ListStatus
        |"P"B -> MsgType.AllocationInstructionAck
        |"Q"B -> MsgType.DontKnowTrade
        |"R"B -> MsgType.QuoteRequest
        |"S"B -> MsgType.Quote
        |"T"B -> MsgType.SettlementInstructions
        |"V"B -> MsgType.MarketDataRequest
        |"W"B -> MsgType.MarketDataSnapshotFullRefresh
        |"X"B -> MsgType.MarketDataIncrementalRefresh
        |"Y"B -> MsgType.MarketDataRequestReject
        |"Z"B -> MsgType.QuoteCancel
        |"a"B -> MsgType.QuoteStatusRequest
        |"b"B -> MsgType.MassQuoteAcknowledgement
        |"c"B -> MsgType.SecurityDefinitionRequest
        |"d"B -> MsgType.SecurityDefinition
        |"e"B -> MsgType.SecurityStatusRequest
        |"f"B -> MsgType.SecurityStatus
        |"g"B -> MsgType.TradingSessionStatusRequest
        |"h"B -> MsgType.TradingSessionStatus
        |"i"B -> MsgType.MassQuote
        |"j"B -> MsgType.BusinessMessageReject
        |"k"B -> MsgType.BidRequest
        |"l"B -> MsgType.BidResponse
        |"m"B -> MsgType.ListStrikePrice
        |"n"B -> MsgType.XmlMessage
        |"o"B -> MsgType.RegistrationInstructions
        |"p"B -> MsgType.RegistrationInstructionsResponse
        |"q"B -> MsgType.OrderMassCancelRequest
        |"r"B -> MsgType.OrderMassCancelReport
        |"s"B -> MsgType.NewOrderCross
        |"t"B -> MsgType.CrossOrderCancelReplaceRequest
        |"u"B -> MsgType.CrossOrderCancelRequest
        |"v"B -> MsgType.SecurityTypeRequest
        |"w"B -> MsgType.SecurityTypes
        |"x"B -> MsgType.SecurityListRequest
        |"y"B -> MsgType.SecurityList
        |"z"B -> MsgType.DerivativeSecurityListRequest
        |"AA"B -> MsgType.DerivativeSecurityList
        |"AB"B -> MsgType.NewOrderMultileg
        |"AC"B -> MsgType.MultilegOrderCancelReplace
        |"AD"B -> MsgType.TradeCaptureReportRequest
        |"AE"B -> MsgType.TradeCaptureReport
        |"AF"B -> MsgType.OrderMassStatusRequest
        |"AG"B -> MsgType.QuoteRequestReject
        |"AH"B -> MsgType.RfqRequest
        |"AI"B -> MsgType.QuoteStatusReport
        |"AJ"B -> MsgType.QuoteResponse
        |"AK"B -> MsgType.Confirmation
        |"AL"B -> MsgType.PositionMaintenanceRequest
        |"AM"B -> MsgType.PositionMaintenanceReport
        |"AN"B -> MsgType.RequestForPositions
        |"AO"B -> MsgType.RequestForPositionsAck
        |"AP"B -> MsgType.PositionReport
        |"AQ"B -> MsgType.TradeCaptureReportRequestAck
        |"AR"B -> MsgType.TradeCaptureReportAck
        |"AS"B -> MsgType.AllocationReport
        |"AT"B -> MsgType.AllocationReportAck
        |"AU"B -> MsgType.ConfirmationAck
        |"AV"B -> MsgType.SettlementInstructionRequest
        |"AW"B -> MsgType.AssignmentReport
        |"AX"B -> MsgType.CollateralRequest
        |"AY"B -> MsgType.CollateralAssignment
        |"AZ"B -> MsgType.CollateralResponse
        |"BA"B -> MsgType.CollateralReport
        |"BB"B -> MsgType.CollateralInquiry
        |"BC"B -> MsgType.NetworkStatusRequest
        |"BD"B -> MsgType.NetworkStatusResponse
        |"BE"B -> MsgType.UserRequest
        |"BF"B -> MsgType.UserResponse
        |"BG"B -> MsgType.CollateralInquiryAck
        |"BH"B -> MsgType.ConfirmationRequest
        | x -> failwith (sprintf "ReadMsgType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMsgType (dest:byte array) (nextFreeIdx:int) (xxIn:MsgType) : int =
    match xxIn with
    | MsgType.Heartbeat ->
        let tag = "35=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TestRequest ->
        let tag = "35=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ResendRequest ->
        let tag = "35=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Reject ->
        let tag = "35=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SequenceReset ->
        let tag = "35=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Logout ->
        let tag = "35=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.IndicationOfInterest ->
        let tag = "35=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Advertisement ->
        let tag = "35=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ExecutionReport ->
        let tag = "35=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelReject ->
        let tag = "35=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Logon ->
        let tag = "35=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.News ->
        let tag = "35=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Email ->
        let tag = "35=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderSingle ->
        let tag = "35=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderList ->
        let tag = "35=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelRequest ->
        let tag = "35=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelReplaceRequest ->
        let tag = "35=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderStatusRequest ->
        let tag = "35=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationInstruction ->
        let tag = "35=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListCancelRequest ->
        let tag = "35=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListExecute ->
        let tag = "35=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStatusRequest ->
        let tag = "35=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStatus ->
        let tag = "35=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationInstructionAck ->
        let tag = "35=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DontKnowTrade ->
        let tag = "35=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteRequest ->
        let tag = "35=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Quote ->
        let tag = "35=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SettlementInstructions ->
        let tag = "35=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataRequest ->
        let tag = "35=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataSnapshotFullRefresh ->
        let tag = "35=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataIncrementalRefresh ->
        let tag = "35=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataRequestReject ->
        let tag = "35=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteCancel ->
        let tag = "35=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteStatusRequest ->
        let tag = "35=a"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MassQuoteAcknowledgement ->
        let tag = "35=b"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityDefinitionRequest ->
        let tag = "35=c"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityDefinition ->
        let tag = "35=d"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityStatusRequest ->
        let tag = "35=e"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityStatus ->
        let tag = "35=f"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradingSessionStatusRequest ->
        let tag = "35=g"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradingSessionStatus ->
        let tag = "35=h"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MassQuote ->
        let tag = "35=i"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BusinessMessageReject ->
        let tag = "35=j"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BidRequest ->
        let tag = "35=k"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BidResponse ->
        let tag = "35=l"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStrikePrice ->
        let tag = "35=m"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.XmlMessage ->
        let tag = "35=n"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RegistrationInstructions ->
        let tag = "35=o"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RegistrationInstructionsResponse ->
        let tag = "35=p"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassCancelRequest ->
        let tag = "35=q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassCancelReport ->
        let tag = "35=r"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NewOrderCross ->
        let tag = "35=s"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CrossOrderCancelReplaceRequest ->
        let tag = "35=t"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CrossOrderCancelRequest ->
        let tag = "35=u"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityTypeRequest ->
        let tag = "35=v"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityTypes ->
        let tag = "35=w"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityListRequest ->
        let tag = "35=x"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityList ->
        let tag = "35=y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DerivativeSecurityListRequest ->
        let tag = "35=z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DerivativeSecurityList ->
        let tag = "35=AA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NewOrderMultileg ->
        let tag = "35=AB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MultilegOrderCancelReplace ->
        let tag = "35=AC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportRequest ->
        let tag = "35=AD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReport ->
        let tag = "35=AE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassStatusRequest ->
        let tag = "35=AF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteRequestReject ->
        let tag = "35=AG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RfqRequest ->
        let tag = "35=AH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteStatusReport ->
        let tag = "35=AI"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteResponse ->
        let tag = "35=AJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Confirmation ->
        let tag = "35=AK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionMaintenanceRequest ->
        let tag = "35=AL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionMaintenanceReport ->
        let tag = "35=AM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RequestForPositions ->
        let tag = "35=AN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RequestForPositionsAck ->
        let tag = "35=AO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionReport ->
        let tag = "35=AP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportRequestAck ->
        let tag = "35=AQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportAck ->
        let tag = "35=AR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationReport ->
        let tag = "35=AS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationReportAck ->
        let tag = "35=AT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ConfirmationAck ->
        let tag = "35=AU"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SettlementInstructionRequest ->
        let tag = "35=AV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AssignmentReport ->
        let tag = "35=AW"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralRequest ->
        let tag = "35=AX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralAssignment ->
        let tag = "35=AY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralResponse ->
        let tag = "35=AZ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralReport ->
        let tag = "35=BA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralInquiry ->
        let tag = "35=BB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NetworkStatusRequest ->
        let tag = "35=BC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NetworkStatusResponse ->
        let tag = "35=BD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.UserRequest ->
        let tag = "35=BE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.UserResponse ->
        let tag = "35=BF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralInquiryAck ->
        let tag = "35=BG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ConfirmationRequest ->
        let tag = "35=BH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNewSeqNo (pos:int) (bs:byte[]) : (int*NewSeqNo) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NewSeqNo.NewSeqNo


let WriteNewSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:NewSeqNo) : int = 
   let tag = "36="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderID (pos:int) (bs:byte[]) : (int*OrderID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrderID.OrderID


let WriteOrderID (dest:byte []) (nextFreeIdx:int) (valIn:OrderID) : int = 
   let tag = "37="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderQty (pos:int) (bs:byte[]) : (int*OrderQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderQty.OrderQty


let WriteOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderQty) : int = 
   let tag = "38="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrdStatus (pos:int) (bs:byte[]) : (int * OrdStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> OrdStatus.New
        |"1"B -> OrdStatus.PartiallyFilled
        |"2"B -> OrdStatus.Filled
        |"3"B -> OrdStatus.DoneForDay
        |"4"B -> OrdStatus.Canceled
        |"5"B -> OrdStatus.Replaced
        |"6"B -> OrdStatus.PendingCancel
        |"7"B -> OrdStatus.Stopped
        |"8"B -> OrdStatus.Rejected
        |"9"B -> OrdStatus.Suspended
        |"A"B -> OrdStatus.PendingNew
        |"B"B -> OrdStatus.Calculated
        |"C"B -> OrdStatus.Expired
        |"D"B -> OrdStatus.AcceptedForBidding
        |"E"B -> OrdStatus.PendingReplace
        | x -> failwith (sprintf "ReadOrdStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOrdStatus (dest:byte array) (nextFreeIdx:int) (xxIn:OrdStatus) : int =
    match xxIn with
    | OrdStatus.New ->
        let tag = "39=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PartiallyFilled ->
        let tag = "39=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Filled ->
        let tag = "39=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.DoneForDay ->
        let tag = "39=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Canceled ->
        let tag = "39=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Replaced ->
        let tag = "39=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingCancel ->
        let tag = "39=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Stopped ->
        let tag = "39=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Rejected ->
        let tag = "39=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Suspended ->
        let tag = "39=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingNew ->
        let tag = "39=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Calculated ->
        let tag = "39=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Expired ->
        let tag = "39=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.AcceptedForBidding ->
        let tag = "39=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingReplace ->
        let tag = "39=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrdType (pos:int) (bs:byte[]) : (int * OrdType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> OrdType.Market
        |"2"B -> OrdType.Limit
        |"3"B -> OrdType.Stop
        |"4"B -> OrdType.StopLimit
        |"5"B -> OrdType.MarketOnClose
        |"6"B -> OrdType.WithOrWithout
        |"7"B -> OrdType.LimitOrBetter
        |"8"B -> OrdType.LimitWithOrWithout
        |"9"B -> OrdType.OnBasis
        |"A"B -> OrdType.OnClose
        |"B"B -> OrdType.LimitOnClose
        |"C"B -> OrdType.ForexMarket
        |"D"B -> OrdType.PreviouslyQuoted
        |"E"B -> OrdType.PreviouslyIndicated
        |"F"B -> OrdType.ForexLimit
        |"G"B -> OrdType.ForexSwap
        |"H"B -> OrdType.ForexPreviouslyQuoted
        |"I"B -> OrdType.Funari
        |"J"B -> OrdType.MarketIfTouched
        |"K"B -> OrdType.MarketWithLeftoverAsLimit
        |"L"B -> OrdType.PreviousFundValuationPoint
        |"M"B -> OrdType.NextFundValuationPoint
        |"P"B -> OrdType.Pegged
        | x -> failwith (sprintf "ReadOrdType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOrdType (dest:byte array) (nextFreeIdx:int) (xxIn:OrdType) : int =
    match xxIn with
    | OrdType.Market ->
        let tag = "40=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Limit ->
        let tag = "40=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Stop ->
        let tag = "40=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.StopLimit ->
        let tag = "40=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketOnClose ->
        let tag = "40=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.WithOrWithout ->
        let tag = "40=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitOrBetter ->
        let tag = "40=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitWithOrWithout ->
        let tag = "40=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.OnBasis ->
        let tag = "40=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.OnClose ->
        let tag = "40=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitOnClose ->
        let tag = "40=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexMarket ->
        let tag = "40=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviouslyQuoted ->
        let tag = "40=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviouslyIndicated ->
        let tag = "40=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexLimit ->
        let tag = "40=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexSwap ->
        let tag = "40=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexPreviouslyQuoted ->
        let tag = "40=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Funari ->
        let tag = "40=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketIfTouched ->
        let tag = "40=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketWithLeftoverAsLimit ->
        let tag = "40=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviousFundValuationPoint ->
        let tag = "40=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.NextFundValuationPoint ->
        let tag = "40=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Pegged ->
        let tag = "40=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigClOrdID (pos:int) (bs:byte[]) : (int*OrigClOrdID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigClOrdID.OrigClOrdID


let WriteOrigClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:OrigClOrdID) : int = 
   let tag = "41="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrigTime (pos:int) (bs:byte[]) : (int*OrigTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigTime.OrigTime


let WriteOrigTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigTime) : int = 
   let tag = "42="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPossDupFlag (pos:int) (bs:byte[]) : (int*PossDupFlag) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) PossDupFlag.PossDupFlag


let WritePossDupFlag (dest:byte []) (nextFreeIdx:int) (valIn:PossDupFlag) : int = 
   let tag = "43="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPrice (pos:int) (bs:byte[]) : (int*Price) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Price.Price


let WritePrice (dest:byte []) (nextFreeIdx:int) (valIn:Price) : int = 
   let tag = "44="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRefSeqNum (pos:int) (bs:byte[]) : (int*RefSeqNum) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RefSeqNum.RefSeqNum


let WriteRefSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:RefSeqNum) : int = 
   let tag = "45="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityID (pos:int) (bs:byte[]) : (int*SecurityID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityID.SecurityID


let WriteSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityID) : int = 
   let tag = "48="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSenderCompID (pos:int) (bs:byte[]) : (int*SenderCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SenderCompID.SenderCompID


let WriteSenderCompID (dest:byte []) (nextFreeIdx:int) (valIn:SenderCompID) : int = 
   let tag = "49="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSenderSubID (pos:int) (bs:byte[]) : (int*SenderSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SenderSubID.SenderSubID


let WriteSenderSubID (dest:byte []) (nextFreeIdx:int) (valIn:SenderSubID) : int = 
   let tag = "50="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSendingTime (pos:int) (bs:byte[]) : (int*SendingTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SendingTime.SendingTime


let WriteSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:SendingTime) : int = 
   let tag = "52="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuantity (pos:int) (bs:byte[]) : (int*Quantity) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Quantity.Quantity


let WriteQuantity (dest:byte []) (nextFreeIdx:int) (valIn:Quantity) : int = 
   let tag = "53="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSide (pos:int) (bs:byte[]) : (int * Side) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> Side.Buy
        |"2"B -> Side.Sell
        |"3"B -> Side.BuyMinus
        |"4"B -> Side.SellPlus
        |"5"B -> Side.SellShort
        |"6"B -> Side.SellShortExempt
        |"7"B -> Side.Undisclosed
        |"8"B -> Side.Cross
        |"9"B -> Side.CrossShort
        |"A"B -> Side.CrossShortExempt
        |"B"B -> Side.AsDefined
        |"C"B -> Side.Opposite
        |"D"B -> Side.Subscribe
        |"E"B -> Side.Redeem
        |"F"B -> Side.Lend
        |"G"B -> Side.Borrow
        | x -> failwith (sprintf "ReadSide unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSide (dest:byte array) (nextFreeIdx:int) (xxIn:Side) : int =
    match xxIn with
    | Side.Buy ->
        let tag = "54=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Sell ->
        let tag = "54=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.BuyMinus ->
        let tag = "54=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellPlus ->
        let tag = "54=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellShort ->
        let tag = "54=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellShortExempt ->
        let tag = "54=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Undisclosed ->
        let tag = "54=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Cross ->
        let tag = "54=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.CrossShort ->
        let tag = "54=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.CrossShortExempt ->
        let tag = "54=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.AsDefined ->
        let tag = "54=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Opposite ->
        let tag = "54=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Subscribe ->
        let tag = "54=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Redeem ->
        let tag = "54=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Lend ->
        let tag = "54=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Borrow ->
        let tag = "54=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSymbol (pos:int) (bs:byte[]) : (int*Symbol) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Symbol.Symbol


let WriteSymbol (dest:byte []) (nextFreeIdx:int) (valIn:Symbol) : int = 
   let tag = "55="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTargetCompID (pos:int) (bs:byte[]) : (int*TargetCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TargetCompID.TargetCompID


let WriteTargetCompID (dest:byte []) (nextFreeIdx:int) (valIn:TargetCompID) : int = 
   let tag = "56="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTargetSubID (pos:int) (bs:byte[]) : (int*TargetSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TargetSubID.TargetSubID


let WriteTargetSubID (dest:byte []) (nextFreeIdx:int) (valIn:TargetSubID) : int = 
   let tag = "57="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadText (pos:int) (bs:byte[]) : (int*Text) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Text.Text


let WriteText (dest:byte []) (nextFreeIdx:int) (valIn:Text) : int = 
   let tag = "58="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTimeInForce (pos:int) (bs:byte[]) : (int * TimeInForce) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TimeInForce.Day
        |"1"B -> TimeInForce.GoodTillCancel
        |"2"B -> TimeInForce.AtTheOpening
        |"3"B -> TimeInForce.ImmediateOrCancel
        |"4"B -> TimeInForce.FillOrKill
        |"5"B -> TimeInForce.GoodTillCrossing
        |"6"B -> TimeInForce.GoodTillDate
        |"7"B -> TimeInForce.AtTheClose
        | x -> failwith (sprintf "ReadTimeInForce unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTimeInForce (dest:byte array) (nextFreeIdx:int) (xxIn:TimeInForce) : int =
    match xxIn with
    | TimeInForce.Day ->
        let tag = "59=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillCancel ->
        let tag = "59=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.AtTheOpening ->
        let tag = "59=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.ImmediateOrCancel ->
        let tag = "59=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.FillOrKill ->
        let tag = "59=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillCrossing ->
        let tag = "59=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillDate ->
        let tag = "59=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.AtTheClose ->
        let tag = "59=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTransactTime (pos:int) (bs:byte[]) : (int*TransactTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TransactTime.TransactTime


let WriteTransactTime (dest:byte []) (nextFreeIdx:int) (valIn:TransactTime) : int = 
   let tag = "60="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUrgency (pos:int) (bs:byte[]) : (int * Urgency) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> Urgency.Normal
        |"1"B -> Urgency.Flash
        |"2"B -> Urgency.Background
        | x -> failwith (sprintf "ReadUrgency unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteUrgency (dest:byte array) (nextFreeIdx:int) (xxIn:Urgency) : int =
    match xxIn with
    | Urgency.Normal ->
        let tag = "61=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Urgency.Flash ->
        let tag = "61=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Urgency.Background ->
        let tag = "61=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadValidUntilTime (pos:int) (bs:byte[]) : (int*ValidUntilTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ValidUntilTime.ValidUntilTime


let WriteValidUntilTime (dest:byte []) (nextFreeIdx:int) (valIn:ValidUntilTime) : int = 
   let tag = "62="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlType (pos:int) (bs:byte[]) : (int * SettlType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SettlType.Regular
        |"1"B -> SettlType.Cash
        |"2"B -> SettlType.NextDay
        |"3"B -> SettlType.TPlus2
        |"4"B -> SettlType.TPlus3
        |"5"B -> SettlType.TPlus4
        |"6"B -> SettlType.Future
        |"7"B -> SettlType.WhenAndIfIssued
        |"8"B -> SettlType.SellersOption
        |"9"B -> SettlType.TPlus5
        | x -> failwith (sprintf "ReadSettlType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlType) : int =
    match xxIn with
    | SettlType.Regular ->
        let tag = "63=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.Cash ->
        let tag = "63=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.NextDay ->
        let tag = "63=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus2 ->
        let tag = "63=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus3 ->
        let tag = "63=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus4 ->
        let tag = "63=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.Future ->
        let tag = "63=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.WhenAndIfIssued ->
        let tag = "63=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.SellersOption ->
        let tag = "63=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus5 ->
        let tag = "63=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSettlDate (pos:int) (bs:byte[]) : (int*SettlDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlDate.SettlDate


let WriteSettlDate (dest:byte []) (nextFreeIdx:int) (valIn:SettlDate) : int = 
   let tag = "64="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSymbolSfx (pos:int) (bs:byte[]) : (int * SymbolSfx) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"WI"B -> SymbolSfx.WhenIssued
        |"CD"B -> SymbolSfx.AEucpWithLumpSumInterest
        | x -> failwith (sprintf "ReadSymbolSfx unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSymbolSfx (dest:byte array) (nextFreeIdx:int) (xxIn:SymbolSfx) : int =
    match xxIn with
    | SymbolSfx.WhenIssued ->
        let tag = "65=WI"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SymbolSfx.AEucpWithLumpSumInterest ->
        let tag = "65=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadListID (pos:int) (bs:byte[]) : (int*ListID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ListID.ListID


let WriteListID (dest:byte []) (nextFreeIdx:int) (valIn:ListID) : int = 
   let tag = "66="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListSeqNo (pos:int) (bs:byte[]) : (int*ListSeqNo) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) ListSeqNo.ListSeqNo


let WriteListSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:ListSeqNo) : int = 
   let tag = "67="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotNoOrders (pos:int) (bs:byte[]) : (int*TotNoOrders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoOrders.TotNoOrders


let WriteTotNoOrders (dest:byte []) (nextFreeIdx:int) (valIn:TotNoOrders) : int = 
   let tag = "68="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListExecInst (pos:int) (bs:byte[]) : (int*ListExecInst) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ListExecInst.ListExecInst


let WriteListExecInst (dest:byte []) (nextFreeIdx:int) (valIn:ListExecInst) : int = 
   let tag = "69="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocID (pos:int) (bs:byte[]) : (int*AllocID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocID.AllocID


let WriteAllocID (dest:byte []) (nextFreeIdx:int) (valIn:AllocID) : int = 
   let tag = "70="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocTransType (pos:int) (bs:byte[]) : (int * AllocTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocTransType.New
        |"1"B -> AllocTransType.Replace
        |"2"B -> AllocTransType.Cancel
        | x -> failwith (sprintf "ReadAllocTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocTransType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocTransType) : int =
    match xxIn with
    | AllocTransType.New ->
        let tag = "71=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocTransType.Replace ->
        let tag = "71=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocTransType.Cancel ->
        let tag = "71=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRefAllocID (pos:int) (bs:byte[]) : (int*RefAllocID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RefAllocID.RefAllocID


let WriteRefAllocID (dest:byte []) (nextFreeIdx:int) (valIn:RefAllocID) : int = 
   let tag = "72="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoOrders (pos:int) (bs:byte[]) : (int*NoOrders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoOrders.NoOrders


let WriteNoOrders (dest:byte []) (nextFreeIdx:int) (valIn:NoOrders) : int = 
   let tag = "73="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAvgPxPrecision (pos:int) (bs:byte[]) : (int*AvgPxPrecision) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AvgPxPrecision.AvgPxPrecision


let WriteAvgPxPrecision (dest:byte []) (nextFreeIdx:int) (valIn:AvgPxPrecision) : int = 
   let tag = "74="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeDate (pos:int) (bs:byte[]) : (int*TradeDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeDate.TradeDate


let WriteTradeDate (dest:byte []) (nextFreeIdx:int) (valIn:TradeDate) : int = 
   let tag = "75="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPositionEffect (pos:int) (bs:byte[]) : (int * PositionEffect) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"O"B -> PositionEffect.Open
        |"C"B -> PositionEffect.Close
        |"R"B -> PositionEffect.Rolled
        |"F"B -> PositionEffect.Fifo
        | x -> failwith (sprintf "ReadPositionEffect unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePositionEffect (dest:byte array) (nextFreeIdx:int) (xxIn:PositionEffect) : int =
    match xxIn with
    | PositionEffect.Open ->
        let tag = "77=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Close ->
        let tag = "77=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Rolled ->
        let tag = "77=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Fifo ->
        let tag = "77=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoAllocs (pos:int) (bs:byte[]) : (int*NoAllocs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoAllocs.NoAllocs


let WriteNoAllocs (dest:byte []) (nextFreeIdx:int) (valIn:NoAllocs) : int = 
   let tag = "78="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocAccount (pos:int) (bs:byte[]) : (int*AllocAccount) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocAccount.AllocAccount


let WriteAllocAccount (dest:byte []) (nextFreeIdx:int) (valIn:AllocAccount) : int = 
   let tag = "79="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocQty (pos:int) (bs:byte[]) : (int*AllocQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AllocQty.AllocQty


let WriteAllocQty (dest:byte []) (nextFreeIdx:int) (valIn:AllocQty) : int = 
   let tag = "80="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadProcessCode (pos:int) (bs:byte[]) : (int * ProcessCode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ProcessCode.Regular
        |"1"B -> ProcessCode.SoftDollar
        |"2"B -> ProcessCode.StepIn
        |"3"B -> ProcessCode.StepOut
        |"4"B -> ProcessCode.SoftDollarStepIn
        |"5"B -> ProcessCode.SoftDollarStepOut
        |"6"B -> ProcessCode.PlanSponsor
        | x -> failwith (sprintf "ReadProcessCode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteProcessCode (dest:byte array) (nextFreeIdx:int) (xxIn:ProcessCode) : int =
    match xxIn with
    | ProcessCode.Regular ->
        let tag = "81=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollar ->
        let tag = "81=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.StepIn ->
        let tag = "81=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.StepOut ->
        let tag = "81=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollarStepIn ->
        let tag = "81=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollarStepOut ->
        let tag = "81=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.PlanSponsor ->
        let tag = "81=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoRpts (pos:int) (bs:byte[]) : (int*NoRpts) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoRpts.NoRpts


let WriteNoRpts (dest:byte []) (nextFreeIdx:int) (valIn:NoRpts) : int = 
   let tag = "82="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRptSeq (pos:int) (bs:byte[]) : (int*RptSeq) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RptSeq.RptSeq


let WriteRptSeq (dest:byte []) (nextFreeIdx:int) (valIn:RptSeq) : int = 
   let tag = "83="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCxlQty (pos:int) (bs:byte[]) : (int*CxlQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) CxlQty.CxlQty


let WriteCxlQty (dest:byte []) (nextFreeIdx:int) (valIn:CxlQty) : int = 
   let tag = "84="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoDlvyInst (pos:int) (bs:byte[]) : (int*NoDlvyInst) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoDlvyInst.NoDlvyInst


let WriteNoDlvyInst (dest:byte []) (nextFreeIdx:int) (valIn:NoDlvyInst) : int = 
   let tag = "85="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocStatus (pos:int) (bs:byte[]) : (int * AllocStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocStatus.Accepted
        |"1"B -> AllocStatus.BlockLevelReject
        |"2"B -> AllocStatus.AccountLevelReject
        |"3"B -> AllocStatus.Received
        |"4"B -> AllocStatus.Incomplete
        |"5"B -> AllocStatus.RejectedByIntermediary
        | x -> failwith (sprintf "ReadAllocStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocStatus (dest:byte array) (nextFreeIdx:int) (xxIn:AllocStatus) : int =
    match xxIn with
    | AllocStatus.Accepted ->
        let tag = "87=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.BlockLevelReject ->
        let tag = "87=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.AccountLevelReject ->
        let tag = "87=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.Received ->
        let tag = "87=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.Incomplete ->
        let tag = "87=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.RejectedByIntermediary ->
        let tag = "87=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocRejCode (pos:int) (bs:byte[]) : (int * AllocRejCode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocRejCode.UnknownAccount
        |"1"B -> AllocRejCode.IncorrectQuantity
        |"2"B -> AllocRejCode.IncorrectAveragePrice
        |"3"B -> AllocRejCode.UnknownExecutingBrokerMnemonic
        |"4"B -> AllocRejCode.CommissionDifference
        |"5"B -> AllocRejCode.UnknownOrderid
        |"6"B -> AllocRejCode.UnknownListid
        |"7"B -> AllocRejCode.Other
        |"8"B -> AllocRejCode.IncorrectAllocatedQuantity
        |"9"B -> AllocRejCode.CalculationDifference
        |"10"B -> AllocRejCode.UnknownOrStaleExecId
        |"11"B -> AllocRejCode.MismatchedDataValue
        |"12"B -> AllocRejCode.UnknownClordid
        |"13"B -> AllocRejCode.WarehouseRequestRejected
        | x -> failwith (sprintf "ReadAllocRejCode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocRejCode (dest:byte array) (nextFreeIdx:int) (xxIn:AllocRejCode) : int =
    match xxIn with
    | AllocRejCode.UnknownAccount ->
        let tag = "88=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectQuantity ->
        let tag = "88=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectAveragePrice ->
        let tag = "88=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownExecutingBrokerMnemonic ->
        let tag = "88=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.CommissionDifference ->
        let tag = "88=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownOrderid ->
        let tag = "88=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownListid ->
        let tag = "88=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.Other ->
        let tag = "88=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectAllocatedQuantity ->
        let tag = "88=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.CalculationDifference ->
        let tag = "88=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownOrStaleExecId ->
        let tag = "88=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.MismatchedDataValue ->
        let tag = "88=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownClordid ->
        let tag = "88=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.WarehouseRequestRejected ->
        let tag = "88=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSignature (pos:int) (bs:byte[]) : (int*Signature) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Signature.Signature


let WriteSignature (dest:byte []) (nextFreeIdx:int) (valIn:Signature) : int = 
   let tag = "89="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteSecureData (dest:byte []) (nextFreeIdx:int) (fld:SecureData) : int =
    // write the string length part of the compound msg
    let lenTag = "90="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadSecureData (pos:int) (bs:byte[]) : (int * SecureData) =
    ReadLengthStringCompoundField "91"B (pos:int) (bs:byte[]) SecureData.SecureData


let ReadSignatureLength (pos:int) (bs:byte[]) : (int*SignatureLength) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SignatureLength.SignatureLength


let WriteSignatureLength (dest:byte []) (nextFreeIdx:int) (valIn:SignatureLength) : int = 
   let tag = "93="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEmailType (pos:int) (bs:byte[]) : (int * EmailType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> EmailType.New
        |"1"B -> EmailType.Reply
        |"2"B -> EmailType.AdminReply
        | x -> failwith (sprintf "ReadEmailType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteEmailType (dest:byte array) (nextFreeIdx:int) (xxIn:EmailType) : int =
    match xxIn with
    | EmailType.New ->
        let tag = "94=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EmailType.Reply ->
        let tag = "94=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EmailType.AdminReply ->
        let tag = "94=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRawDataLength (pos:int) (bs:byte[]) : (int*RawDataLength) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RawDataLength.RawDataLength


let WriteRawDataLength (dest:byte []) (nextFreeIdx:int) (valIn:RawDataLength) : int = 
   let tag = "95="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRawData (pos:int) (bs:byte[]) : (int*RawData) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RawData.RawData


let WriteRawData (dest:byte []) (nextFreeIdx:int) (valIn:RawData) : int = 
   let tag = "96="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPossResend (pos:int) (bs:byte[]) : (int*PossResend) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) PossResend.PossResend


let WritePossResend (dest:byte []) (nextFreeIdx:int) (valIn:PossResend) : int = 
   let tag = "97="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEncryptMethod (pos:int) (bs:byte[]) : (int * EncryptMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> EncryptMethod.NoneOther
        |"1"B -> EncryptMethod.Pkcs
        |"2"B -> EncryptMethod.Des
        |"3"B -> EncryptMethod.PkcsDes
        |"4"B -> EncryptMethod.PgpDes
        |"5"B -> EncryptMethod.PgpDesMd5
        |"6"B -> EncryptMethod.PemDesMd5
        | x -> failwith (sprintf "ReadEncryptMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteEncryptMethod (dest:byte array) (nextFreeIdx:int) (xxIn:EncryptMethod) : int =
    match xxIn with
    | EncryptMethod.NoneOther ->
        let tag = "98=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.Pkcs ->
        let tag = "98=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.Des ->
        let tag = "98=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PkcsDes ->
        let tag = "98=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PgpDes ->
        let tag = "98=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PgpDesMd5 ->
        let tag = "98=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PemDesMd5 ->
        let tag = "98=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStopPx (pos:int) (bs:byte[]) : (int*StopPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) StopPx.StopPx


let WriteStopPx (dest:byte []) (nextFreeIdx:int) (valIn:StopPx) : int = 
   let tag = "99="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExDestination (pos:int) (bs:byte[]) : (int*ExDestination) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExDestination.ExDestination


let WriteExDestination (dest:byte []) (nextFreeIdx:int) (valIn:ExDestination) : int = 
   let tag = "100="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCxlRejReason (pos:int) (bs:byte[]) : (int * CxlRejReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CxlRejReason.TooLateToCancel
        |"1"B -> CxlRejReason.UnknownOrder
        |"2"B -> CxlRejReason.BrokerExchangeOption
        |"3"B -> CxlRejReason.OrderAlreadyInPendingCancelOrPendingReplaceStatus
        |"4"B -> CxlRejReason.UnableToProcessOrderMassCancelRequest
        |"5"B -> CxlRejReason.OrigordmodtimeDidNotMatchLastTransacttimeOfOrder
        |"6"B -> CxlRejReason.DuplicateClordidReceived
        |"99"B -> CxlRejReason.Other
        | x -> failwith (sprintf "ReadCxlRejReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCxlRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:CxlRejReason) : int =
    match xxIn with
    | CxlRejReason.TooLateToCancel ->
        let tag = "102=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.UnknownOrder ->
        let tag = "102=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.BrokerExchangeOption ->
        let tag = "102=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.OrderAlreadyInPendingCancelOrPendingReplaceStatus ->
        let tag = "102=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.UnableToProcessOrderMassCancelRequest ->
        let tag = "102=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.OrigordmodtimeDidNotMatchLastTransacttimeOfOrder ->
        let tag = "102=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.DuplicateClordidReceived ->
        let tag = "102=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.Other ->
        let tag = "102=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrdRejReason (pos:int) (bs:byte[]) : (int * OrdRejReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> OrdRejReason.BrokerExchangeOption
        |"1"B -> OrdRejReason.UnknownSymbol
        |"2"B -> OrdRejReason.ExchangeClosed
        |"3"B -> OrdRejReason.OrderExceedsLimit
        |"4"B -> OrdRejReason.TooLateToEnter
        |"5"B -> OrdRejReason.UnknownOrder
        |"6"B -> OrdRejReason.DuplicateOrder
        |"7"B -> OrdRejReason.DuplicateOfAVerballyCommunicatedOrder
        |"8"B -> OrdRejReason.StaleOrder
        |"9"B -> OrdRejReason.TradeAlongRequired
        |"10"B -> OrdRejReason.InvalidInvestorId
        |"11"B -> OrdRejReason.UnsupportedOrderCharacteristic
        |"12"B -> OrdRejReason.SurveillenceOption
        |"13"B -> OrdRejReason.IncorrectQuantity
        |"14"B -> OrdRejReason.IncorrectAllocatedQuantity
        |"15"B -> OrdRejReason.UnknownAccount
        |"99"B -> OrdRejReason.Other
        | x -> failwith (sprintf "ReadOrdRejReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOrdRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:OrdRejReason) : int =
    match xxIn with
    | OrdRejReason.BrokerExchangeOption ->
        let tag = "103=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownSymbol ->
        let tag = "103=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.ExchangeClosed ->
        let tag = "103=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.OrderExceedsLimit ->
        let tag = "103=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.TooLateToEnter ->
        let tag = "103=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownOrder ->
        let tag = "103=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.DuplicateOrder ->
        let tag = "103=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.DuplicateOfAVerballyCommunicatedOrder ->
        let tag = "103=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.StaleOrder ->
        let tag = "103=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.TradeAlongRequired ->
        let tag = "103=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.InvalidInvestorId ->
        let tag = "103=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnsupportedOrderCharacteristic ->
        let tag = "103=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.SurveillenceOption ->
        let tag = "103=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.IncorrectQuantity ->
        let tag = "103=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.IncorrectAllocatedQuantity ->
        let tag = "103=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownAccount ->
        let tag = "103=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.Other ->
        let tag = "103=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIQualifier (pos:int) (bs:byte[]) : (int * IOIQualifier) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> IOIQualifier.AllOrNone
        |"B"B -> IOIQualifier.MarketOnClose
        |"C"B -> IOIQualifier.AtTheClose
        |"D"B -> IOIQualifier.Vwap
        |"I"B -> IOIQualifier.InTouchWith
        |"L"B -> IOIQualifier.Limit
        |"M"B -> IOIQualifier.MoreBehind
        |"O"B -> IOIQualifier.AtTheOpen
        |"P"B -> IOIQualifier.TakingAPosition
        |"Q"B -> IOIQualifier.AtTheMarket
        |"R"B -> IOIQualifier.ReadyToTrade
        |"S"B -> IOIQualifier.PortfolioShown
        |"T"B -> IOIQualifier.ThroughTheDay
        |"V"B -> IOIQualifier.Versus
        |"W"B -> IOIQualifier.IndicationWorkingAway
        |"X"B -> IOIQualifier.CrossingOpportunity
        |"Y"B -> IOIQualifier.AtTheMidpoint
        |"Z"B -> IOIQualifier.PreOpen
        | x -> failwith (sprintf "ReadIOIQualifier unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteIOIQualifier (dest:byte array) (nextFreeIdx:int) (xxIn:IOIQualifier) : int =
    match xxIn with
    | IOIQualifier.AllOrNone ->
        let tag = "104=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.MarketOnClose ->
        let tag = "104=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheClose ->
        let tag = "104=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Vwap ->
        let tag = "104=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.InTouchWith ->
        let tag = "104=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Limit ->
        let tag = "104=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.MoreBehind ->
        let tag = "104=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheOpen ->
        let tag = "104=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.TakingAPosition ->
        let tag = "104=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheMarket ->
        let tag = "104=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.ReadyToTrade ->
        let tag = "104=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.PortfolioShown ->
        let tag = "104=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.ThroughTheDay ->
        let tag = "104=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Versus ->
        let tag = "104=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.IndicationWorkingAway ->
        let tag = "104=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.CrossingOpportunity ->
        let tag = "104=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheMidpoint ->
        let tag = "104=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.PreOpen ->
        let tag = "104=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWaveNo (pos:int) (bs:byte[]) : (int*WaveNo) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) WaveNo.WaveNo


let WriteWaveNo (dest:byte []) (nextFreeIdx:int) (valIn:WaveNo) : int = 
   let tag = "105="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIssuer (pos:int) (bs:byte[]) : (int*Issuer) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Issuer.Issuer


let WriteIssuer (dest:byte []) (nextFreeIdx:int) (valIn:Issuer) : int = 
   let tag = "106="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityDesc (pos:int) (bs:byte[]) : (int*SecurityDesc) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityDesc.SecurityDesc


let WriteSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:SecurityDesc) : int = 
   let tag = "107="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHeartBtInt (pos:int) (bs:byte[]) : (int*HeartBtInt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) HeartBtInt.HeartBtInt


let WriteHeartBtInt (dest:byte []) (nextFreeIdx:int) (valIn:HeartBtInt) : int = 
   let tag = "108="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMinQty (pos:int) (bs:byte[]) : (int*MinQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MinQty.MinQty


let WriteMinQty (dest:byte []) (nextFreeIdx:int) (valIn:MinQty) : int = 
   let tag = "110="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMaxFloor (pos:int) (bs:byte[]) : (int*MaxFloor) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MaxFloor.MaxFloor


let WriteMaxFloor (dest:byte []) (nextFreeIdx:int) (valIn:MaxFloor) : int = 
   let tag = "111="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTestReqID (pos:int) (bs:byte[]) : (int*TestReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TestReqID.TestReqID


let WriteTestReqID (dest:byte []) (nextFreeIdx:int) (valIn:TestReqID) : int = 
   let tag = "112="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadReportToExch (pos:int) (bs:byte[]) : (int*ReportToExch) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ReportToExch.ReportToExch


let WriteReportToExch (dest:byte []) (nextFreeIdx:int) (valIn:ReportToExch) : int = 
   let tag = "113="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLocateReqd (pos:int) (bs:byte[]) : (int*LocateReqd) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) LocateReqd.LocateReqd


let WriteLocateReqd (dest:byte []) (nextFreeIdx:int) (valIn:LocateReqd) : int = 
   let tag = "114="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOnBehalfOfCompID (pos:int) (bs:byte[]) : (int*OnBehalfOfCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OnBehalfOfCompID.OnBehalfOfCompID


let WriteOnBehalfOfCompID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfCompID) : int = 
   let tag = "115="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOnBehalfOfSubID (pos:int) (bs:byte[]) : (int*OnBehalfOfSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OnBehalfOfSubID.OnBehalfOfSubID


let WriteOnBehalfOfSubID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfSubID) : int = 
   let tag = "116="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteID (pos:int) (bs:byte[]) : (int*QuoteID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteID.QuoteID


let WriteQuoteID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteID) : int = 
   let tag = "117="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetMoney (pos:int) (bs:byte[]) : (int*NetMoney) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NetMoney.NetMoney


let WriteNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:NetMoney) : int = 
   let tag = "118="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrAmt (pos:int) (bs:byte[]) : (int*SettlCurrAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SettlCurrAmt.SettlCurrAmt


let WriteSettlCurrAmt (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrAmt) : int = 
   let tag = "119="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrency (pos:int) (bs:byte[]) : (int*SettlCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlCurrency.SettlCurrency


let WriteSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrency) : int = 
   let tag = "120="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadForexReq (pos:int) (bs:byte[]) : (int*ForexReq) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ForexReq.ForexReq


let WriteForexReq (dest:byte []) (nextFreeIdx:int) (valIn:ForexReq) : int = 
   let tag = "121="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrigSendingTime (pos:int) (bs:byte[]) : (int*OrigSendingTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigSendingTime.OrigSendingTime


let WriteOrigSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigSendingTime) : int = 
   let tag = "122="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadGapFillFlag (pos:int) (bs:byte[]) : (int*GapFillFlag) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) GapFillFlag.GapFillFlag


let WriteGapFillFlag (dest:byte []) (nextFreeIdx:int) (valIn:GapFillFlag) : int = 
   let tag = "123="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoExecs (pos:int) (bs:byte[]) : (int*NoExecs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoExecs.NoExecs


let WriteNoExecs (dest:byte []) (nextFreeIdx:int) (valIn:NoExecs) : int = 
   let tag = "124="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExpireTime (pos:int) (bs:byte[]) : (int*ExpireTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExpireTime.ExpireTime


let WriteExpireTime (dest:byte []) (nextFreeIdx:int) (valIn:ExpireTime) : int = 
   let tag = "126="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDKReason (pos:int) (bs:byte[]) : (int * DKReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> DKReason.UnknownSymbol
        |"B"B -> DKReason.WrongSide
        |"C"B -> DKReason.QuantityExceedsOrder
        |"D"B -> DKReason.NoMatchingOrder
        |"E"B -> DKReason.PriceExceedsLimit
        |"F"B -> DKReason.CalculationDifference
        |"Z"B -> DKReason.Other
        | x -> failwith (sprintf "ReadDKReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDKReason (dest:byte array) (nextFreeIdx:int) (xxIn:DKReason) : int =
    match xxIn with
    | DKReason.UnknownSymbol ->
        let tag = "127=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.WrongSide ->
        let tag = "127=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.QuantityExceedsOrder ->
        let tag = "127=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.NoMatchingOrder ->
        let tag = "127=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.PriceExceedsLimit ->
        let tag = "127=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.CalculationDifference ->
        let tag = "127=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.Other ->
        let tag = "127=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDeliverToCompID (pos:int) (bs:byte[]) : (int*DeliverToCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DeliverToCompID.DeliverToCompID


let WriteDeliverToCompID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToCompID) : int = 
   let tag = "128="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeliverToSubID (pos:int) (bs:byte[]) : (int*DeliverToSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DeliverToSubID.DeliverToSubID


let WriteDeliverToSubID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToSubID) : int = 
   let tag = "129="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIOINaturalFlag (pos:int) (bs:byte[]) : (int*IOINaturalFlag) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) IOINaturalFlag.IOINaturalFlag


let WriteIOINaturalFlag (dest:byte []) (nextFreeIdx:int) (valIn:IOINaturalFlag) : int = 
   let tag = "130="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteReqID (pos:int) (bs:byte[]) : (int*QuoteReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteReqID.QuoteReqID


let WriteQuoteReqID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteReqID) : int = 
   let tag = "131="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidPx (pos:int) (bs:byte[]) : (int*BidPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidPx.BidPx


let WriteBidPx (dest:byte []) (nextFreeIdx:int) (valIn:BidPx) : int = 
   let tag = "132="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferPx (pos:int) (bs:byte[]) : (int*OfferPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferPx.OfferPx


let WriteOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:OfferPx) : int = 
   let tag = "133="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidSize (pos:int) (bs:byte[]) : (int*BidSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidSize.BidSize


let WriteBidSize (dest:byte []) (nextFreeIdx:int) (valIn:BidSize) : int = 
   let tag = "134="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferSize (pos:int) (bs:byte[]) : (int*OfferSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferSize.OfferSize


let WriteOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:OfferSize) : int = 
   let tag = "135="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoMiscFees (pos:int) (bs:byte[]) : (int*NoMiscFees) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoMiscFees.NoMiscFees


let WriteNoMiscFees (dest:byte []) (nextFreeIdx:int) (valIn:NoMiscFees) : int = 
   let tag = "136="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMiscFeeAmt (pos:int) (bs:byte[]) : (int*MiscFeeAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MiscFeeAmt.MiscFeeAmt


let WriteMiscFeeAmt (dest:byte []) (nextFreeIdx:int) (valIn:MiscFeeAmt) : int = 
   let tag = "137="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMiscFeeCurr (pos:int) (bs:byte[]) : (int*MiscFeeCurr) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MiscFeeCurr.MiscFeeCurr


let WriteMiscFeeCurr (dest:byte []) (nextFreeIdx:int) (valIn:MiscFeeCurr) : int = 
   let tag = "138="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMiscFeeType (pos:int) (bs:byte[]) : (int * MiscFeeType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> MiscFeeType.Regulatory
        |"2"B -> MiscFeeType.Tax
        |"3"B -> MiscFeeType.LocalCommission
        |"4"B -> MiscFeeType.ExchangeFees
        |"5"B -> MiscFeeType.Stamp
        |"6"B -> MiscFeeType.Levy
        |"7"B -> MiscFeeType.Other
        |"8"B -> MiscFeeType.Markup
        |"9"B -> MiscFeeType.ConsumptionTax
        |"10"B -> MiscFeeType.PerTransaction
        |"11"B -> MiscFeeType.Conversion
        |"12"B -> MiscFeeType.Agent
        | x -> failwith (sprintf "ReadMiscFeeType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMiscFeeType (dest:byte array) (nextFreeIdx:int) (xxIn:MiscFeeType) : int =
    match xxIn with
    | MiscFeeType.Regulatory ->
        let tag = "139=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Tax ->
        let tag = "139=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.LocalCommission ->
        let tag = "139=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.ExchangeFees ->
        let tag = "139=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Stamp ->
        let tag = "139=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Levy ->
        let tag = "139=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Other ->
        let tag = "139=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Markup ->
        let tag = "139=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.ConsumptionTax ->
        let tag = "139=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.PerTransaction ->
        let tag = "139=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Conversion ->
        let tag = "139=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Agent ->
        let tag = "139=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPrevClosePx (pos:int) (bs:byte[]) : (int*PrevClosePx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PrevClosePx.PrevClosePx


let WritePrevClosePx (dest:byte []) (nextFreeIdx:int) (valIn:PrevClosePx) : int = 
   let tag = "140="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadResetSeqNumFlag (pos:int) (bs:byte[]) : (int*ResetSeqNumFlag) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ResetSeqNumFlag.ResetSeqNumFlag


let WriteResetSeqNumFlag (dest:byte []) (nextFreeIdx:int) (valIn:ResetSeqNumFlag) : int = 
   let tag = "141="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSenderLocationID (pos:int) (bs:byte[]) : (int*SenderLocationID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SenderLocationID.SenderLocationID


let WriteSenderLocationID (dest:byte []) (nextFreeIdx:int) (valIn:SenderLocationID) : int = 
   let tag = "142="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTargetLocationID (pos:int) (bs:byte[]) : (int*TargetLocationID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TargetLocationID.TargetLocationID


let WriteTargetLocationID (dest:byte []) (nextFreeIdx:int) (valIn:TargetLocationID) : int = 
   let tag = "143="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOnBehalfOfLocationID (pos:int) (bs:byte[]) : (int*OnBehalfOfLocationID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OnBehalfOfLocationID.OnBehalfOfLocationID


let WriteOnBehalfOfLocationID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfLocationID) : int = 
   let tag = "144="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeliverToLocationID (pos:int) (bs:byte[]) : (int*DeliverToLocationID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DeliverToLocationID.DeliverToLocationID


let WriteDeliverToLocationID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToLocationID) : int = 
   let tag = "145="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoRelatedSym (pos:int) (bs:byte[]) : (int*NoRelatedSym) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoRelatedSym.NoRelatedSym


let WriteNoRelatedSym (dest:byte []) (nextFreeIdx:int) (valIn:NoRelatedSym) : int = 
   let tag = "146="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSubject (pos:int) (bs:byte[]) : (int*Subject) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Subject.Subject


let WriteSubject (dest:byte []) (nextFreeIdx:int) (valIn:Subject) : int = 
   let tag = "147="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHeadline (pos:int) (bs:byte[]) : (int*Headline) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Headline.Headline


let WriteHeadline (dest:byte []) (nextFreeIdx:int) (valIn:Headline) : int = 
   let tag = "148="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadURLLink (pos:int) (bs:byte[]) : (int*URLLink) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) URLLink.URLLink


let WriteURLLink (dest:byte []) (nextFreeIdx:int) (valIn:URLLink) : int = 
   let tag = "149="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExecType (pos:int) (bs:byte[]) : (int * ExecType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ExecType.New
        |"1"B -> ExecType.PartialFill
        |"2"B -> ExecType.Fill
        |"3"B -> ExecType.DoneForDay
        |"4"B -> ExecType.Canceled
        |"5"B -> ExecType.Replace
        |"6"B -> ExecType.PendingCancel
        |"7"B -> ExecType.Stopped
        |"8"B -> ExecType.Rejected
        |"9"B -> ExecType.Suspended
        |"A"B -> ExecType.PendingNew
        |"B"B -> ExecType.Calculated
        |"C"B -> ExecType.Expired
        |"D"B -> ExecType.Restated
        |"E"B -> ExecType.PendingReplace
        |"F"B -> ExecType.Trade
        |"G"B -> ExecType.TradeCorrect
        |"H"B -> ExecType.TradeCancel
        |"I"B -> ExecType.OrderStatus
        | x -> failwith (sprintf "ReadExecType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExecType (dest:byte array) (nextFreeIdx:int) (xxIn:ExecType) : int =
    match xxIn with
    | ExecType.New ->
        let tag = "150=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PartialFill ->
        let tag = "150=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Fill ->
        let tag = "150=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.DoneForDay ->
        let tag = "150=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Canceled ->
        let tag = "150=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Replace ->
        let tag = "150=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingCancel ->
        let tag = "150=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Stopped ->
        let tag = "150=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Rejected ->
        let tag = "150=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Suspended ->
        let tag = "150=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingNew ->
        let tag = "150=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Calculated ->
        let tag = "150=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Expired ->
        let tag = "150=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Restated ->
        let tag = "150=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingReplace ->
        let tag = "150=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Trade ->
        let tag = "150=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.TradeCorrect ->
        let tag = "150=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.TradeCancel ->
        let tag = "150=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.OrderStatus ->
        let tag = "150=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLeavesQty (pos:int) (bs:byte[]) : (int*LeavesQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LeavesQty.LeavesQty


let WriteLeavesQty (dest:byte []) (nextFreeIdx:int) (valIn:LeavesQty) : int = 
   let tag = "151="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashOrderQty (pos:int) (bs:byte[]) : (int*CashOrderQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) CashOrderQty.CashOrderQty


let WriteCashOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:CashOrderQty) : int = 
   let tag = "152="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocAvgPx (pos:int) (bs:byte[]) : (int*AllocAvgPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AllocAvgPx.AllocAvgPx


let WriteAllocAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:AllocAvgPx) : int = 
   let tag = "153="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocNetMoney (pos:int) (bs:byte[]) : (int*AllocNetMoney) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllocNetMoney.AllocNetMoney


let WriteAllocNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:AllocNetMoney) : int = 
   let tag = "154="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrFxRate (pos:int) (bs:byte[]) : (int*SettlCurrFxRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) SettlCurrFxRate.SettlCurrFxRate


let WriteSettlCurrFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrFxRate) : int = 
   let tag = "155="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrFxRateCalc (pos:int) (bs:byte[]) : (int * SettlCurrFxRateCalc) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"M"B -> SettlCurrFxRateCalc.Multiply
        |"D"B -> SettlCurrFxRateCalc.Divide
        | x -> failwith (sprintf "ReadSettlCurrFxRateCalc unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlCurrFxRateCalc (dest:byte array) (nextFreeIdx:int) (xxIn:SettlCurrFxRateCalc) : int =
    match xxIn with
    | SettlCurrFxRateCalc.Multiply ->
        let tag = "156=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlCurrFxRateCalc.Divide ->
        let tag = "156=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumDaysInterest (pos:int) (bs:byte[]) : (int*NumDaysInterest) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NumDaysInterest.NumDaysInterest


let WriteNumDaysInterest (dest:byte []) (nextFreeIdx:int) (valIn:NumDaysInterest) : int = 
   let tag = "157="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAccruedInterestRate (pos:int) (bs:byte[]) : (int*AccruedInterestRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AccruedInterestRate.AccruedInterestRate


let WriteAccruedInterestRate (dest:byte []) (nextFreeIdx:int) (valIn:AccruedInterestRate) : int = 
   let tag = "158="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAccruedInterestAmt (pos:int) (bs:byte[]) : (int*AccruedInterestAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AccruedInterestAmt.AccruedInterestAmt


let WriteAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:AccruedInterestAmt) : int = 
   let tag = "159="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstMode (pos:int) (bs:byte[]) : (int * SettlInstMode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SettlInstMode.Default
        |"1"B -> SettlInstMode.StandingInstructionsProvided
        |"4"B -> SettlInstMode.SpecificOrderForASingleAccount
        |"5"B -> SettlInstMode.RequestReject
        | x -> failwith (sprintf "ReadSettlInstMode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlInstMode (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstMode) : int =
    match xxIn with
    | SettlInstMode.Default ->
        let tag = "160=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.StandingInstructionsProvided ->
        let tag = "160=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.SpecificOrderForASingleAccount ->
        let tag = "160=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.RequestReject ->
        let tag = "160=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocText (pos:int) (bs:byte[]) : (int*AllocText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocText.AllocText


let WriteAllocText (dest:byte []) (nextFreeIdx:int) (valIn:AllocText) : int = 
   let tag = "161="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstID (pos:int) (bs:byte[]) : (int*SettlInstID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlInstID.SettlInstID


let WriteSettlInstID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstID) : int = 
   let tag = "162="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstTransType (pos:int) (bs:byte[]) : (int * SettlInstTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"N"B -> SettlInstTransType.New
        |"C"B -> SettlInstTransType.Cancel
        |"R"B -> SettlInstTransType.Replace
        |"T"B -> SettlInstTransType.Restate
        | x -> failwith (sprintf "ReadSettlInstTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlInstTransType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstTransType) : int =
    match xxIn with
    | SettlInstTransType.New ->
        let tag = "163=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Cancel ->
        let tag = "163=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Replace ->
        let tag = "163=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Restate ->
        let tag = "163=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEmailThreadID (pos:int) (bs:byte[]) : (int*EmailThreadID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) EmailThreadID.EmailThreadID


let WriteEmailThreadID (dest:byte []) (nextFreeIdx:int) (valIn:EmailThreadID) : int = 
   let tag = "164="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstSource (pos:int) (bs:byte[]) : (int * SettlInstSource) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SettlInstSource.BrokersInstructions
        |"2"B -> SettlInstSource.InstitutionsInstructions
        |"3"B -> SettlInstSource.Investor
        | x -> failwith (sprintf "ReadSettlInstSource unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlInstSource (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstSource) : int =
    match xxIn with
    | SettlInstSource.BrokersInstructions ->
        let tag = "165=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstSource.InstitutionsInstructions ->
        let tag = "165=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstSource.Investor ->
        let tag = "165=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityType (pos:int) (bs:byte[]) : (int * SecurityType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"EUSUPRA"B -> SecurityType.EuroSupranationalCoupons
        |"FAC"B -> SecurityType.FederalAgencyCoupon
        |"FADN"B -> SecurityType.FederalAgencyDiscountNote
        |"PEF"B -> SecurityType.PrivateExportFunding
        |"SUPRA"B -> SecurityType.UsdSupranationalCoupons
        |"FUT"B -> SecurityType.Future
        |"OPT"B -> SecurityType.Option
        |"CORP"B -> SecurityType.CorporateBond
        |"CPP"B -> SecurityType.CorporatePrivatePlacement
        |"CB"B -> SecurityType.ConvertibleBond
        |"DUAL"B -> SecurityType.DualCurrency
        |"EUCORP"B -> SecurityType.EuroCorporateBond
        |"XLINKD"B -> SecurityType.IndexedLinked
        |"STRUCT"B -> SecurityType.StructuredNotes
        |"YANK"B -> SecurityType.YankeeCorporateBond
        |"FOR"B -> SecurityType.ForeignExchangeContract
        |"CS"B -> SecurityType.CommonStock
        |"PS"B -> SecurityType.PreferredStock
        |"BRADY"B -> SecurityType.BradyBond
        |"EUSOV"B -> SecurityType.EuroSovereigns
        |"TBOND"B -> SecurityType.UsTreasuryBond
        |"TINT"B -> SecurityType.InterestStripFromAnyBondOrNote
        |"TIPS"B -> SecurityType.TreasuryInflationProtectedSecurities
        |"TCAL"B -> SecurityType.PrincipalStripOfACallableBondOrNote
        |"TPRN"B -> SecurityType.PrincipalStripFromANonCallableBondOrNote
        |"TNOTE"B -> SecurityType.UsTreasuryNote
        |"TBILL"B -> SecurityType.UsTreasuryBill
        |"REPO"B -> SecurityType.Repurchase
        |"FORWARD"B -> SecurityType.Forward
        |"BUYSELL"B -> SecurityType.BuySellback
        |"SECLOAN"B -> SecurityType.SecuritiesLoan
        |"SECPLEDGE"B -> SecurityType.SecuritiesPledge
        |"TERM"B -> SecurityType.TermLoan
        |"RVLV"B -> SecurityType.RevolverLoan
        |"RVLVTRM"B -> SecurityType.RevolverTermLoan
        |"BRIDGE"B -> SecurityType.BridgeLoan
        |"LOFC"B -> SecurityType.LetterOfCredit
        |"SWING"B -> SecurityType.SwingLineFacility
        |"DINP"B -> SecurityType.DebtorInPossession
        |"DEFLTED"B -> SecurityType.Defaulted
        |"WITHDRN"B -> SecurityType.Withdrawn
        |"REPLACD"B -> SecurityType.Replaced
        |"MATURED"B -> SecurityType.Matured
        |"AMENDED"B -> SecurityType.AmendedAndRestated
        |"RETIRED"B -> SecurityType.Retired
        |"BA"B -> SecurityType.BankersAcceptance
        |"BN"B -> SecurityType.BankNotes
        |"BOX"B -> SecurityType.BillOfExchanges
        |"CD"B -> SecurityType.CertificateOfDeposit
        |"CL"B -> SecurityType.CallLoans
        |"CP"B -> SecurityType.CommercialPaper
        |"DN"B -> SecurityType.DepositNotes
        |"EUCD"B -> SecurityType.EuroCertificateOfDeposit
        |"EUCP"B -> SecurityType.EuroCommercialPaper
        |"LQN"B -> SecurityType.LiquidityNote
        |"MTN"B -> SecurityType.MediumTermNotes
        |"ONITE"B -> SecurityType.Overnight
        |"PN"B -> SecurityType.PromissoryNote
        |"PZFJ"B -> SecurityType.PlazosFijos
        |"STN"B -> SecurityType.ShortTermLoanNote
        |"TD"B -> SecurityType.TimeDeposit
        |"XCN"B -> SecurityType.ExtendedCommNote
        |"YCD"B -> SecurityType.YankeeCertificateOfDeposit
        |"ABS"B -> SecurityType.AssetBackedSecurities
        |"CMBS"B -> SecurityType.CorpMortgageBackedSecurities
        |"CMO"B -> SecurityType.CollateralizedMortgageObligation
        |"IET"B -> SecurityType.IoetteMortgage
        |"MBS"B -> SecurityType.MortgageBackedSecurities
        |"MIO"B -> SecurityType.MortgageInterestOnly
        |"MPO"B -> SecurityType.MortgagePrincipalOnly
        |"MPP"B -> SecurityType.MortgagePrivatePlacement
        |"MPT"B -> SecurityType.MiscellaneousPassThrough
        |"PFAND"B -> SecurityType.Pfandbriefe
        |"TBA"B -> SecurityType.ToBeAnnounced
        |"AN"B -> SecurityType.OtherAnticipationNotes
        |"COFO"B -> SecurityType.CertificateOfObligation
        |"COFP"B -> SecurityType.CertificateOfParticipation
        |"GO"B -> SecurityType.GeneralObligationBonds
        |"MT"B -> SecurityType.MandatoryTender
        |"RAN"B -> SecurityType.RevenueAnticipationNote
        |"REV"B -> SecurityType.RevenueBonds
        |"SPCLA"B -> SecurityType.SpecialAssessment
        |"SPCLO"B -> SecurityType.SpecialObligation
        |"SPCLT"B -> SecurityType.SpecialTax
        |"TAN"B -> SecurityType.TaxAnticipationNote
        |"TAXA"B -> SecurityType.TaxAllocation
        |"TECP"B -> SecurityType.TaxExemptCommercialPaper
        |"TRAN"B -> SecurityType.TaxAndRevenueAnticipationNote
        |"VRDN"B -> SecurityType.VariableRateDemandNote
        |"WAR"B -> SecurityType.Warrant
        |"MF"B -> SecurityType.MutualFund
        |"MLEG"B -> SecurityType.MultiLegInstrument
        |"NONE"B -> SecurityType.NoSecurityType
        |"?"B -> SecurityType.Wildcard
        | x -> failwith (sprintf "ReadSecurityType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityType) : int =
    match xxIn with
    | SecurityType.EuroSupranationalCoupons ->
        let tag = "167=EUSUPRA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.FederalAgencyCoupon ->
        let tag = "167=FAC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.FederalAgencyDiscountNote ->
        let tag = "167=FADN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrivateExportFunding ->
        let tag = "167=PEF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsdSupranationalCoupons ->
        let tag = "167=SUPRA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Future ->
        let tag = "167=FUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Option ->
        let tag = "167=OPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorporateBond ->
        let tag = "167=CORP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorporatePrivatePlacement ->
        let tag = "167=CPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ConvertibleBond ->
        let tag = "167=CB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DualCurrency ->
        let tag = "167=DUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCorporateBond ->
        let tag = "167=EUCORP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.IndexedLinked ->
        let tag = "167=XLINKD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.StructuredNotes ->
        let tag = "167=STRUCT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.YankeeCorporateBond ->
        let tag = "167=YANK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ForeignExchangeContract ->
        let tag = "167=FOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CommonStock ->
        let tag = "167=CS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PreferredStock ->
        let tag = "167=PS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BradyBond ->
        let tag = "167=BRADY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroSovereigns ->
        let tag = "167=EUSOV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryBond ->
        let tag = "167=TBOND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.InterestStripFromAnyBondOrNote ->
        let tag = "167=TINT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TreasuryInflationProtectedSecurities ->
        let tag = "167=TIPS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrincipalStripOfACallableBondOrNote ->
        let tag = "167=TCAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrincipalStripFromANonCallableBondOrNote ->
        let tag = "167=TPRN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryNote ->
        let tag = "167=TNOTE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryBill ->
        let tag = "167=TBILL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Repurchase ->
        let tag = "167=REPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Forward ->
        let tag = "167=FORWARD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BuySellback ->
        let tag = "167=BUYSELL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SecuritiesLoan ->
        let tag = "167=SECLOAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SecuritiesPledge ->
        let tag = "167=SECPLEDGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TermLoan ->
        let tag = "167=TERM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevolverLoan ->
        let tag = "167=RVLV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevolverTermLoan ->
        let tag = "167=RVLVTRM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BridgeLoan ->
        let tag = "167=BRIDGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.LetterOfCredit ->
        let tag = "167=LOFC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SwingLineFacility ->
        let tag = "167=SWING"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DebtorInPossession ->
        let tag = "167=DINP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Defaulted ->
        let tag = "167=DEFLTED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Withdrawn ->
        let tag = "167=WITHDRN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Replaced ->
        let tag = "167=REPLACD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Matured ->
        let tag = "167=MATURED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.AmendedAndRestated ->
        let tag = "167=AMENDED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Retired ->
        let tag = "167=RETIRED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BankersAcceptance ->
        let tag = "167=BA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BankNotes ->
        let tag = "167=BN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BillOfExchanges ->
        let tag = "167=BOX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfDeposit ->
        let tag = "167=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CallLoans ->
        let tag = "167=CL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CommercialPaper ->
        let tag = "167=CP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DepositNotes ->
        let tag = "167=DN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCertificateOfDeposit ->
        let tag = "167=EUCD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCommercialPaper ->
        let tag = "167=EUCP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.LiquidityNote ->
        let tag = "167=LQN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MediumTermNotes ->
        let tag = "167=MTN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Overnight ->
        let tag = "167=ONITE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PromissoryNote ->
        let tag = "167=PN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PlazosFijos ->
        let tag = "167=PZFJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ShortTermLoanNote ->
        let tag = "167=STN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TimeDeposit ->
        let tag = "167=TD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ExtendedCommNote ->
        let tag = "167=XCN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.YankeeCertificateOfDeposit ->
        let tag = "167=YCD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.AssetBackedSecurities ->
        let tag = "167=ABS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorpMortgageBackedSecurities ->
        let tag = "167=CMBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CollateralizedMortgageObligation ->
        let tag = "167=CMO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.IoetteMortgage ->
        let tag = "167=IET"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgageBackedSecurities ->
        let tag = "167=MBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgageInterestOnly ->
        let tag = "167=MIO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgagePrincipalOnly ->
        let tag = "167=MPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgagePrivatePlacement ->
        let tag = "167=MPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MiscellaneousPassThrough ->
        let tag = "167=MPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Pfandbriefe ->
        let tag = "167=PFAND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ToBeAnnounced ->
        let tag = "167=TBA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.OtherAnticipationNotes ->
        let tag = "167=AN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfObligation ->
        let tag = "167=COFO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfParticipation ->
        let tag = "167=COFP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.GeneralObligationBonds ->
        let tag = "167=GO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MandatoryTender ->
        let tag = "167=MT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevenueAnticipationNote ->
        let tag = "167=RAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevenueBonds ->
        let tag = "167=REV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialAssessment ->
        let tag = "167=SPCLA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialObligation ->
        let tag = "167=SPCLO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialTax ->
        let tag = "167=SPCLT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAnticipationNote ->
        let tag = "167=TAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAllocation ->
        let tag = "167=TAXA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxExemptCommercialPaper ->
        let tag = "167=TECP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAndRevenueAnticipationNote ->
        let tag = "167=TRAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.VariableRateDemandNote ->
        let tag = "167=VRDN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Warrant ->
        let tag = "167=WAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MutualFund ->
        let tag = "167=MF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MultiLegInstrument ->
        let tag = "167=MLEG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.NoSecurityType ->
        let tag = "167=NONE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Wildcard ->
        let tag = "167=?"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEffectiveTime (pos:int) (bs:byte[]) : (int*EffectiveTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) EffectiveTime.EffectiveTime


let WriteEffectiveTime (dest:byte []) (nextFreeIdx:int) (valIn:EffectiveTime) : int = 
   let tag = "168="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStandInstDbType (pos:int) (bs:byte[]) : (int * StandInstDbType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> StandInstDbType.Other
        |"1"B -> StandInstDbType.DtcSid
        |"2"B -> StandInstDbType.ThomsonAlert
        |"3"B -> StandInstDbType.AGlobalCustodian
        |"4"B -> StandInstDbType.Accountnet
        | x -> failwith (sprintf "ReadStandInstDbType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteStandInstDbType (dest:byte array) (nextFreeIdx:int) (xxIn:StandInstDbType) : int =
    match xxIn with
    | StandInstDbType.Other ->
        let tag = "169=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.DtcSid ->
        let tag = "169=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.ThomsonAlert ->
        let tag = "169=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.AGlobalCustodian ->
        let tag = "169=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.Accountnet ->
        let tag = "169=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStandInstDbName (pos:int) (bs:byte[]) : (int*StandInstDbName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StandInstDbName.StandInstDbName


let WriteStandInstDbName (dest:byte []) (nextFreeIdx:int) (valIn:StandInstDbName) : int = 
   let tag = "170="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStandInstDbID (pos:int) (bs:byte[]) : (int*StandInstDbID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StandInstDbID.StandInstDbID


let WriteStandInstDbID (dest:byte []) (nextFreeIdx:int) (valIn:StandInstDbID) : int = 
   let tag = "171="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlDeliveryType (pos:int) (bs:byte[]) : (int * SettlDeliveryType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SettlDeliveryType.VersusPayment
        |"1"B -> SettlDeliveryType.Free
        |"2"B -> SettlDeliveryType.TriParty
        |"3"B -> SettlDeliveryType.HoldInCustody
        | x -> failwith (sprintf "ReadSettlDeliveryType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlDeliveryType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlDeliveryType) : int =
    match xxIn with
    | SettlDeliveryType.VersusPayment ->
        let tag = "172=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.Free ->
        let tag = "172=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.TriParty ->
        let tag = "172=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.HoldInCustody ->
        let tag = "172=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidSpotRate (pos:int) (bs:byte[]) : (int*BidSpotRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidSpotRate.BidSpotRate


let WriteBidSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:BidSpotRate) : int = 
   let tag = "188="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidForwardPoints (pos:int) (bs:byte[]) : (int*BidForwardPoints) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidForwardPoints.BidForwardPoints


let WriteBidForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:BidForwardPoints) : int = 
   let tag = "189="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferSpotRate (pos:int) (bs:byte[]) : (int*OfferSpotRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferSpotRate.OfferSpotRate


let WriteOfferSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:OfferSpotRate) : int = 
   let tag = "190="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferForwardPoints (pos:int) (bs:byte[]) : (int*OfferForwardPoints) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferForwardPoints.OfferForwardPoints


let WriteOfferForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:OfferForwardPoints) : int = 
   let tag = "191="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderQty2 (pos:int) (bs:byte[]) : (int*OrderQty2) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderQty2.OrderQty2


let WriteOrderQty2 (dest:byte []) (nextFreeIdx:int) (valIn:OrderQty2) : int = 
   let tag = "192="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlDate2 (pos:int) (bs:byte[]) : (int*SettlDate2) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlDate2.SettlDate2


let WriteSettlDate2 (dest:byte []) (nextFreeIdx:int) (valIn:SettlDate2) : int = 
   let tag = "193="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastSpotRate (pos:int) (bs:byte[]) : (int*LastSpotRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastSpotRate.LastSpotRate


let WriteLastSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:LastSpotRate) : int = 
   let tag = "194="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastForwardPoints (pos:int) (bs:byte[]) : (int*LastForwardPoints) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastForwardPoints.LastForwardPoints


let WriteLastForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:LastForwardPoints) : int = 
   let tag = "195="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocLinkID (pos:int) (bs:byte[]) : (int*AllocLinkID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocLinkID.AllocLinkID


let WriteAllocLinkID (dest:byte []) (nextFreeIdx:int) (valIn:AllocLinkID) : int = 
   let tag = "196="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocLinkType (pos:int) (bs:byte[]) : (int * AllocLinkType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocLinkType.FXNetting
        |"1"B -> AllocLinkType.FXSwap
        | x -> failwith (sprintf "ReadAllocLinkType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocLinkType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocLinkType) : int =
    match xxIn with
    | AllocLinkType.FXNetting ->
        let tag = "197=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocLinkType.FXSwap ->
        let tag = "197=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryOrderID (pos:int) (bs:byte[]) : (int*SecondaryOrderID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryOrderID.SecondaryOrderID


let WriteSecondaryOrderID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryOrderID) : int = 
   let tag = "198="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoIOIQualifiers (pos:int) (bs:byte[]) : (int*NoIOIQualifiers) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoIOIQualifiers.NoIOIQualifiers


let WriteNoIOIQualifiers (dest:byte []) (nextFreeIdx:int) (valIn:NoIOIQualifiers) : int = 
   let tag = "199="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMaturityMonthYear (pos:int) (bs:byte[]) : (int*MaturityMonthYear) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MaturityMonthYear.MaturityMonthYear


let WriteMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:MaturityMonthYear) : int = 
   let tag = "200="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPutOrCall (pos:int) (bs:byte[]) : (int * PutOrCall) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PutOrCall.Put
        |"1"B -> PutOrCall.Call
        | x -> failwith (sprintf "ReadPutOrCall unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePutOrCall (dest:byte array) (nextFreeIdx:int) (xxIn:PutOrCall) : int =
    match xxIn with
    | PutOrCall.Put ->
        let tag = "201=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PutOrCall.Call ->
        let tag = "201=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikePrice (pos:int) (bs:byte[]) : (int*StrikePrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) StrikePrice.StrikePrice


let WriteStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:StrikePrice) : int = 
   let tag = "202="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCoveredOrUncovered (pos:int) (bs:byte[]) : (int * CoveredOrUncovered) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CoveredOrUncovered.Covered
        |"1"B -> CoveredOrUncovered.Uncovered
        | x -> failwith (sprintf "ReadCoveredOrUncovered unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCoveredOrUncovered (dest:byte array) (nextFreeIdx:int) (xxIn:CoveredOrUncovered) : int =
    match xxIn with
    | CoveredOrUncovered.Covered ->
        let tag = "203=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CoveredOrUncovered.Uncovered ->
        let tag = "203=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOptAttribute (pos:int) (bs:byte[]) : (int*OptAttribute) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) OptAttribute.OptAttribute


let WriteOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:OptAttribute) : int = 
   let tag = "206="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityExchange (pos:int) (bs:byte[]) : (int*SecurityExchange) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityExchange.SecurityExchange


let WriteSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:SecurityExchange) : int = 
   let tag = "207="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNotifyBrokerOfCredit (pos:int) (bs:byte[]) : (int*NotifyBrokerOfCredit) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) NotifyBrokerOfCredit.NotifyBrokerOfCredit


let WriteNotifyBrokerOfCredit (dest:byte []) (nextFreeIdx:int) (valIn:NotifyBrokerOfCredit) : int = 
   let tag = "208="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocHandlInst (pos:int) (bs:byte[]) : (int * AllocHandlInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AllocHandlInst.Match
        |"2"B -> AllocHandlInst.Forward
        |"3"B -> AllocHandlInst.ForwardAndMatch
        | x -> failwith (sprintf "ReadAllocHandlInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocHandlInst (dest:byte array) (nextFreeIdx:int) (xxIn:AllocHandlInst) : int =
    match xxIn with
    | AllocHandlInst.Match ->
        let tag = "209=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocHandlInst.Forward ->
        let tag = "209=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocHandlInst.ForwardAndMatch ->
        let tag = "209=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMaxShow (pos:int) (bs:byte[]) : (int*MaxShow) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MaxShow.MaxShow


let WriteMaxShow (dest:byte []) (nextFreeIdx:int) (valIn:MaxShow) : int = 
   let tag = "210="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPegOffsetValue (pos:int) (bs:byte[]) : (int*PegOffsetValue) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PegOffsetValue.PegOffsetValue


let WritePegOffsetValue (dest:byte []) (nextFreeIdx:int) (valIn:PegOffsetValue) : int = 
   let tag = "211="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteXmlData (dest:byte []) (nextFreeIdx:int) (fld:XmlData) : int =
    // write the string length part of the compound msg
    let lenTag = "212="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadXmlData (pos:int) (bs:byte[]) : (int * XmlData) =
    ReadLengthStringCompoundField "213"B (pos:int) (bs:byte[]) XmlData.XmlData


let ReadSettlInstRefID (pos:int) (bs:byte[]) : (int*SettlInstRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlInstRefID.SettlInstRefID


let WriteSettlInstRefID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstRefID) : int = 
   let tag = "214="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoRoutingIDs (pos:int) (bs:byte[]) : (int*NoRoutingIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoRoutingIDs.NoRoutingIDs


let WriteNoRoutingIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoRoutingIDs) : int = 
   let tag = "215="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRoutingType (pos:int) (bs:byte[]) : (int * RoutingType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> RoutingType.TargetFirm
        |"2"B -> RoutingType.TargetList
        |"3"B -> RoutingType.BlockFirm
        |"4"B -> RoutingType.BlockList
        | x -> failwith (sprintf "ReadRoutingType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteRoutingType (dest:byte array) (nextFreeIdx:int) (xxIn:RoutingType) : int =
    match xxIn with
    | RoutingType.TargetFirm ->
        let tag = "216=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.TargetList ->
        let tag = "216=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.BlockFirm ->
        let tag = "216=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.BlockList ->
        let tag = "216=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoutingID (pos:int) (bs:byte[]) : (int*RoutingID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RoutingID.RoutingID


let WriteRoutingID (dest:byte []) (nextFreeIdx:int) (valIn:RoutingID) : int = 
   let tag = "217="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSpread (pos:int) (bs:byte[]) : (int*Spread) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Spread.Spread


let WriteSpread (dest:byte []) (nextFreeIdx:int) (valIn:Spread) : int = 
   let tag = "218="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkCurveCurrency (pos:int) (bs:byte[]) : (int*BenchmarkCurveCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BenchmarkCurveCurrency.BenchmarkCurveCurrency


let WriteBenchmarkCurveCurrency (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkCurveCurrency) : int = 
   let tag = "220="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkCurveName (pos:int) (bs:byte[]) : (int * BenchmarkCurveName) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"MuniAAA"B -> BenchmarkCurveName.Muniaaa
        |"FutureSWAP"B -> BenchmarkCurveName.Futureswap
        |"LIBID"B -> BenchmarkCurveName.Libid
        |"LIBOR"B -> BenchmarkCurveName.Libor
        |"OTHER"B -> BenchmarkCurveName.Other
        |"SWAP"B -> BenchmarkCurveName.Swap
        |"Treasury"B -> BenchmarkCurveName.Treasury
        |"Euribor"B -> BenchmarkCurveName.Euribor
        |"Pfandbriefe"B -> BenchmarkCurveName.Pfandbriefe
        |"EONIA"B -> BenchmarkCurveName.Eonia
        |"SONIA"B -> BenchmarkCurveName.Sonia
        |"EUREPO"B -> BenchmarkCurveName.Eurepo
        | x -> failwith (sprintf "ReadBenchmarkCurveName unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBenchmarkCurveName (dest:byte array) (nextFreeIdx:int) (xxIn:BenchmarkCurveName) : int =
    match xxIn with
    | BenchmarkCurveName.Muniaaa ->
        let tag = "221=MuniAAA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Futureswap ->
        let tag = "221=FutureSWAP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Libid ->
        let tag = "221=LIBID"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Libor ->
        let tag = "221=LIBOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Other ->
        let tag = "221=OTHER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Swap ->
        let tag = "221=SWAP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Treasury ->
        let tag = "221=Treasury"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Euribor ->
        let tag = "221=Euribor"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Pfandbriefe ->
        let tag = "221=Pfandbriefe"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Eonia ->
        let tag = "221=EONIA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Sonia ->
        let tag = "221=SONIA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Eurepo ->
        let tag = "221=EUREPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBenchmarkCurvePoint (pos:int) (bs:byte[]) : (int*BenchmarkCurvePoint) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BenchmarkCurvePoint.BenchmarkCurvePoint


let WriteBenchmarkCurvePoint (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkCurvePoint) : int = 
   let tag = "222="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCouponRate (pos:int) (bs:byte[]) : (int*CouponRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) CouponRate.CouponRate


let WriteCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:CouponRate) : int = 
   let tag = "223="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCouponPaymentDate (pos:int) (bs:byte[]) : (int*CouponPaymentDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CouponPaymentDate.CouponPaymentDate


let WriteCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:CouponPaymentDate) : int = 
   let tag = "224="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIssueDate (pos:int) (bs:byte[]) : (int*IssueDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) IssueDate.IssueDate


let WriteIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:IssueDate) : int = 
   let tag = "225="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRepurchaseTerm (pos:int) (bs:byte[]) : (int*RepurchaseTerm) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RepurchaseTerm.RepurchaseTerm


let WriteRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:RepurchaseTerm) : int = 
   let tag = "226="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRepurchaseRate (pos:int) (bs:byte[]) : (int*RepurchaseRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) RepurchaseRate.RepurchaseRate


let WriteRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:RepurchaseRate) : int = 
   let tag = "227="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadFactor (pos:int) (bs:byte[]) : (int*Factor) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Factor.Factor


let WriteFactor (dest:byte []) (nextFreeIdx:int) (valIn:Factor) : int = 
   let tag = "228="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeOriginationDate (pos:int) (bs:byte[]) : (int*TradeOriginationDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeOriginationDate.TradeOriginationDate


let WriteTradeOriginationDate (dest:byte []) (nextFreeIdx:int) (valIn:TradeOriginationDate) : int = 
   let tag = "229="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExDate (pos:int) (bs:byte[]) : (int*ExDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExDate.ExDate


let WriteExDate (dest:byte []) (nextFreeIdx:int) (valIn:ExDate) : int = 
   let tag = "230="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContractMultiplier (pos:int) (bs:byte[]) : (int*ContractMultiplier) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ContractMultiplier.ContractMultiplier


let WriteContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:ContractMultiplier) : int = 
   let tag = "231="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoStipulations (pos:int) (bs:byte[]) : (int*NoStipulations) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoStipulations.NoStipulations


let WriteNoStipulations (dest:byte []) (nextFreeIdx:int) (valIn:NoStipulations) : int = 
   let tag = "232="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStipulationType (pos:int) (bs:byte[]) : (int * StipulationType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"AMT"B -> StipulationType.Amt
        |"AUTOREINV"B -> StipulationType.AutoReinvestmentAtOrBetter
        |"BANKQUAL"B -> StipulationType.BankQualified
        |"BGNCON"B -> StipulationType.BargainConditions
        |"COUPON"B -> StipulationType.CouponRange
        |"CURRENCY"B -> StipulationType.IsoCurrencyCode
        |"CUSTOMDATE"B -> StipulationType.CustomStartEndDate
        |"GEOG"B -> StipulationType.GeographicsAndPercentRange
        |"HAIRCUT"B -> StipulationType.ValuationDiscount
        |"INSURED"B -> StipulationType.Insured
        |"ISSUE"B -> StipulationType.YearOrYearMonthOfIssue
        |"ISSUER"B -> StipulationType.IssuersTicker
        |"ISSUESIZE"B -> StipulationType.IssueSizeRange
        |"LOOKBACK"B -> StipulationType.LookbackDays
        |"LOT"B -> StipulationType.ExplicitLotIdentifier
        |"LOTVAR"B -> StipulationType.LotVariance
        |"MAT"B -> StipulationType.MaturityYearAndMonth
        |"MATURITY"B -> StipulationType.MaturityRange
        |"MAXSUBS"B -> StipulationType.MaximumSubstitutions
        |"MINQTY"B -> StipulationType.MinimumQuantity
        |"MININCR"B -> StipulationType.MinimumIncrement
        |"MINDNOM"B -> StipulationType.MinimumDenomination
        |"PAYFREQ"B -> StipulationType.PaymentFrequencyCalendar
        |"PIECES"B -> StipulationType.NumberOfPieces
        |"PMAX"B -> StipulationType.PoolsMaximum
        |"PPM"B -> StipulationType.PoolsPerMillion
        |"PPL"B -> StipulationType.PoolsPerLot
        |"PPT"B -> StipulationType.PoolsPerTrade
        |"PRICE"B -> StipulationType.PriceRange
        |"PRICEFREQ"B -> StipulationType.PricingFrequency
        |"PROD"B -> StipulationType.ProductionYear
        |"PROTECT"B -> StipulationType.CallProtection
        |"PURPOSE"B -> StipulationType.Purpose
        |"PXSOURCE"B -> StipulationType.BenchmarkPriceSource
        |"RATING"B -> StipulationType.RatingSourceAndRange
        |"RESTRICTED"B -> StipulationType.Restricted
        |"SECTOR"B -> StipulationType.MarketSector
        |"SECTYPE"B -> StipulationType.SecuritytypeIncludedOrExcluded
        |"STRUCT"B -> StipulationType.Structure
        |"SUBSFREQ"B -> StipulationType.SubstitutionsFrequency
        |"SUBSLEFT"B -> StipulationType.SubstitutionsLeft
        |"TEXT"B -> StipulationType.FreeformText
        |"TRDVAR"B -> StipulationType.TradeVariance
        |"WAC"B -> StipulationType.WeightedAverageCoupon
        |"WAL"B -> StipulationType.WeightedAverageLifeCoupon
        |"WALA"B -> StipulationType.WeightedAverageLoanAge
        |"WAM"B -> StipulationType.WeightedAverageMaturity
        |"WHOLE"B -> StipulationType.WholePool
        |"YIELD"B -> StipulationType.YieldRange
        |"SMM"B -> StipulationType.SingleMonthlyMortality
        |"CPR"B -> StipulationType.ConstantPrepaymentRate
        |"CPY"B -> StipulationType.ConstantPrepaymentYield
        |"CPP"B -> StipulationType.ConstantPrepaymentPenalty
        |"ABS"B -> StipulationType.AbsolutePrepaymentSpeed
        |"MPR"B -> StipulationType.MonthlyPrepaymentRate
        |"PSA"B -> StipulationType.PercentOfBmaPrepaymentCurve
        |"PPC"B -> StipulationType.PercentOfProspectusPrepaymentCurve
        |"MHP"B -> StipulationType.PercentOfManufacturedHousingPrepaymentCurve
        |"HEP"B -> StipulationType.FinalCprOfHomeEquityPrepaymentCurve
        | x -> failwith (sprintf "ReadStipulationType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteStipulationType (dest:byte array) (nextFreeIdx:int) (xxIn:StipulationType) : int =
    match xxIn with
    | StipulationType.Amt ->
        let tag = "233=AMT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.AutoReinvestmentAtOrBetter ->
        let tag = "233=AUTOREINV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BankQualified ->
        let tag = "233=BANKQUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BargainConditions ->
        let tag = "233=BGNCON"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CouponRange ->
        let tag = "233=COUPON"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IsoCurrencyCode ->
        let tag = "233=CURRENCY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CustomStartEndDate ->
        let tag = "233=CUSTOMDATE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.GeographicsAndPercentRange ->
        let tag = "233=GEOG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ValuationDiscount ->
        let tag = "233=HAIRCUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Insured ->
        let tag = "233=INSURED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.YearOrYearMonthOfIssue ->
        let tag = "233=ISSUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IssuersTicker ->
        let tag = "233=ISSUER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IssueSizeRange ->
        let tag = "233=ISSUESIZE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.LookbackDays ->
        let tag = "233=LOOKBACK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ExplicitLotIdentifier ->
        let tag = "233=LOT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.LotVariance ->
        let tag = "233=LOTVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaturityYearAndMonth ->
        let tag = "233=MAT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaturityRange ->
        let tag = "233=MATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaximumSubstitutions ->
        let tag = "233=MAXSUBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumQuantity ->
        let tag = "233=MINQTY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumIncrement ->
        let tag = "233=MININCR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumDenomination ->
        let tag = "233=MINDNOM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PaymentFrequencyCalendar ->
        let tag = "233=PAYFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.NumberOfPieces ->
        let tag = "233=PIECES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsMaximum ->
        let tag = "233=PMAX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerMillion ->
        let tag = "233=PPM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerLot ->
        let tag = "233=PPL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerTrade ->
        let tag = "233=PPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PriceRange ->
        let tag = "233=PRICE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PricingFrequency ->
        let tag = "233=PRICEFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ProductionYear ->
        let tag = "233=PROD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CallProtection ->
        let tag = "233=PROTECT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Purpose ->
        let tag = "233=PURPOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BenchmarkPriceSource ->
        let tag = "233=PXSOURCE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.RatingSourceAndRange ->
        let tag = "233=RATING"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Restricted ->
        let tag = "233=RESTRICTED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MarketSector ->
        let tag = "233=SECTOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SecuritytypeIncludedOrExcluded ->
        let tag = "233=SECTYPE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Structure ->
        let tag = "233=STRUCT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SubstitutionsFrequency ->
        let tag = "233=SUBSFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SubstitutionsLeft ->
        let tag = "233=SUBSLEFT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.FreeformText ->
        let tag = "233=TEXT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.TradeVariance ->
        let tag = "233=TRDVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageCoupon ->
        let tag = "233=WAC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageLifeCoupon ->
        let tag = "233=WAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageLoanAge ->
        let tag = "233=WALA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageMaturity ->
        let tag = "233=WAM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WholePool ->
        let tag = "233=WHOLE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.YieldRange ->
        let tag = "233=YIELD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SingleMonthlyMortality ->
        let tag = "233=SMM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentRate ->
        let tag = "233=CPR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentYield ->
        let tag = "233=CPY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentPenalty ->
        let tag = "233=CPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.AbsolutePrepaymentSpeed ->
        let tag = "233=ABS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MonthlyPrepaymentRate ->
        let tag = "233=MPR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfBmaPrepaymentCurve ->
        let tag = "233=PSA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfProspectusPrepaymentCurve ->
        let tag = "233=PPC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfManufacturedHousingPrepaymentCurve ->
        let tag = "233=MHP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.FinalCprOfHomeEquityPrepaymentCurve ->
        let tag = "233=HEP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStipulationValue (pos:int) (bs:byte[]) : (int * StipulationValue) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"CD"B -> StipulationValue.SpecialCumDividend
        |"XD"B -> StipulationValue.SpecialExDividend
        |"CC"B -> StipulationValue.SpecialCumCoupon
        |"XC"B -> StipulationValue.SpecialExCoupon
        |"CB"B -> StipulationValue.SpecialCumBonus
        |"XB"B -> StipulationValue.SpecialExBonus
        |"CR"B -> StipulationValue.SpecialCumRights
        |"XR"B -> StipulationValue.SpecialExRights
        |"CP"B -> StipulationValue.SpecialCumCapitalRepayments
        |"XP"B -> StipulationValue.SpecialExCapitalRepayments
        |"CS"B -> StipulationValue.CashSettlement
        |"SP"B -> StipulationValue.SpecialPrice
        |"TR"B -> StipulationValue.ReportForEuropeanEquityMarketSecurities
        |"GD"B -> StipulationValue.GuaranteedDelivery
        | x -> failwith (sprintf "ReadStipulationValue unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteStipulationValue (dest:byte array) (nextFreeIdx:int) (xxIn:StipulationValue) : int =
    match xxIn with
    | StipulationValue.SpecialCumDividend ->
        let tag = "234=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExDividend ->
        let tag = "234=XD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumCoupon ->
        let tag = "234=CC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExCoupon ->
        let tag = "234=XC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumBonus ->
        let tag = "234=CB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExBonus ->
        let tag = "234=XB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumRights ->
        let tag = "234=CR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExRights ->
        let tag = "234=XR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumCapitalRepayments ->
        let tag = "234=CP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExCapitalRepayments ->
        let tag = "234=XP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.CashSettlement ->
        let tag = "234=CS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialPrice ->
        let tag = "234=SP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.ReportForEuropeanEquityMarketSecurities ->
        let tag = "234=TR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.GuaranteedDelivery ->
        let tag = "234=GD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadYieldType (pos:int) (bs:byte[]) : (int * YieldType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"AFTERTAX"B -> YieldType.AfterTaxYield
        |"ANNUAL"B -> YieldType.AnnualYield
        |"ATISSUE"B -> YieldType.YieldAtIssue
        |"AVGMATURITY"B -> YieldType.YieldToAverageMaturity
        |"BOOK"B -> YieldType.BookYield
        |"CALL"B -> YieldType.YieldToNextCall
        |"CHANGE"B -> YieldType.YieldChangeSinceClose
        |"CLOSE"B -> YieldType.ClosingYield
        |"COMPOUND"B -> YieldType.CompoundYield
        |"CURRENT"B -> YieldType.CurrentYield
        |"GROSS"B -> YieldType.TrueGrossYield
        |"GOVTEQUIV"B -> YieldType.GovernmentEquivalentYield
        |"INFLATION"B -> YieldType.YieldWithInflationAssumption
        |"INVERSEFLOATER"B -> YieldType.InverseFloaterBondYield
        |"LASTCLOSE"B -> YieldType.MostRecentClosingYield
        |"LASTMONTH"B -> YieldType.ClosingYieldMostRecentMonth
        |"LASTQUARTER"B -> YieldType.ClosingYieldMostRecentQuarter
        |"LASTYEAR"B -> YieldType.ClosingYieldMostRecentYear
        |"LONGAVGLIFE"B -> YieldType.YieldToLongestAverageLife
        |"MARK"B -> YieldType.MarkToMarketYield
        |"MATURITY"B -> YieldType.YieldToMaturity
        |"NEXTREFUND"B -> YieldType.YieldToNextRefund
        |"OPENAVG"B -> YieldType.OpenAverageYield
        |"PUT"B -> YieldType.YieldToNextPut
        |"PREVCLOSE"B -> YieldType.PreviousCloseYield
        |"PROCEEDS"B -> YieldType.ProceedsYield
        |"SEMIANNUAL"B -> YieldType.SemiAnnualYield
        |"SHORTAVGLIFE"B -> YieldType.YieldToShortestAverageLife
        |"SIMPLE"B -> YieldType.SimpleYield
        |"TAXEQUIV"B -> YieldType.TaxEquivalentYield
        |"TENDER"B -> YieldType.YieldToTenderDate
        |"TRUE"B -> YieldType.TrueYield
        |"VALUE1_32"B -> YieldType.YieldValueOf132
        |"WORST"B -> YieldType.YieldToWorst
        | x -> failwith (sprintf "ReadYieldType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteYieldType (dest:byte array) (nextFreeIdx:int) (xxIn:YieldType) : int =
    match xxIn with
    | YieldType.AfterTaxYield ->
        let tag = "235=AFTERTAX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.AnnualYield ->
        let tag = "235=ANNUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldAtIssue ->
        let tag = "235=ATISSUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToAverageMaturity ->
        let tag = "235=AVGMATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.BookYield ->
        let tag = "235=BOOK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextCall ->
        let tag = "235=CALL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldChangeSinceClose ->
        let tag = "235=CHANGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYield ->
        let tag = "235=CLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.CompoundYield ->
        let tag = "235=COMPOUND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.CurrentYield ->
        let tag = "235=CURRENT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TrueGrossYield ->
        let tag = "235=GROSS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.GovernmentEquivalentYield ->
        let tag = "235=GOVTEQUIV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldWithInflationAssumption ->
        let tag = "235=INFLATION"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.InverseFloaterBondYield ->
        let tag = "235=INVERSEFLOATER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.MostRecentClosingYield ->
        let tag = "235=LASTCLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentMonth ->
        let tag = "235=LASTMONTH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentQuarter ->
        let tag = "235=LASTQUARTER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentYear ->
        let tag = "235=LASTYEAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToLongestAverageLife ->
        let tag = "235=LONGAVGLIFE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.MarkToMarketYield ->
        let tag = "235=MARK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToMaturity ->
        let tag = "235=MATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextRefund ->
        let tag = "235=NEXTREFUND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.OpenAverageYield ->
        let tag = "235=OPENAVG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextPut ->
        let tag = "235=PUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.PreviousCloseYield ->
        let tag = "235=PREVCLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ProceedsYield ->
        let tag = "235=PROCEEDS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.SemiAnnualYield ->
        let tag = "235=SEMIANNUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToShortestAverageLife ->
        let tag = "235=SHORTAVGLIFE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.SimpleYield ->
        let tag = "235=SIMPLE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TaxEquivalentYield ->
        let tag = "235=TAXEQUIV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToTenderDate ->
        let tag = "235=TENDER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TrueYield ->
        let tag = "235=TRUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldValueOf132 ->
        let tag = "235=VALUE1_32"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToWorst ->
        let tag = "235=WORST"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadYield (pos:int) (bs:byte[]) : (int*Yield) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Yield.Yield


let WriteYield (dest:byte []) (nextFreeIdx:int) (valIn:Yield) : int = 
   let tag = "236="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotalTakedown (pos:int) (bs:byte[]) : (int*TotalTakedown) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotalTakedown.TotalTakedown


let WriteTotalTakedown (dest:byte []) (nextFreeIdx:int) (valIn:TotalTakedown) : int = 
   let tag = "237="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConcession (pos:int) (bs:byte[]) : (int*Concession) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Concession.Concession


let WriteConcession (dest:byte []) (nextFreeIdx:int) (valIn:Concession) : int = 
   let tag = "238="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRepoCollateralSecurityType (pos:int) (bs:byte[]) : (int*RepoCollateralSecurityType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RepoCollateralSecurityType.RepoCollateralSecurityType


let WriteRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:RepoCollateralSecurityType) : int = 
   let tag = "239="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRedemptionDate (pos:int) (bs:byte[]) : (int*RedemptionDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RedemptionDate.RedemptionDate


let WriteRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:RedemptionDate) : int = 
   let tag = "240="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCouponPaymentDate (pos:int) (bs:byte[]) : (int*UnderlyingCouponPaymentDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCouponPaymentDate.UnderlyingCouponPaymentDate


let WriteUnderlyingCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCouponPaymentDate) : int = 
   let tag = "241="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingIssueDate (pos:int) (bs:byte[]) : (int*UnderlyingIssueDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingIssueDate.UnderlyingIssueDate


let WriteUnderlyingIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingIssueDate) : int = 
   let tag = "242="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingRepoCollateralSecurityType (pos:int) (bs:byte[]) : (int*UnderlyingRepoCollateralSecurityType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingRepoCollateralSecurityType.UnderlyingRepoCollateralSecurityType


let WriteUnderlyingRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepoCollateralSecurityType) : int = 
   let tag = "243="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingRepurchaseTerm (pos:int) (bs:byte[]) : (int*UnderlyingRepurchaseTerm) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingRepurchaseTerm.UnderlyingRepurchaseTerm


let WriteUnderlyingRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepurchaseTerm) : int = 
   let tag = "244="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingRepurchaseRate (pos:int) (bs:byte[]) : (int*UnderlyingRepurchaseRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingRepurchaseRate.UnderlyingRepurchaseRate


let WriteUnderlyingRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepurchaseRate) : int = 
   let tag = "245="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingFactor (pos:int) (bs:byte[]) : (int*UnderlyingFactor) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingFactor.UnderlyingFactor


let WriteUnderlyingFactor (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingFactor) : int = 
   let tag = "246="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingRedemptionDate (pos:int) (bs:byte[]) : (int*UnderlyingRedemptionDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingRedemptionDate.UnderlyingRedemptionDate


let WriteUnderlyingRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRedemptionDate) : int = 
   let tag = "247="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCouponPaymentDate (pos:int) (bs:byte[]) : (int*LegCouponPaymentDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegCouponPaymentDate.LegCouponPaymentDate


let WriteLegCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:LegCouponPaymentDate) : int = 
   let tag = "248="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegIssueDate (pos:int) (bs:byte[]) : (int*LegIssueDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegIssueDate.LegIssueDate


let WriteLegIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:LegIssueDate) : int = 
   let tag = "249="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegRepoCollateralSecurityType (pos:int) (bs:byte[]) : (int*LegRepoCollateralSecurityType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegRepoCollateralSecurityType.LegRepoCollateralSecurityType


let WriteLegRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:LegRepoCollateralSecurityType) : int = 
   let tag = "250="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegRepurchaseTerm (pos:int) (bs:byte[]) : (int*LegRepurchaseTerm) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegRepurchaseTerm.LegRepurchaseTerm


let WriteLegRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:LegRepurchaseTerm) : int = 
   let tag = "251="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegRepurchaseRate (pos:int) (bs:byte[]) : (int*LegRepurchaseRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegRepurchaseRate.LegRepurchaseRate


let WriteLegRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:LegRepurchaseRate) : int = 
   let tag = "252="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegFactor (pos:int) (bs:byte[]) : (int*LegFactor) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegFactor.LegFactor


let WriteLegFactor (dest:byte []) (nextFreeIdx:int) (valIn:LegFactor) : int = 
   let tag = "253="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegRedemptionDate (pos:int) (bs:byte[]) : (int*LegRedemptionDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegRedemptionDate.LegRedemptionDate


let WriteLegRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:LegRedemptionDate) : int = 
   let tag = "254="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCreditRating (pos:int) (bs:byte[]) : (int*CreditRating) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CreditRating.CreditRating


let WriteCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:CreditRating) : int = 
   let tag = "255="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCreditRating (pos:int) (bs:byte[]) : (int*UnderlyingCreditRating) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCreditRating.UnderlyingCreditRating


let WriteUnderlyingCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCreditRating) : int = 
   let tag = "256="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCreditRating (pos:int) (bs:byte[]) : (int*LegCreditRating) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegCreditRating.LegCreditRating


let WriteLegCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:LegCreditRating) : int = 
   let tag = "257="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradedFlatSwitch (pos:int) (bs:byte[]) : (int*TradedFlatSwitch) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) TradedFlatSwitch.TradedFlatSwitch


let WriteTradedFlatSwitch (dest:byte []) (nextFreeIdx:int) (valIn:TradedFlatSwitch) : int = 
   let tag = "258="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBasisFeatureDate (pos:int) (bs:byte[]) : (int*BasisFeatureDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BasisFeatureDate.BasisFeatureDate


let WriteBasisFeatureDate (dest:byte []) (nextFreeIdx:int) (valIn:BasisFeatureDate) : int = 
   let tag = "259="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBasisFeaturePrice (pos:int) (bs:byte[]) : (int*BasisFeaturePrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BasisFeaturePrice.BasisFeaturePrice


let WriteBasisFeaturePrice (dest:byte []) (nextFreeIdx:int) (valIn:BasisFeaturePrice) : int = 
   let tag = "260="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDReqID (pos:int) (bs:byte[]) : (int*MDReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDReqID.MDReqID


let WriteMDReqID (dest:byte []) (nextFreeIdx:int) (valIn:MDReqID) : int = 
   let tag = "262="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSubscriptionRequestType (pos:int) (bs:byte[]) : (int * SubscriptionRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SubscriptionRequestType.Snapshot
        |"1"B -> SubscriptionRequestType.SnapshotPlusUpdates
        |"2"B -> SubscriptionRequestType.DisablePreviousSnapshotPlusUpdateRequest
        | x -> failwith (sprintf "ReadSubscriptionRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSubscriptionRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SubscriptionRequestType) : int =
    match xxIn with
    | SubscriptionRequestType.Snapshot ->
        let tag = "263=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SubscriptionRequestType.SnapshotPlusUpdates ->
        let tag = "263=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SubscriptionRequestType.DisablePreviousSnapshotPlusUpdateRequest ->
        let tag = "263=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMarketDepth (pos:int) (bs:byte[]) : (int*MarketDepth) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MarketDepth.MarketDepth


let WriteMarketDepth (dest:byte []) (nextFreeIdx:int) (valIn:MarketDepth) : int = 
   let tag = "264="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDUpdateType (pos:int) (bs:byte[]) : (int * MDUpdateType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MDUpdateType.FullRefresh
        |"1"B -> MDUpdateType.IncrementalRefresh
        | x -> failwith (sprintf "ReadMDUpdateType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMDUpdateType (dest:byte array) (nextFreeIdx:int) (xxIn:MDUpdateType) : int =
    match xxIn with
    | MDUpdateType.FullRefresh ->
        let tag = "265=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateType.IncrementalRefresh ->
        let tag = "265=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAggregatedBook (pos:int) (bs:byte[]) : (int*AggregatedBook) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) AggregatedBook.AggregatedBook


let WriteAggregatedBook (dest:byte []) (nextFreeIdx:int) (valIn:AggregatedBook) : int = 
   let tag = "266="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoMDEntryTypes (pos:int) (bs:byte[]) : (int*NoMDEntryTypes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoMDEntryTypes.NoMDEntryTypes


let WriteNoMDEntryTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoMDEntryTypes) : int = 
   let tag = "267="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoMDEntries (pos:int) (bs:byte[]) : (int*NoMDEntries) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoMDEntries.NoMDEntries


let WriteNoMDEntries (dest:byte []) (nextFreeIdx:int) (valIn:NoMDEntries) : int = 
   let tag = "268="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntryType (pos:int) (bs:byte[]) : (int * MDEntryType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MDEntryType.Bid
        |"1"B -> MDEntryType.Offer
        |"2"B -> MDEntryType.Trade
        |"3"B -> MDEntryType.IndexValue
        |"4"B -> MDEntryType.OpeningPrice
        |"5"B -> MDEntryType.ClosingPrice
        |"6"B -> MDEntryType.SettlementPrice
        |"7"B -> MDEntryType.TradingSessionHighPrice
        |"8"B -> MDEntryType.TradingSessionLowPrice
        |"9"B -> MDEntryType.TradingSessionVwapPrice
        |"A"B -> MDEntryType.Imbalance
        |"B"B -> MDEntryType.TradeVolume
        |"C"B -> MDEntryType.OpenInterest
        | x -> failwith (sprintf "ReadMDEntryType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMDEntryType (dest:byte array) (nextFreeIdx:int) (xxIn:MDEntryType) : int =
    match xxIn with
    | MDEntryType.Bid ->
        let tag = "269=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Offer ->
        let tag = "269=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Trade ->
        let tag = "269=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.IndexValue ->
        let tag = "269=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.OpeningPrice ->
        let tag = "269=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.ClosingPrice ->
        let tag = "269=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.SettlementPrice ->
        let tag = "269=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionHighPrice ->
        let tag = "269=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionLowPrice ->
        let tag = "269=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionVwapPrice ->
        let tag = "269=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Imbalance ->
        let tag = "269=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradeVolume ->
        let tag = "269=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.OpenInterest ->
        let tag = "269=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryPx (pos:int) (bs:byte[]) : (int*MDEntryPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MDEntryPx.MDEntryPx


let WriteMDEntryPx (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryPx) : int = 
   let tag = "270="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntrySize (pos:int) (bs:byte[]) : (int*MDEntrySize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MDEntrySize.MDEntrySize


let WriteMDEntrySize (dest:byte []) (nextFreeIdx:int) (valIn:MDEntrySize) : int = 
   let tag = "271="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntryDate (pos:int) (bs:byte[]) : (int*MDEntryDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryDate.MDEntryDate


let WriteMDEntryDate (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryDate) : int = 
   let tag = "272="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntryTime (pos:int) (bs:byte[]) : (int*MDEntryTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryTime.MDEntryTime


let WriteMDEntryTime (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryTime) : int = 
   let tag = "273="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTickDirection (pos:int) (bs:byte[]) : (int * TickDirection) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TickDirection.PlusTick
        |"1"B -> TickDirection.ZeroPlusTick
        |"2"B -> TickDirection.MinusTick
        |"3"B -> TickDirection.ZeroMinusTick
        | x -> failwith (sprintf "ReadTickDirection unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTickDirection (dest:byte array) (nextFreeIdx:int) (xxIn:TickDirection) : int =
    match xxIn with
    | TickDirection.PlusTick ->
        let tag = "274=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.ZeroPlusTick ->
        let tag = "274=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.MinusTick ->
        let tag = "274=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.ZeroMinusTick ->
        let tag = "274=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDMkt (pos:int) (bs:byte[]) : (int*MDMkt) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDMkt.MDMkt


let WriteMDMkt (dest:byte []) (nextFreeIdx:int) (valIn:MDMkt) : int = 
   let tag = "275="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteCondition (pos:int) (bs:byte[]) : (int * QuoteCondition) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> QuoteCondition.OpenActive
        |"B"B -> QuoteCondition.ClosedInactive
        |"C"B -> QuoteCondition.ExchangeBest
        |"D"B -> QuoteCondition.ConsolidatedBest
        |"E"B -> QuoteCondition.Locked
        |"F"B -> QuoteCondition.Crossed
        |"G"B -> QuoteCondition.Depth
        |"H"B -> QuoteCondition.FastTrading
        |"I"B -> QuoteCondition.NonFirm
        | x -> failwith (sprintf "ReadQuoteCondition unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteCondition (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteCondition) : int =
    match xxIn with
    | QuoteCondition.OpenActive ->
        let tag = "276=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ClosedInactive ->
        let tag = "276=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ExchangeBest ->
        let tag = "276=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ConsolidatedBest ->
        let tag = "276=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Locked ->
        let tag = "276=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Crossed ->
        let tag = "276=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Depth ->
        let tag = "276=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.FastTrading ->
        let tag = "276=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.NonFirm ->
        let tag = "276=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeCondition (pos:int) (bs:byte[]) : (int * TradeCondition) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> TradeCondition.CashMarket
        |"B"B -> TradeCondition.AveragePriceTrade
        |"C"B -> TradeCondition.CashTrade
        |"D"B -> TradeCondition.NextDayMarket
        |"E"B -> TradeCondition.OpeningReopeningTradeDetail
        |"F"B -> TradeCondition.IntradayTradeDetail
        |"G"B -> TradeCondition.Rule127
        |"H"B -> TradeCondition.Rule155
        |"I"B -> TradeCondition.SoldLast
        |"J"B -> TradeCondition.NextDayTrade
        |"K"B -> TradeCondition.Opened
        |"L"B -> TradeCondition.Seller
        |"M"B -> TradeCondition.Sold
        |"N"B -> TradeCondition.StoppedStock
        |"P"B -> TradeCondition.ImbalanceMoreBuyers
        |"Q"B -> TradeCondition.ImbalanceMoreSellers
        |"R"B -> TradeCondition.OpeningPrice
        | x -> failwith (sprintf "ReadTradeCondition unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeCondition (dest:byte array) (nextFreeIdx:int) (xxIn:TradeCondition) : int =
    match xxIn with
    | TradeCondition.CashMarket ->
        let tag = "277=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.AveragePriceTrade ->
        let tag = "277=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.CashTrade ->
        let tag = "277=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.NextDayMarket ->
        let tag = "277=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.OpeningReopeningTradeDetail ->
        let tag = "277=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.IntradayTradeDetail ->
        let tag = "277=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Rule127 ->
        let tag = "277=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Rule155 ->
        let tag = "277=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.SoldLast ->
        let tag = "277=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.NextDayTrade ->
        let tag = "277=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Opened ->
        let tag = "277=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Seller ->
        let tag = "277=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Sold ->
        let tag = "277=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.StoppedStock ->
        let tag = "277=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.ImbalanceMoreBuyers ->
        let tag = "277=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.ImbalanceMoreSellers ->
        let tag = "277=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.OpeningPrice ->
        let tag = "277=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryID (pos:int) (bs:byte[]) : (int*MDEntryID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryID.MDEntryID


let WriteMDEntryID (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryID) : int = 
   let tag = "278="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDUpdateAction (pos:int) (bs:byte[]) : (int * MDUpdateAction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MDUpdateAction.New
        |"1"B -> MDUpdateAction.Change
        |"2"B -> MDUpdateAction.Delete
        | x -> failwith (sprintf "ReadMDUpdateAction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMDUpdateAction (dest:byte array) (nextFreeIdx:int) (xxIn:MDUpdateAction) : int =
    match xxIn with
    | MDUpdateAction.New ->
        let tag = "279=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateAction.Change ->
        let tag = "279=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateAction.Delete ->
        let tag = "279=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryRefID (pos:int) (bs:byte[]) : (int*MDEntryRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryRefID.MDEntryRefID


let WriteMDEntryRefID (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryRefID) : int = 
   let tag = "280="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDReqRejReason (pos:int) (bs:byte[]) : (int * MDReqRejReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MDReqRejReason.UnknownSymbol
        |"1"B -> MDReqRejReason.DuplicateMdreqid
        |"2"B -> MDReqRejReason.InsufficientBandwidth
        |"3"B -> MDReqRejReason.InsufficientPermissions
        |"4"B -> MDReqRejReason.UnsupportedSubscriptionrequesttype
        |"5"B -> MDReqRejReason.UnsupportedMarketdepth
        |"6"B -> MDReqRejReason.UnsupportedMdupdatetype
        |"7"B -> MDReqRejReason.UnsupportedAggregatedbook
        |"8"B -> MDReqRejReason.UnsupportedMdentrytype
        |"9"B -> MDReqRejReason.UnsupportedTradingsessionid
        |"A"B -> MDReqRejReason.UnsupportedScope
        |"B"B -> MDReqRejReason.UnsupportedOpenclosesettleflag
        |"C"B -> MDReqRejReason.UnsupportedMdimplicitdelete
        | x -> failwith (sprintf "ReadMDReqRejReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMDReqRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:MDReqRejReason) : int =
    match xxIn with
    | MDReqRejReason.UnknownSymbol ->
        let tag = "281=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.DuplicateMdreqid ->
        let tag = "281=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.InsufficientBandwidth ->
        let tag = "281=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.InsufficientPermissions ->
        let tag = "281=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedSubscriptionrequesttype ->
        let tag = "281=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMarketdepth ->
        let tag = "281=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdupdatetype ->
        let tag = "281=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedAggregatedbook ->
        let tag = "281=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdentrytype ->
        let tag = "281=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedTradingsessionid ->
        let tag = "281=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedScope ->
        let tag = "281=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedOpenclosesettleflag ->
        let tag = "281=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdimplicitdelete ->
        let tag = "281=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryOriginator (pos:int) (bs:byte[]) : (int*MDEntryOriginator) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryOriginator.MDEntryOriginator


let WriteMDEntryOriginator (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryOriginator) : int = 
   let tag = "282="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLocationID (pos:int) (bs:byte[]) : (int*LocationID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LocationID.LocationID


let WriteLocationID (dest:byte []) (nextFreeIdx:int) (valIn:LocationID) : int = 
   let tag = "283="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeskID (pos:int) (bs:byte[]) : (int*DeskID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DeskID.DeskID


let WriteDeskID (dest:byte []) (nextFreeIdx:int) (valIn:DeskID) : int = 
   let tag = "284="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeleteReason (pos:int) (bs:byte[]) : (int * DeleteReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DeleteReason.CancelationTradeBust
        |"1"B -> DeleteReason.Error
        | x -> failwith (sprintf "ReadDeleteReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDeleteReason (dest:byte array) (nextFreeIdx:int) (xxIn:DeleteReason) : int =
    match xxIn with
    | DeleteReason.CancelationTradeBust ->
        let tag = "285=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeleteReason.Error ->
        let tag = "285=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOpenCloseSettlFlag (pos:int) (bs:byte[]) : (int * OpenCloseSettlFlag) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> OpenCloseSettlFlag.DailyOpenCloseSettlementEntry
        |"1"B -> OpenCloseSettlFlag.SessionOpenCloseSettlementEntry
        |"2"B -> OpenCloseSettlFlag.DeliverySettlementEntry
        |"3"B -> OpenCloseSettlFlag.ExpectedEntry
        |"4"B -> OpenCloseSettlFlag.EntryFromPreviousBusinessDay
        |"5"B -> OpenCloseSettlFlag.TheoreticalPriceValue
        | x -> failwith (sprintf "ReadOpenCloseSettlFlag unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOpenCloseSettlFlag (dest:byte array) (nextFreeIdx:int) (xxIn:OpenCloseSettlFlag) : int =
    match xxIn with
    | OpenCloseSettlFlag.DailyOpenCloseSettlementEntry ->
        let tag = "286=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.SessionOpenCloseSettlementEntry ->
        let tag = "286=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.DeliverySettlementEntry ->
        let tag = "286=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.ExpectedEntry ->
        let tag = "286=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.EntryFromPreviousBusinessDay ->
        let tag = "286=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.TheoreticalPriceValue ->
        let tag = "286=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSellerDays (pos:int) (bs:byte[]) : (int*SellerDays) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SellerDays.SellerDays


let WriteSellerDays (dest:byte []) (nextFreeIdx:int) (valIn:SellerDays) : int = 
   let tag = "287="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntryBuyer (pos:int) (bs:byte[]) : (int*MDEntryBuyer) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntryBuyer.MDEntryBuyer


let WriteMDEntryBuyer (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryBuyer) : int = 
   let tag = "288="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntrySeller (pos:int) (bs:byte[]) : (int*MDEntrySeller) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MDEntrySeller.MDEntrySeller


let WriteMDEntrySeller (dest:byte []) (nextFreeIdx:int) (valIn:MDEntrySeller) : int = 
   let tag = "289="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMDEntryPositionNo (pos:int) (bs:byte[]) : (int*MDEntryPositionNo) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MDEntryPositionNo.MDEntryPositionNo


let WriteMDEntryPositionNo (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryPositionNo) : int = 
   let tag = "290="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadFinancialStatus (pos:int) (bs:byte[]) : (int * FinancialStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> FinancialStatus.Bankrupt
        |"2"B -> FinancialStatus.PendingDelisting
        | x -> failwith (sprintf "ReadFinancialStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteFinancialStatus (dest:byte array) (nextFreeIdx:int) (xxIn:FinancialStatus) : int =
    match xxIn with
    | FinancialStatus.Bankrupt ->
        let tag = "291=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | FinancialStatus.PendingDelisting ->
        let tag = "291=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCorporateAction (pos:int) (bs:byte[]) : (int * CorporateAction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> CorporateAction.ExDividend
        |"B"B -> CorporateAction.ExDistribution
        |"C"B -> CorporateAction.ExRights
        |"D"B -> CorporateAction.New
        |"E"B -> CorporateAction.ExInterest
        | x -> failwith (sprintf "ReadCorporateAction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCorporateAction (dest:byte array) (nextFreeIdx:int) (xxIn:CorporateAction) : int =
    match xxIn with
    | CorporateAction.ExDividend ->
        let tag = "292=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExDistribution ->
        let tag = "292=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExRights ->
        let tag = "292=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.New ->
        let tag = "292=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExInterest ->
        let tag = "292=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDefBidSize (pos:int) (bs:byte[]) : (int*DefBidSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DefBidSize.DefBidSize


let WriteDefBidSize (dest:byte []) (nextFreeIdx:int) (valIn:DefBidSize) : int = 
   let tag = "293="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDefOfferSize (pos:int) (bs:byte[]) : (int*DefOfferSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DefOfferSize.DefOfferSize


let WriteDefOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:DefOfferSize) : int = 
   let tag = "294="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoQuoteEntries (pos:int) (bs:byte[]) : (int*NoQuoteEntries) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoQuoteEntries.NoQuoteEntries


let WriteNoQuoteEntries (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteEntries) : int = 
   let tag = "295="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoQuoteSets (pos:int) (bs:byte[]) : (int*NoQuoteSets) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoQuoteSets.NoQuoteSets


let WriteNoQuoteSets (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteSets) : int = 
   let tag = "296="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteStatus (pos:int) (bs:byte[]) : (int * QuoteStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> QuoteStatus.Accepted
        |"1"B -> QuoteStatus.CanceledForSymbol
        |"2"B -> QuoteStatus.CanceledForSecurityType
        |"3"B -> QuoteStatus.CanceledForUnderlying
        |"4"B -> QuoteStatus.CanceledAll
        |"5"B -> QuoteStatus.Rejected
        |"6"B -> QuoteStatus.RemovedFromMarket
        |"7"B -> QuoteStatus.Expired
        |"8"B -> QuoteStatus.Query
        |"9"B -> QuoteStatus.QuoteNotFound
        |"10"B -> QuoteStatus.Pending
        |"11"B -> QuoteStatus.Pass
        |"12"B -> QuoteStatus.LockedMarketWarning
        |"13"B -> QuoteStatus.CrossMarketWarning
        |"14"B -> QuoteStatus.CanceledDueToLockMarket
        |"15"B -> QuoteStatus.CanceledDueToCrossMarket
        | x -> failwith (sprintf "ReadQuoteStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteStatus (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteStatus) : int =
    match xxIn with
    | QuoteStatus.Accepted ->
        let tag = "297=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForSymbol ->
        let tag = "297=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForSecurityType ->
        let tag = "297=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForUnderlying ->
        let tag = "297=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledAll ->
        let tag = "297=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Rejected ->
        let tag = "297=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.RemovedFromMarket ->
        let tag = "297=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Expired ->
        let tag = "297=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Query ->
        let tag = "297=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.QuoteNotFound ->
        let tag = "297=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Pending ->
        let tag = "297=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Pass ->
        let tag = "297=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.LockedMarketWarning ->
        let tag = "297=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CrossMarketWarning ->
        let tag = "297=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledDueToLockMarket ->
        let tag = "297=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledDueToCrossMarket ->
        let tag = "297=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteCancelType (pos:int) (bs:byte[]) : (int * QuoteCancelType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteCancelType.CancelForSymbol
        |"2"B -> QuoteCancelType.CancelForSecurityType
        |"3"B -> QuoteCancelType.CancelForUnderlyingSymbol
        |"4"B -> QuoteCancelType.CancelAllQuotes
        | x -> failwith (sprintf "ReadQuoteCancelType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteCancelType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteCancelType) : int =
    match xxIn with
    | QuoteCancelType.CancelForSymbol ->
        let tag = "298=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelForSecurityType ->
        let tag = "298=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelForUnderlyingSymbol ->
        let tag = "298=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelAllQuotes ->
        let tag = "298=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteEntryID (pos:int) (bs:byte[]) : (int*QuoteEntryID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteEntryID.QuoteEntryID


let WriteQuoteEntryID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteEntryID) : int = 
   let tag = "299="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteRejectReason (pos:int) (bs:byte[]) : (int * QuoteRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteRejectReason.UnknownSymbol
        |"2"B -> QuoteRejectReason.ExchangeClosed
        |"3"B -> QuoteRejectReason.QuoteRequestExceedsLimit
        |"4"B -> QuoteRejectReason.TooLateToEnter
        |"5"B -> QuoteRejectReason.UnknownQuote
        |"6"B -> QuoteRejectReason.DuplicateQuote
        |"7"B -> QuoteRejectReason.InvalidBidAskSpread
        |"8"B -> QuoteRejectReason.InvalidPrice
        |"9"B -> QuoteRejectReason.NotAuthorizedToQuoteSecurity
        |"99"B -> QuoteRejectReason.Other
        | x -> failwith (sprintf "ReadQuoteRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRejectReason) : int =
    match xxIn with
    | QuoteRejectReason.UnknownSymbol ->
        let tag = "300=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.ExchangeClosed ->
        let tag = "300=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.QuoteRequestExceedsLimit ->
        let tag = "300=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.TooLateToEnter ->
        let tag = "300=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.UnknownQuote ->
        let tag = "300=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.DuplicateQuote ->
        let tag = "300=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.InvalidBidAskSpread ->
        let tag = "300=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.InvalidPrice ->
        let tag = "300=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.NotAuthorizedToQuoteSecurity ->
        let tag = "300=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.Other ->
        let tag = "300=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteResponseLevel (pos:int) (bs:byte[]) : (int * QuoteResponseLevel) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> QuoteResponseLevel.NoAcknowledgement
        |"1"B -> QuoteResponseLevel.AcknowledgeOnlyNegativeOrErroneousQuotes
        |"2"B -> QuoteResponseLevel.AcknowledgeEachQuoteMessages
        | x -> failwith (sprintf "ReadQuoteResponseLevel unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteResponseLevel (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteResponseLevel) : int =
    match xxIn with
    | QuoteResponseLevel.NoAcknowledgement ->
        let tag = "301=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteResponseLevel.AcknowledgeOnlyNegativeOrErroneousQuotes ->
        let tag = "301=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteResponseLevel.AcknowledgeEachQuoteMessages ->
        let tag = "301=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteSetID (pos:int) (bs:byte[]) : (int*QuoteSetID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteSetID.QuoteSetID


let WriteQuoteSetID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteSetID) : int = 
   let tag = "302="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteRequestType (pos:int) (bs:byte[]) : (int * QuoteRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteRequestType.Manual
        |"2"B -> QuoteRequestType.Automatic
        | x -> failwith (sprintf "ReadQuoteRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRequestType) : int =
    match xxIn with
    | QuoteRequestType.Manual ->
        let tag = "303=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestType.Automatic ->
        let tag = "303=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNoQuoteEntries (pos:int) (bs:byte[]) : (int*TotNoQuoteEntries) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoQuoteEntries.TotNoQuoteEntries


let WriteTotNoQuoteEntries (dest:byte []) (nextFreeIdx:int) (valIn:TotNoQuoteEntries) : int = 
   let tag = "304="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityIDSource (pos:int) (bs:byte[]) : (int*UnderlyingSecurityIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityIDSource.UnderlyingSecurityIDSource


let WriteUnderlyingSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityIDSource) : int = 
   let tag = "305="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingIssuer (pos:int) (bs:byte[]) : (int*UnderlyingIssuer) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingIssuer.UnderlyingIssuer


let WriteUnderlyingIssuer (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingIssuer) : int = 
   let tag = "306="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityDesc (pos:int) (bs:byte[]) : (int*UnderlyingSecurityDesc) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityDesc.UnderlyingSecurityDesc


let WriteUnderlyingSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityDesc) : int = 
   let tag = "307="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityExchange (pos:int) (bs:byte[]) : (int*UnderlyingSecurityExchange) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityExchange.UnderlyingSecurityExchange


let WriteUnderlyingSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityExchange) : int = 
   let tag = "308="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityID (pos:int) (bs:byte[]) : (int*UnderlyingSecurityID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityID.UnderlyingSecurityID


let WriteUnderlyingSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityID) : int = 
   let tag = "309="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityType (pos:int) (bs:byte[]) : (int*UnderlyingSecurityType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityType.UnderlyingSecurityType


let WriteUnderlyingSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityType) : int = 
   let tag = "310="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSymbol (pos:int) (bs:byte[]) : (int*UnderlyingSymbol) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSymbol.UnderlyingSymbol


let WriteUnderlyingSymbol (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSymbol) : int = 
   let tag = "311="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSymbolSfx (pos:int) (bs:byte[]) : (int*UnderlyingSymbolSfx) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSymbolSfx.UnderlyingSymbolSfx


let WriteUnderlyingSymbolSfx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSymbolSfx) : int = 
   let tag = "312="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingMaturityMonthYear (pos:int) (bs:byte[]) : (int*UnderlyingMaturityMonthYear) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingMaturityMonthYear.UnderlyingMaturityMonthYear


let WriteUnderlyingMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingMaturityMonthYear) : int = 
   let tag = "313="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingPutOrCall (pos:int) (bs:byte[]) : (int * UnderlyingPutOrCall) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> UnderlyingPutOrCall.Put
        |"1"B -> UnderlyingPutOrCall.Call
        | x -> failwith (sprintf "ReadUnderlyingPutOrCall unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteUnderlyingPutOrCall (dest:byte array) (nextFreeIdx:int) (xxIn:UnderlyingPutOrCall) : int =
    match xxIn with
    | UnderlyingPutOrCall.Put ->
        let tag = "315=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UnderlyingPutOrCall.Call ->
        let tag = "315=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingStrikePrice (pos:int) (bs:byte[]) : (int*UnderlyingStrikePrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingStrikePrice.UnderlyingStrikePrice


let WriteUnderlyingStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStrikePrice) : int = 
   let tag = "316="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingOptAttribute (pos:int) (bs:byte[]) : (int*UnderlyingOptAttribute) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingOptAttribute.UnderlyingOptAttribute


let WriteUnderlyingOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingOptAttribute) : int = 
   let tag = "317="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCurrency (pos:int) (bs:byte[]) : (int*UnderlyingCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCurrency.UnderlyingCurrency


let WriteUnderlyingCurrency (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCurrency) : int = 
   let tag = "318="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityReqID (pos:int) (bs:byte[]) : (int*SecurityReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityReqID.SecurityReqID


let WriteSecurityReqID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityReqID) : int = 
   let tag = "320="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityRequestType (pos:int) (bs:byte[]) : (int * SecurityRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SecurityRequestType.RequestSecurityIdentityAndSpecifications
        |"1"B -> SecurityRequestType.RequestSecurityIdentityForTheSpecificationsProvided
        |"2"B -> SecurityRequestType.RequestListSecurityTypes
        |"3"B -> SecurityRequestType.RequestListSecurities
        | x -> failwith (sprintf "ReadSecurityRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityRequestType) : int =
    match xxIn with
    | SecurityRequestType.RequestSecurityIdentityAndSpecifications ->
        let tag = "321=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestSecurityIdentityForTheSpecificationsProvided ->
        let tag = "321=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestListSecurityTypes ->
        let tag = "321=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestListSecurities ->
        let tag = "321=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityResponseID (pos:int) (bs:byte[]) : (int*SecurityResponseID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityResponseID.SecurityResponseID


let WriteSecurityResponseID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityResponseID) : int = 
   let tag = "322="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityResponseType (pos:int) (bs:byte[]) : (int * SecurityResponseType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SecurityResponseType.AcceptSecurityProposalAsIs
        |"2"B -> SecurityResponseType.AcceptSecurityProposalWithRevisionsAsIndicatedInTheMessage
        |"3"B -> SecurityResponseType.ListOfSecurityTypesReturnedPerRequest
        |"4"B -> SecurityResponseType.ListOfSecuritiesReturnedPerRequest
        |"5"B -> SecurityResponseType.RejectSecurityProposal
        |"6"B -> SecurityResponseType.CanNotMatchSelectionCriteria
        | x -> failwith (sprintf "ReadSecurityResponseType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityResponseType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityResponseType) : int =
    match xxIn with
    | SecurityResponseType.AcceptSecurityProposalAsIs ->
        let tag = "323=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.AcceptSecurityProposalWithRevisionsAsIndicatedInTheMessage ->
        let tag = "323=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.ListOfSecurityTypesReturnedPerRequest ->
        let tag = "323=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.ListOfSecuritiesReturnedPerRequest ->
        let tag = "323=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.RejectSecurityProposal ->
        let tag = "323=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.CanNotMatchSelectionCriteria ->
        let tag = "323=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityStatusReqID (pos:int) (bs:byte[]) : (int*SecurityStatusReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityStatusReqID.SecurityStatusReqID


let WriteSecurityStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityStatusReqID) : int = 
   let tag = "324="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnsolicitedIndicator (pos:int) (bs:byte[]) : (int*UnsolicitedIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) UnsolicitedIndicator.UnsolicitedIndicator


let WriteUnsolicitedIndicator (dest:byte []) (nextFreeIdx:int) (valIn:UnsolicitedIndicator) : int = 
   let tag = "325="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityTradingStatus (pos:int) (bs:byte[]) : (int * SecurityTradingStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SecurityTradingStatus.OpeningDelay
        |"2"B -> SecurityTradingStatus.TradingHalt
        |"3"B -> SecurityTradingStatus.Resume
        |"4"B -> SecurityTradingStatus.NoOpenNoResume
        |"5"B -> SecurityTradingStatus.PriceIndication
        |"6"B -> SecurityTradingStatus.TradingRangeIndication
        |"7"B -> SecurityTradingStatus.MarketImbalanceBuy
        |"8"B -> SecurityTradingStatus.MarketImbalanceSell
        |"9"B -> SecurityTradingStatus.MarketOnCloseImbalanceBuy
        |"10"B -> SecurityTradingStatus.MarketOnCloseImbalanceSell
        |"11"B -> SecurityTradingStatus.NotAssigned
        |"12"B -> SecurityTradingStatus.NoMarketImbalance
        |"13"B -> SecurityTradingStatus.NoMarketOnCloseImbalance
        |"14"B -> SecurityTradingStatus.ItsPreOpening
        |"15"B -> SecurityTradingStatus.NewPriceIndication
        |"16"B -> SecurityTradingStatus.TradeDisseminationTime
        |"17"B -> SecurityTradingStatus.ReadyToTradeStartOfSession
        |"18"B -> SecurityTradingStatus.NotAvailableForTradingEndOfSession
        |"19"B -> SecurityTradingStatus.NotTradedOnThisMarket
        |"20"B -> SecurityTradingStatus.UnknownOrInvalid
        |"21"B -> SecurityTradingStatus.PreOpen
        |"22"B -> SecurityTradingStatus.OpeningRotation
        |"23"B -> SecurityTradingStatus.FastMarket
        | x -> failwith (sprintf "ReadSecurityTradingStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityTradingStatus (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityTradingStatus) : int =
    match xxIn with
    | SecurityTradingStatus.OpeningDelay ->
        let tag = "326=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradingHalt ->
        let tag = "326=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.Resume ->
        let tag = "326=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoOpenNoResume ->
        let tag = "326=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.PriceIndication ->
        let tag = "326=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradingRangeIndication ->
        let tag = "326=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketImbalanceBuy ->
        let tag = "326=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketImbalanceSell ->
        let tag = "326=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketOnCloseImbalanceBuy ->
        let tag = "326=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketOnCloseImbalanceSell ->
        let tag = "326=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotAssigned ->
        let tag = "326=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoMarketImbalance ->
        let tag = "326=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoMarketOnCloseImbalance ->
        let tag = "326=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.ItsPreOpening ->
        let tag = "326=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NewPriceIndication ->
        let tag = "326=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradeDisseminationTime ->
        let tag = "326=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.ReadyToTradeStartOfSession ->
        let tag = "326=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotAvailableForTradingEndOfSession ->
        let tag = "326=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotTradedOnThisMarket ->
        let tag = "326=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.UnknownOrInvalid ->
        let tag = "326=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.PreOpen ->
        let tag = "326=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.OpeningRotation ->
        let tag = "326=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.FastMarket ->
        let tag = "326=23"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadHaltReason (pos:int) (bs:byte[]) : (int * HaltReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"I"B -> HaltReason.OrderImbalance
        |"X"B -> HaltReason.EquipmentChangeover
        |"P"B -> HaltReason.NewsPending
        |"D"B -> HaltReason.NewsDissemination
        |"E"B -> HaltReason.OrderInflux
        |"M"B -> HaltReason.AdditionalInformation
        | x -> failwith (sprintf "ReadHaltReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteHaltReason (dest:byte array) (nextFreeIdx:int) (xxIn:HaltReason) : int =
    match xxIn with
    | HaltReason.OrderImbalance ->
        let tag = "327=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.EquipmentChangeover ->
        let tag = "327=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.NewsPending ->
        let tag = "327=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.NewsDissemination ->
        let tag = "327=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.OrderInflux ->
        let tag = "327=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.AdditionalInformation ->
        let tag = "327=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadInViewOfCommon (pos:int) (bs:byte[]) : (int*InViewOfCommon) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) InViewOfCommon.InViewOfCommon


let WriteInViewOfCommon (dest:byte []) (nextFreeIdx:int) (valIn:InViewOfCommon) : int = 
   let tag = "328="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDueToRelated (pos:int) (bs:byte[]) : (int*DueToRelated) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) DueToRelated.DueToRelated


let WriteDueToRelated (dest:byte []) (nextFreeIdx:int) (valIn:DueToRelated) : int = 
   let tag = "329="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBuyVolume (pos:int) (bs:byte[]) : (int*BuyVolume) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BuyVolume.BuyVolume


let WriteBuyVolume (dest:byte []) (nextFreeIdx:int) (valIn:BuyVolume) : int = 
   let tag = "330="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSellVolume (pos:int) (bs:byte[]) : (int*SellVolume) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) SellVolume.SellVolume


let WriteSellVolume (dest:byte []) (nextFreeIdx:int) (valIn:SellVolume) : int = 
   let tag = "331="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHighPx (pos:int) (bs:byte[]) : (int*HighPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) HighPx.HighPx


let WriteHighPx (dest:byte []) (nextFreeIdx:int) (valIn:HighPx) : int = 
   let tag = "332="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLowPx (pos:int) (bs:byte[]) : (int*LowPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LowPx.LowPx


let WriteLowPx (dest:byte []) (nextFreeIdx:int) (valIn:LowPx) : int = 
   let tag = "333="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAdjustment (pos:int) (bs:byte[]) : (int * Adjustment) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> Adjustment.Cancel
        |"2"B -> Adjustment.Error
        |"3"B -> Adjustment.Correction
        | x -> failwith (sprintf "ReadAdjustment unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAdjustment (dest:byte array) (nextFreeIdx:int) (xxIn:Adjustment) : int =
    match xxIn with
    | Adjustment.Cancel ->
        let tag = "334=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Adjustment.Error ->
        let tag = "334=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Adjustment.Correction ->
        let tag = "334=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesReqID (pos:int) (bs:byte[]) : (int*TradSesReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesReqID.TradSesReqID


let WriteTradSesReqID (dest:byte []) (nextFreeIdx:int) (valIn:TradSesReqID) : int = 
   let tag = "335="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradingSessionID (pos:int) (bs:byte[]) : (int*TradingSessionID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradingSessionID.TradingSessionID


let WriteTradingSessionID (dest:byte []) (nextFreeIdx:int) (valIn:TradingSessionID) : int = 
   let tag = "336="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContraTrader (pos:int) (bs:byte[]) : (int*ContraTrader) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContraTrader.ContraTrader


let WriteContraTrader (dest:byte []) (nextFreeIdx:int) (valIn:ContraTrader) : int = 
   let tag = "337="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesMethod (pos:int) (bs:byte[]) : (int * TradSesMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> TradSesMethod.Electronic
        |"2"B -> TradSesMethod.OpenOutcry
        |"3"B -> TradSesMethod.TwoParty
        | x -> failwith (sprintf "ReadTradSesMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradSesMethod (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesMethod) : int =
    match xxIn with
    | TradSesMethod.Electronic ->
        let tag = "338=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMethod.OpenOutcry ->
        let tag = "338=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMethod.TwoParty ->
        let tag = "338=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesMode (pos:int) (bs:byte[]) : (int * TradSesMode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> TradSesMode.Testing
        |"2"B -> TradSesMode.Simulated
        |"3"B -> TradSesMode.Production
        | x -> failwith (sprintf "ReadTradSesMode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradSesMode (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesMode) : int =
    match xxIn with
    | TradSesMode.Testing ->
        let tag = "339=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMode.Simulated ->
        let tag = "339=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMode.Production ->
        let tag = "339=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesStatus (pos:int) (bs:byte[]) : (int * TradSesStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradSesStatus.Unknown
        |"1"B -> TradSesStatus.Halted
        |"2"B -> TradSesStatus.Open
        |"3"B -> TradSesStatus.Closed
        |"4"B -> TradSesStatus.PreOpen
        |"5"B -> TradSesStatus.PreClose
        |"6"B -> TradSesStatus.RequestRejected
        | x -> failwith (sprintf "ReadTradSesStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradSesStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesStatus) : int =
    match xxIn with
    | TradSesStatus.Unknown ->
        let tag = "340=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Halted ->
        let tag = "340=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Open ->
        let tag = "340=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Closed ->
        let tag = "340=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.PreOpen ->
        let tag = "340=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.PreClose ->
        let tag = "340=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.RequestRejected ->
        let tag = "340=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesStartTime (pos:int) (bs:byte[]) : (int*TradSesStartTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesStartTime.TradSesStartTime


let WriteTradSesStartTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesStartTime) : int = 
   let tag = "341="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesOpenTime (pos:int) (bs:byte[]) : (int*TradSesOpenTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesOpenTime.TradSesOpenTime


let WriteTradSesOpenTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesOpenTime) : int = 
   let tag = "342="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesPreCloseTime (pos:int) (bs:byte[]) : (int*TradSesPreCloseTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesPreCloseTime.TradSesPreCloseTime


let WriteTradSesPreCloseTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesPreCloseTime) : int = 
   let tag = "343="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesCloseTime (pos:int) (bs:byte[]) : (int*TradSesCloseTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesCloseTime.TradSesCloseTime


let WriteTradSesCloseTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesCloseTime) : int = 
   let tag = "344="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesEndTime (pos:int) (bs:byte[]) : (int*TradSesEndTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradSesEndTime.TradSesEndTime


let WriteTradSesEndTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesEndTime) : int = 
   let tag = "345="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNumberOfOrders (pos:int) (bs:byte[]) : (int*NumberOfOrders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NumberOfOrders.NumberOfOrders


let WriteNumberOfOrders (dest:byte []) (nextFreeIdx:int) (valIn:NumberOfOrders) : int = 
   let tag = "346="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMessageEncoding (pos:int) (bs:byte[]) : (int * MessageEncoding) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"ISO-2022-JP"B -> MessageEncoding.Iso2022Jp
        |"EUC-JP"B -> MessageEncoding.EucJp
        |"SHIFT_JIS"B -> MessageEncoding.ShiftJis
        |"UTF-8"B -> MessageEncoding.Utf8
        | x -> failwith (sprintf "ReadMessageEncoding unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMessageEncoding (dest:byte array) (nextFreeIdx:int) (xxIn:MessageEncoding) : int =
    match xxIn with
    | MessageEncoding.Iso2022Jp ->
        let tag = "347=ISO-2022-JP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.EucJp ->
        let tag = "347=EUC-JP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.ShiftJis ->
        let tag = "347=SHIFT_JIS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.Utf8 ->
        let tag = "347=UTF-8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "348="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedIssuer (pos:int) (bs:byte[]) : (int * EncodedIssuer) =
    ReadLengthStringCompoundField "349"B (pos:int) (bs:byte[]) EncodedIssuer.EncodedIssuer


// compound write, of a length field and the corresponding string field
let WriteEncodedSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "350="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedSecurityDesc (pos:int) (bs:byte[]) : (int * EncodedSecurityDesc) =
    ReadLengthStringCompoundField "351"B (pos:int) (bs:byte[]) EncodedSecurityDesc.EncodedSecurityDesc


// compound write, of a length field and the corresponding string field
let WriteEncodedListExecInst (dest:byte []) (nextFreeIdx:int) (fld:EncodedListExecInst) : int =
    // write the string length part of the compound msg
    let lenTag = "352="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedListExecInst (pos:int) (bs:byte[]) : (int * EncodedListExecInst) =
    ReadLengthStringCompoundField "353"B (pos:int) (bs:byte[]) EncodedListExecInst.EncodedListExecInst


// compound write, of a length field and the corresponding string field
let WriteEncodedText (dest:byte []) (nextFreeIdx:int) (fld:EncodedText) : int =
    // write the string length part of the compound msg
    let lenTag = "354="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedText (pos:int) (bs:byte[]) : (int * EncodedText) =
    ReadLengthStringCompoundField "355"B (pos:int) (bs:byte[]) EncodedText.EncodedText


// compound write, of a length field and the corresponding string field
let WriteEncodedSubject (dest:byte []) (nextFreeIdx:int) (fld:EncodedSubject) : int =
    // write the string length part of the compound msg
    let lenTag = "356="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedSubject (pos:int) (bs:byte[]) : (int * EncodedSubject) =
    ReadLengthStringCompoundField "357"B (pos:int) (bs:byte[]) EncodedSubject.EncodedSubject


// compound write, of a length field and the corresponding string field
let WriteEncodedHeadline (dest:byte []) (nextFreeIdx:int) (fld:EncodedHeadline) : int =
    // write the string length part of the compound msg
    let lenTag = "358="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedHeadline (pos:int) (bs:byte[]) : (int * EncodedHeadline) =
    ReadLengthStringCompoundField "359"B (pos:int) (bs:byte[]) EncodedHeadline.EncodedHeadline


// compound write, of a length field and the corresponding string field
let WriteEncodedAllocText (dest:byte []) (nextFreeIdx:int) (fld:EncodedAllocText) : int =
    // write the string length part of the compound msg
    let lenTag = "360="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedAllocText (pos:int) (bs:byte[]) : (int * EncodedAllocText) =
    ReadLengthStringCompoundField "361"B (pos:int) (bs:byte[]) EncodedAllocText.EncodedAllocText


// compound write, of a length field and the corresponding string field
let WriteEncodedUnderlyingIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedUnderlyingIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "362="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedUnderlyingIssuer (pos:int) (bs:byte[]) : (int * EncodedUnderlyingIssuer) =
    ReadLengthStringCompoundField "363"B (pos:int) (bs:byte[]) EncodedUnderlyingIssuer.EncodedUnderlyingIssuer


// compound write, of a length field and the corresponding string field
let WriteEncodedUnderlyingSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedUnderlyingSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "364="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedUnderlyingSecurityDesc (pos:int) (bs:byte[]) : (int * EncodedUnderlyingSecurityDesc) =
    ReadLengthStringCompoundField "365"B (pos:int) (bs:byte[]) EncodedUnderlyingSecurityDesc.EncodedUnderlyingSecurityDesc


let ReadAllocPrice (pos:int) (bs:byte[]) : (int*AllocPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AllocPrice.AllocPrice


let WriteAllocPrice (dest:byte []) (nextFreeIdx:int) (valIn:AllocPrice) : int = 
   let tag = "366="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteSetValidUntilTime (pos:int) (bs:byte[]) : (int*QuoteSetValidUntilTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteSetValidUntilTime.QuoteSetValidUntilTime


let WriteQuoteSetValidUntilTime (dest:byte []) (nextFreeIdx:int) (valIn:QuoteSetValidUntilTime) : int = 
   let tag = "367="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteEntryRejectReason (pos:int) (bs:byte[]) : (int * QuoteEntryRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteEntryRejectReason.UnknownSymbol
        |"2"B -> QuoteEntryRejectReason.ExchangeClosed
        |"3"B -> QuoteEntryRejectReason.QuoteExceedsLimit
        |"4"B -> QuoteEntryRejectReason.TooLateToEnter
        |"5"B -> QuoteEntryRejectReason.UnknownQuote
        |"6"B -> QuoteEntryRejectReason.DuplicateQuote
        |"7"B -> QuoteEntryRejectReason.InvalidBidAskSpread
        |"8"B -> QuoteEntryRejectReason.InvalidPrice
        |"9"B -> QuoteEntryRejectReason.NotAuthorizedToQuoteSecurity
        | x -> failwith (sprintf "ReadQuoteEntryRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteEntryRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteEntryRejectReason) : int =
    match xxIn with
    | QuoteEntryRejectReason.UnknownSymbol ->
        let tag = "368=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.ExchangeClosed ->
        let tag = "368=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.QuoteExceedsLimit ->
        let tag = "368=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.TooLateToEnter ->
        let tag = "368=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.UnknownQuote ->
        let tag = "368=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.DuplicateQuote ->
        let tag = "368=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.InvalidBidAskSpread ->
        let tag = "368=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.InvalidPrice ->
        let tag = "368=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.NotAuthorizedToQuoteSecurity ->
        let tag = "368=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastMsgSeqNumProcessed (pos:int) (bs:byte[]) : (int*LastMsgSeqNumProcessed) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LastMsgSeqNumProcessed.LastMsgSeqNumProcessed


let WriteLastMsgSeqNumProcessed (dest:byte []) (nextFreeIdx:int) (valIn:LastMsgSeqNumProcessed) : int = 
   let tag = "369="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRefTagID (pos:int) (bs:byte[]) : (int*RefTagID) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) RefTagID.RefTagID


let WriteRefTagID (dest:byte []) (nextFreeIdx:int) (valIn:RefTagID) : int = 
   let tag = "371="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRefMsgType (pos:int) (bs:byte[]) : (int*RefMsgType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RefMsgType.RefMsgType


let WriteRefMsgType (dest:byte []) (nextFreeIdx:int) (valIn:RefMsgType) : int = 
   let tag = "372="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSessionRejectReason (pos:int) (bs:byte[]) : (int * SessionRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SessionRejectReason.InvalidTagNumber
        |"1"B -> SessionRejectReason.RequiredTagMissing
        |"2"B -> SessionRejectReason.TagNotDefinedForThisMessageType
        |"3"B -> SessionRejectReason.UndefinedTag
        |"4"B -> SessionRejectReason.TagSpecifiedWithoutAValue
        |"5"B -> SessionRejectReason.ValueIsIncorrect
        |"6"B -> SessionRejectReason.IncorrectDataFormatForValue
        |"7"B -> SessionRejectReason.DecryptionProblem
        |"8"B -> SessionRejectReason.SignatureProblem
        |"9"B -> SessionRejectReason.CompidProblem
        |"10"B -> SessionRejectReason.SendingtimeAccuracyProblem
        |"11"B -> SessionRejectReason.InvalidMsgtype
        |"12"B -> SessionRejectReason.XmlValidationError
        |"13"B -> SessionRejectReason.TagAppearsMoreThanOnce
        |"14"B -> SessionRejectReason.TagSpecifiedOutOfRequiredOrder
        |"15"B -> SessionRejectReason.RepeatingGroupFieldsOutOfOrder
        |"16"B -> SessionRejectReason.IncorrectNumingroupCountForRepeatingGroup
        |"17"B -> SessionRejectReason.NonDataValueIncludesFieldDelimiter
        |"99"B -> SessionRejectReason.Other
        | x -> failwith (sprintf "ReadSessionRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSessionRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:SessionRejectReason) : int =
    match xxIn with
    | SessionRejectReason.InvalidTagNumber ->
        let tag = "373=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.RequiredTagMissing ->
        let tag = "373=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagNotDefinedForThisMessageType ->
        let tag = "373=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.UndefinedTag ->
        let tag = "373=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagSpecifiedWithoutAValue ->
        let tag = "373=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.ValueIsIncorrect ->
        let tag = "373=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.IncorrectDataFormatForValue ->
        let tag = "373=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.DecryptionProblem ->
        let tag = "373=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.SignatureProblem ->
        let tag = "373=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.CompidProblem ->
        let tag = "373=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.SendingtimeAccuracyProblem ->
        let tag = "373=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.InvalidMsgtype ->
        let tag = "373=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.XmlValidationError ->
        let tag = "373=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagAppearsMoreThanOnce ->
        let tag = "373=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagSpecifiedOutOfRequiredOrder ->
        let tag = "373=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.RepeatingGroupFieldsOutOfOrder ->
        let tag = "373=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.IncorrectNumingroupCountForRepeatingGroup ->
        let tag = "373=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.NonDataValueIncludesFieldDelimiter ->
        let tag = "373=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.Other ->
        let tag = "373=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidRequestTransType (pos:int) (bs:byte[]) : (int * BidRequestTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"N"B -> BidRequestTransType.New
        |"C"B -> BidRequestTransType.Cancel
        | x -> failwith (sprintf "ReadBidRequestTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBidRequestTransType (dest:byte array) (nextFreeIdx:int) (xxIn:BidRequestTransType) : int =
    match xxIn with
    | BidRequestTransType.New ->
        let tag = "374=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidRequestTransType.Cancel ->
        let tag = "374=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContraBroker (pos:int) (bs:byte[]) : (int*ContraBroker) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContraBroker.ContraBroker


let WriteContraBroker (dest:byte []) (nextFreeIdx:int) (valIn:ContraBroker) : int = 
   let tag = "375="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadComplianceID (pos:int) (bs:byte[]) : (int*ComplianceID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ComplianceID.ComplianceID


let WriteComplianceID (dest:byte []) (nextFreeIdx:int) (valIn:ComplianceID) : int = 
   let tag = "376="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSolicitedFlag (pos:int) (bs:byte[]) : (int*SolicitedFlag) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) SolicitedFlag.SolicitedFlag


let WriteSolicitedFlag (dest:byte []) (nextFreeIdx:int) (valIn:SolicitedFlag) : int = 
   let tag = "377="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExecRestatementReason (pos:int) (bs:byte[]) : (int * ExecRestatementReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ExecRestatementReason.GtCorporateAction
        |"1"B -> ExecRestatementReason.GtRenewalRestatement
        |"2"B -> ExecRestatementReason.VerbalChange
        |"3"B -> ExecRestatementReason.RepricingOfOrder
        |"4"B -> ExecRestatementReason.BrokerOption
        |"5"B -> ExecRestatementReason.PartialDeclineOfOrderqty
        |"6"B -> ExecRestatementReason.CancelOnTradingHalt
        |"7"B -> ExecRestatementReason.CancelOnSystemFailure
        |"8"B -> ExecRestatementReason.MarketOption
        |"9"B -> ExecRestatementReason.CanceledNotBest
        | x -> failwith (sprintf "ReadExecRestatementReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExecRestatementReason (dest:byte array) (nextFreeIdx:int) (xxIn:ExecRestatementReason) : int =
    match xxIn with
    | ExecRestatementReason.GtCorporateAction ->
        let tag = "378=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.GtRenewalRestatement ->
        let tag = "378=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.VerbalChange ->
        let tag = "378=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.RepricingOfOrder ->
        let tag = "378=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.BrokerOption ->
        let tag = "378=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.PartialDeclineOfOrderqty ->
        let tag = "378=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CancelOnTradingHalt ->
        let tag = "378=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CancelOnSystemFailure ->
        let tag = "378=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.MarketOption ->
        let tag = "378=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CanceledNotBest ->
        let tag = "378=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBusinessRejectRefID (pos:int) (bs:byte[]) : (int*BusinessRejectRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BusinessRejectRefID.BusinessRejectRefID


let WriteBusinessRejectRefID (dest:byte []) (nextFreeIdx:int) (valIn:BusinessRejectRefID) : int = 
   let tag = "379="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBusinessRejectReason (pos:int) (bs:byte[]) : (int * BusinessRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> BusinessRejectReason.Other
        |"1"B -> BusinessRejectReason.UnkownId
        |"2"B -> BusinessRejectReason.UnknownSecurity
        |"3"B -> BusinessRejectReason.UnsupportedMessageType
        |"4"B -> BusinessRejectReason.ApplicationNotAvailable
        |"5"B -> BusinessRejectReason.ConditionallyRequiredFieldMissing
        |"6"B -> BusinessRejectReason.NotAuthorized
        |"7"B -> BusinessRejectReason.DelivertoFirmNotAvailableAtThisTime
        | x -> failwith (sprintf "ReadBusinessRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBusinessRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:BusinessRejectReason) : int =
    match xxIn with
    | BusinessRejectReason.Other ->
        let tag = "380=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnkownId ->
        let tag = "380=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnknownSecurity ->
        let tag = "380=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnsupportedMessageType ->
        let tag = "380=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.ApplicationNotAvailable ->
        let tag = "380=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.ConditionallyRequiredFieldMissing ->
        let tag = "380=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.NotAuthorized ->
        let tag = "380=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.DelivertoFirmNotAvailableAtThisTime ->
        let tag = "380=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadGrossTradeAmt (pos:int) (bs:byte[]) : (int*GrossTradeAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) GrossTradeAmt.GrossTradeAmt


let WriteGrossTradeAmt (dest:byte []) (nextFreeIdx:int) (valIn:GrossTradeAmt) : int = 
   let tag = "381="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoContraBrokers (pos:int) (bs:byte[]) : (int*NoContraBrokers) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoContraBrokers.NoContraBrokers


let WriteNoContraBrokers (dest:byte []) (nextFreeIdx:int) (valIn:NoContraBrokers) : int = 
   let tag = "382="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMaxMessageSize (pos:int) (bs:byte[]) : (int*MaxMessageSize) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MaxMessageSize.MaxMessageSize


let WriteMaxMessageSize (dest:byte []) (nextFreeIdx:int) (valIn:MaxMessageSize) : int = 
   let tag = "383="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoMsgTypes (pos:int) (bs:byte[]) : (int*NoMsgTypes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoMsgTypes.NoMsgTypes


let WriteNoMsgTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoMsgTypes) : int = 
   let tag = "384="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMsgDirection (pos:int) (bs:byte[]) : (int * MsgDirection) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"S"B -> MsgDirection.Send
        |"R"B -> MsgDirection.Receive
        | x -> failwith (sprintf "ReadMsgDirection unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMsgDirection (dest:byte array) (nextFreeIdx:int) (xxIn:MsgDirection) : int =
    match xxIn with
    | MsgDirection.Send ->
        let tag = "385=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgDirection.Receive ->
        let tag = "385=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoTradingSessions (pos:int) (bs:byte[]) : (int*NoTradingSessions) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoTradingSessions.NoTradingSessions


let WriteNoTradingSessions (dest:byte []) (nextFreeIdx:int) (valIn:NoTradingSessions) : int = 
   let tag = "386="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotalVolumeTraded (pos:int) (bs:byte[]) : (int*TotalVolumeTraded) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) TotalVolumeTraded.TotalVolumeTraded


let WriteTotalVolumeTraded (dest:byte []) (nextFreeIdx:int) (valIn:TotalVolumeTraded) : int = 
   let tag = "387="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDiscretionInst (pos:int) (bs:byte[]) : (int * DiscretionInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DiscretionInst.RelatedToDisplayedPrice
        |"1"B -> DiscretionInst.RelatedToMarketPrice
        |"2"B -> DiscretionInst.RelatedToPrimaryPrice
        |"3"B -> DiscretionInst.RelatedToLocalPrimaryPrice
        |"4"B -> DiscretionInst.RelatedToMidpointPrice
        |"5"B -> DiscretionInst.RelatedToLastTradePrice
        |"6"B -> DiscretionInst.RelatedToVwap
        | x -> failwith (sprintf "ReadDiscretionInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionInst (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionInst) : int =
    match xxIn with
    | DiscretionInst.RelatedToDisplayedPrice ->
        let tag = "388=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToMarketPrice ->
        let tag = "388=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToPrimaryPrice ->
        let tag = "388=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToLocalPrimaryPrice ->
        let tag = "388=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToMidpointPrice ->
        let tag = "388=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToLastTradePrice ->
        let tag = "388=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToVwap ->
        let tag = "388=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionOffsetValue (pos:int) (bs:byte[]) : (int*DiscretionOffsetValue) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DiscretionOffsetValue.DiscretionOffsetValue


let WriteDiscretionOffsetValue (dest:byte []) (nextFreeIdx:int) (valIn:DiscretionOffsetValue) : int = 
   let tag = "389="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidID (pos:int) (bs:byte[]) : (int*BidID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BidID.BidID


let WriteBidID (dest:byte []) (nextFreeIdx:int) (valIn:BidID) : int = 
   let tag = "390="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadClientBidID (pos:int) (bs:byte[]) : (int*ClientBidID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ClientBidID.ClientBidID


let WriteClientBidID (dest:byte []) (nextFreeIdx:int) (valIn:ClientBidID) : int = 
   let tag = "391="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListName (pos:int) (bs:byte[]) : (int*ListName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ListName.ListName


let WriteListName (dest:byte []) (nextFreeIdx:int) (valIn:ListName) : int = 
   let tag = "392="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotNoRelatedSym (pos:int) (bs:byte[]) : (int*TotNoRelatedSym) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoRelatedSym.TotNoRelatedSym


let WriteTotNoRelatedSym (dest:byte []) (nextFreeIdx:int) (valIn:TotNoRelatedSym) : int = 
   let tag = "393="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidType (pos:int) (bs:byte[]) : (int * BidType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> BidType.NonDisclosed
        |"2"B -> BidType.DisclosedStyle
        |"3"B -> BidType.NoBiddingProcess
        | x -> failwith (sprintf "ReadBidType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBidType (dest:byte array) (nextFreeIdx:int) (xxIn:BidType) : int =
    match xxIn with
    | BidType.NonDisclosed ->
        let tag = "394=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidType.DisclosedStyle ->
        let tag = "394=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidType.NoBiddingProcess ->
        let tag = "394=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumTickets (pos:int) (bs:byte[]) : (int*NumTickets) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NumTickets.NumTickets


let WriteNumTickets (dest:byte []) (nextFreeIdx:int) (valIn:NumTickets) : int = 
   let tag = "395="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSideValue1 (pos:int) (bs:byte[]) : (int*SideValue1) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SideValue1.SideValue1


let WriteSideValue1 (dest:byte []) (nextFreeIdx:int) (valIn:SideValue1) : int = 
   let tag = "396="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSideValue2 (pos:int) (bs:byte[]) : (int*SideValue2) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SideValue2.SideValue2


let WriteSideValue2 (dest:byte []) (nextFreeIdx:int) (valIn:SideValue2) : int = 
   let tag = "397="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoBidDescriptors (pos:int) (bs:byte[]) : (int*NoBidDescriptors) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoBidDescriptors.NoBidDescriptors


let WriteNoBidDescriptors (dest:byte []) (nextFreeIdx:int) (valIn:NoBidDescriptors) : int = 
   let tag = "398="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidDescriptorType (pos:int) (bs:byte[]) : (int * BidDescriptorType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> BidDescriptorType.Sector
        |"2"B -> BidDescriptorType.Country
        |"3"B -> BidDescriptorType.Index
        | x -> failwith (sprintf "ReadBidDescriptorType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBidDescriptorType (dest:byte array) (nextFreeIdx:int) (xxIn:BidDescriptorType) : int =
    match xxIn with
    | BidDescriptorType.Sector ->
        let tag = "399=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidDescriptorType.Country ->
        let tag = "399=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidDescriptorType.Index ->
        let tag = "399=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidDescriptor (pos:int) (bs:byte[]) : (int*BidDescriptor) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BidDescriptor.BidDescriptor


let WriteBidDescriptor (dest:byte []) (nextFreeIdx:int) (valIn:BidDescriptor) : int = 
   let tag = "400="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSideValueInd (pos:int) (bs:byte[]) : (int * SideValueInd) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SideValueInd.Sidevalue1
        |"2"B -> SideValueInd.Sidevalue2
        | x -> failwith (sprintf "ReadSideValueInd unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSideValueInd (dest:byte array) (nextFreeIdx:int) (xxIn:SideValueInd) : int =
    match xxIn with
    | SideValueInd.Sidevalue1 ->
        let tag = "401=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideValueInd.Sidevalue2 ->
        let tag = "401=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLiquidityPctLow (pos:int) (bs:byte[]) : (int*LiquidityPctLow) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LiquidityPctLow.LiquidityPctLow


let WriteLiquidityPctLow (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityPctLow) : int = 
   let tag = "402="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLiquidityPctHigh (pos:int) (bs:byte[]) : (int*LiquidityPctHigh) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LiquidityPctHigh.LiquidityPctHigh


let WriteLiquidityPctHigh (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityPctHigh) : int = 
   let tag = "403="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLiquidityValue (pos:int) (bs:byte[]) : (int*LiquidityValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LiquidityValue.LiquidityValue


let WriteLiquidityValue (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityValue) : int = 
   let tag = "404="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEFPTrackingError (pos:int) (bs:byte[]) : (int*EFPTrackingError) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) EFPTrackingError.EFPTrackingError


let WriteEFPTrackingError (dest:byte []) (nextFreeIdx:int) (valIn:EFPTrackingError) : int = 
   let tag = "405="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadFairValue (pos:int) (bs:byte[]) : (int*FairValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) FairValue.FairValue


let WriteFairValue (dest:byte []) (nextFreeIdx:int) (valIn:FairValue) : int = 
   let tag = "406="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOutsideIndexPct (pos:int) (bs:byte[]) : (int*OutsideIndexPct) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OutsideIndexPct.OutsideIndexPct


let WriteOutsideIndexPct (dest:byte []) (nextFreeIdx:int) (valIn:OutsideIndexPct) : int = 
   let tag = "407="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadValueOfFutures (pos:int) (bs:byte[]) : (int*ValueOfFutures) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) ValueOfFutures.ValueOfFutures


let WriteValueOfFutures (dest:byte []) (nextFreeIdx:int) (valIn:ValueOfFutures) : int = 
   let tag = "408="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLiquidityIndType (pos:int) (bs:byte[]) : (int * LiquidityIndType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> LiquidityIndType.FivedayMovingAverage
        |"2"B -> LiquidityIndType.TwentydayMovingAverage
        |"3"B -> LiquidityIndType.NormalMarketSize
        |"4"B -> LiquidityIndType.Other
        | x -> failwith (sprintf "ReadLiquidityIndType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteLiquidityIndType (dest:byte array) (nextFreeIdx:int) (xxIn:LiquidityIndType) : int =
    match xxIn with
    | LiquidityIndType.FivedayMovingAverage ->
        let tag = "409=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.TwentydayMovingAverage ->
        let tag = "409=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.NormalMarketSize ->
        let tag = "409=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.Other ->
        let tag = "409=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWtAverageLiquidity (pos:int) (bs:byte[]) : (int*WtAverageLiquidity) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) WtAverageLiquidity.WtAverageLiquidity


let WriteWtAverageLiquidity (dest:byte []) (nextFreeIdx:int) (valIn:WtAverageLiquidity) : int = 
   let tag = "410="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExchangeForPhysical (pos:int) (bs:byte[]) : (int*ExchangeForPhysical) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ExchangeForPhysical.ExchangeForPhysical


let WriteExchangeForPhysical (dest:byte []) (nextFreeIdx:int) (valIn:ExchangeForPhysical) : int = 
   let tag = "411="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOutMainCntryUIndex (pos:int) (bs:byte[]) : (int*OutMainCntryUIndex) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) OutMainCntryUIndex.OutMainCntryUIndex


let WriteOutMainCntryUIndex (dest:byte []) (nextFreeIdx:int) (valIn:OutMainCntryUIndex) : int = 
   let tag = "412="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCrossPercent (pos:int) (bs:byte[]) : (int*CrossPercent) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) CrossPercent.CrossPercent


let WriteCrossPercent (dest:byte []) (nextFreeIdx:int) (valIn:CrossPercent) : int = 
   let tag = "413="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadProgRptReqs (pos:int) (bs:byte[]) : (int * ProgRptReqs) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ProgRptReqs.BuysideExplicitlyRequestsStatusUsingStatusrequest
        |"2"B -> ProgRptReqs.SellsidePeriodicallySendsStatusUsingListstatus
        |"3"B -> ProgRptReqs.RealTimeExecutionReports
        | x -> failwith (sprintf "ReadProgRptReqs unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteProgRptReqs (dest:byte array) (nextFreeIdx:int) (xxIn:ProgRptReqs) : int =
    match xxIn with
    | ProgRptReqs.BuysideExplicitlyRequestsStatusUsingStatusrequest ->
        let tag = "414=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProgRptReqs.SellsidePeriodicallySendsStatusUsingListstatus ->
        let tag = "414=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProgRptReqs.RealTimeExecutionReports ->
        let tag = "414=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadProgPeriodInterval (pos:int) (bs:byte[]) : (int*ProgPeriodInterval) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) ProgPeriodInterval.ProgPeriodInterval


let WriteProgPeriodInterval (dest:byte []) (nextFreeIdx:int) (valIn:ProgPeriodInterval) : int = 
   let tag = "415="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIncTaxInd (pos:int) (bs:byte[]) : (int * IncTaxInd) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> IncTaxInd.Net
        |"2"B -> IncTaxInd.Gross
        | x -> failwith (sprintf "ReadIncTaxInd unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteIncTaxInd (dest:byte array) (nextFreeIdx:int) (xxIn:IncTaxInd) : int =
    match xxIn with
    | IncTaxInd.Net ->
        let tag = "416=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IncTaxInd.Gross ->
        let tag = "416=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumBidders (pos:int) (bs:byte[]) : (int*NumBidders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NumBidders.NumBidders


let WriteNumBidders (dest:byte []) (nextFreeIdx:int) (valIn:NumBidders) : int = 
   let tag = "417="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidTradeType (pos:int) (bs:byte[]) : (int * BidTradeType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"R"B -> BidTradeType.RiskTrade
        |"G"B -> BidTradeType.VwapGuarantee
        |"A"B -> BidTradeType.Agency
        |"J"B -> BidTradeType.GuaranteedClose
        | x -> failwith (sprintf "ReadBidTradeType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBidTradeType (dest:byte array) (nextFreeIdx:int) (xxIn:BidTradeType) : int =
    match xxIn with
    | BidTradeType.RiskTrade ->
        let tag = "418=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.VwapGuarantee ->
        let tag = "418=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.Agency ->
        let tag = "418=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.GuaranteedClose ->
        let tag = "418=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBasisPxType (pos:int) (bs:byte[]) : (int * BasisPxType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"2"B -> BasisPxType.ClosingPriceAtMorningSession
        |"3"B -> BasisPxType.ClosingPrice
        |"4"B -> BasisPxType.CurrentPrice
        |"5"B -> BasisPxType.Sq
        |"6"B -> BasisPxType.VwapThroughADay
        |"7"B -> BasisPxType.VwapThroughAMorningSession
        |"8"B -> BasisPxType.VwapThroughAnAfternoonSession
        |"9"B -> BasisPxType.VwapThroughADayExceptYori
        |"A"B -> BasisPxType.VwapThroughAMorningSessionExceptYori
        |"B"B -> BasisPxType.VwapThroughAnAfternoonSessionExceptYori
        |"C"B -> BasisPxType.Strike
        |"D"B -> BasisPxType.Open
        |"Z"B -> BasisPxType.Others
        | x -> failwith (sprintf "ReadBasisPxType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBasisPxType (dest:byte array) (nextFreeIdx:int) (xxIn:BasisPxType) : int =
    match xxIn with
    | BasisPxType.ClosingPriceAtMorningSession ->
        let tag = "419=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.ClosingPrice ->
        let tag = "419=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.CurrentPrice ->
        let tag = "419=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Sq ->
        let tag = "419=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughADay ->
        let tag = "419=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAMorningSession ->
        let tag = "419=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAnAfternoonSession ->
        let tag = "419=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughADayExceptYori ->
        let tag = "419=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAMorningSessionExceptYori ->
        let tag = "419=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAnAfternoonSessionExceptYori ->
        let tag = "419=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Strike ->
        let tag = "419=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Open ->
        let tag = "419=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Others ->
        let tag = "419=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoBidComponents (pos:int) (bs:byte[]) : (int*NoBidComponents) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoBidComponents.NoBidComponents


let WriteNoBidComponents (dest:byte []) (nextFreeIdx:int) (valIn:NoBidComponents) : int = 
   let tag = "420="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCountry (pos:int) (bs:byte[]) : (int*Country) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Country.Country


let WriteCountry (dest:byte []) (nextFreeIdx:int) (valIn:Country) : int = 
   let tag = "421="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotNoStrikes (pos:int) (bs:byte[]) : (int*TotNoStrikes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoStrikes.TotNoStrikes


let WriteTotNoStrikes (dest:byte []) (nextFreeIdx:int) (valIn:TotNoStrikes) : int = 
   let tag = "422="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPriceType (pos:int) (bs:byte[]) : (int * PriceType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PriceType.Percentage
        |"2"B -> PriceType.PerUnit
        |"3"B -> PriceType.FixedAmount
        |"4"B -> PriceType.Discount
        |"5"B -> PriceType.Premium
        |"6"B -> PriceType.Spread
        |"7"B -> PriceType.TedPrice
        |"8"B -> PriceType.TedYield
        |"9"B -> PriceType.Yield
        |"10"B -> PriceType.FixedCabinetTradePrice
        |"11"B -> PriceType.VariableCabinetTradePrice
        | x -> failwith (sprintf "ReadPriceType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePriceType (dest:byte array) (nextFreeIdx:int) (xxIn:PriceType) : int =
    match xxIn with
    | PriceType.Percentage ->
        let tag = "423=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.PerUnit ->
        let tag = "423=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.FixedAmount ->
        let tag = "423=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Discount ->
        let tag = "423=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Premium ->
        let tag = "423=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Spread ->
        let tag = "423=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.TedPrice ->
        let tag = "423=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.TedYield ->
        let tag = "423=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Yield ->
        let tag = "423=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.FixedCabinetTradePrice ->
        let tag = "423=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.VariableCabinetTradePrice ->
        let tag = "423=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDayOrderQty (pos:int) (bs:byte[]) : (int*DayOrderQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DayOrderQty.DayOrderQty


let WriteDayOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:DayOrderQty) : int = 
   let tag = "424="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDayCumQty (pos:int) (bs:byte[]) : (int*DayCumQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DayCumQty.DayCumQty


let WriteDayCumQty (dest:byte []) (nextFreeIdx:int) (valIn:DayCumQty) : int = 
   let tag = "425="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDayAvgPx (pos:int) (bs:byte[]) : (int*DayAvgPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DayAvgPx.DayAvgPx


let WriteDayAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:DayAvgPx) : int = 
   let tag = "426="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadGTBookingInst (pos:int) (bs:byte[]) : (int * GTBookingInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> GTBookingInst.BookOutAllTradesOnDayOfExecution
        |"1"B -> GTBookingInst.AccumulateExecutionsUntilOrderIsFilledOrExpires
        |"2"B -> GTBookingInst.AccumulateUntilVerballyNotifiedOtherwise
        | x -> failwith (sprintf "ReadGTBookingInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteGTBookingInst (dest:byte array) (nextFreeIdx:int) (xxIn:GTBookingInst) : int =
    match xxIn with
    | GTBookingInst.BookOutAllTradesOnDayOfExecution ->
        let tag = "427=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | GTBookingInst.AccumulateExecutionsUntilOrderIsFilledOrExpires ->
        let tag = "427=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | GTBookingInst.AccumulateUntilVerballyNotifiedOtherwise ->
        let tag = "427=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoStrikes (pos:int) (bs:byte[]) : (int*NoStrikes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoStrikes.NoStrikes


let WriteNoStrikes (dest:byte []) (nextFreeIdx:int) (valIn:NoStrikes) : int = 
   let tag = "428="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListStatusType (pos:int) (bs:byte[]) : (int * ListStatusType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ListStatusType.Ack
        |"2"B -> ListStatusType.Response
        |"3"B -> ListStatusType.Timed
        |"4"B -> ListStatusType.Execstarted
        |"5"B -> ListStatusType.Alldone
        |"6"B -> ListStatusType.Alert
        | x -> failwith (sprintf "ReadListStatusType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteListStatusType (dest:byte array) (nextFreeIdx:int) (xxIn:ListStatusType) : int =
    match xxIn with
    | ListStatusType.Ack ->
        let tag = "429=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Response ->
        let tag = "429=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Timed ->
        let tag = "429=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Execstarted ->
        let tag = "429=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Alldone ->
        let tag = "429=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Alert ->
        let tag = "429=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNetGrossInd (pos:int) (bs:byte[]) : (int * NetGrossInd) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> NetGrossInd.Net
        |"2"B -> NetGrossInd.Gross
        | x -> failwith (sprintf "ReadNetGrossInd unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteNetGrossInd (dest:byte array) (nextFreeIdx:int) (xxIn:NetGrossInd) : int =
    match xxIn with
    | NetGrossInd.Net ->
        let tag = "430=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetGrossInd.Gross ->
        let tag = "430=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadListOrderStatus (pos:int) (bs:byte[]) : (int * ListOrderStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ListOrderStatus.Inbiddingprocess
        |"2"B -> ListOrderStatus.Receivedforexecution
        |"3"B -> ListOrderStatus.Executing
        |"4"B -> ListOrderStatus.Canceling
        |"5"B -> ListOrderStatus.Alert
        |"6"B -> ListOrderStatus.AllDone
        |"7"B -> ListOrderStatus.Reject
        | x -> failwith (sprintf "ReadListOrderStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteListOrderStatus (dest:byte array) (nextFreeIdx:int) (xxIn:ListOrderStatus) : int =
    match xxIn with
    | ListOrderStatus.Inbiddingprocess ->
        let tag = "431=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Receivedforexecution ->
        let tag = "431=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Executing ->
        let tag = "431=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Canceling ->
        let tag = "431=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Alert ->
        let tag = "431=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.AllDone ->
        let tag = "431=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Reject ->
        let tag = "431=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExpireDate (pos:int) (bs:byte[]) : (int*ExpireDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExpireDate.ExpireDate


let WriteExpireDate (dest:byte []) (nextFreeIdx:int) (valIn:ExpireDate) : int = 
   let tag = "432="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListExecInstType (pos:int) (bs:byte[]) : (int * ListExecInstType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ListExecInstType.Immediate
        |"2"B -> ListExecInstType.WaitForExecuteInstruction
        |"3"B -> ListExecInstType.ExchangeSwitchCivOrderSellDriven
        |"4"B -> ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashTopUp
        |"5"B -> ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashWithdraw
        | x -> failwith (sprintf "ReadListExecInstType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteListExecInstType (dest:byte array) (nextFreeIdx:int) (xxIn:ListExecInstType) : int =
    match xxIn with
    | ListExecInstType.Immediate ->
        let tag = "433=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.WaitForExecuteInstruction ->
        let tag = "433=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderSellDriven ->
        let tag = "433=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashTopUp ->
        let tag = "433=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashWithdraw ->
        let tag = "433=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCxlRejResponseTo (pos:int) (bs:byte[]) : (int * CxlRejResponseTo) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> CxlRejResponseTo.OrderCancelRequest
        |"2"B -> CxlRejResponseTo.OrderCancelReplaceRequest
        | x -> failwith (sprintf "ReadCxlRejResponseTo unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCxlRejResponseTo (dest:byte array) (nextFreeIdx:int) (xxIn:CxlRejResponseTo) : int =
    match xxIn with
    | CxlRejResponseTo.OrderCancelRequest ->
        let tag = "434=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejResponseTo.OrderCancelReplaceRequest ->
        let tag = "434=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingCouponRate (pos:int) (bs:byte[]) : (int*UnderlyingCouponRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingCouponRate.UnderlyingCouponRate


let WriteUnderlyingCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCouponRate) : int = 
   let tag = "435="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingContractMultiplier (pos:int) (bs:byte[]) : (int*UnderlyingContractMultiplier) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingContractMultiplier.UnderlyingContractMultiplier


let WriteUnderlyingContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingContractMultiplier) : int = 
   let tag = "436="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContraTradeQty (pos:int) (bs:byte[]) : (int*ContraTradeQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ContraTradeQty.ContraTradeQty


let WriteContraTradeQty (dest:byte []) (nextFreeIdx:int) (valIn:ContraTradeQty) : int = 
   let tag = "437="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContraTradeTime (pos:int) (bs:byte[]) : (int*ContraTradeTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContraTradeTime.ContraTradeTime


let WriteContraTradeTime (dest:byte []) (nextFreeIdx:int) (valIn:ContraTradeTime) : int = 
   let tag = "438="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLiquidityNumSecurities (pos:int) (bs:byte[]) : (int*LiquidityNumSecurities) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LiquidityNumSecurities.LiquidityNumSecurities


let WriteLiquidityNumSecurities (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityNumSecurities) : int = 
   let tag = "441="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMultiLegReportingType (pos:int) (bs:byte[]) : (int * MultiLegReportingType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> MultiLegReportingType.SingleSecurity
        |"2"B -> MultiLegReportingType.IndividualLegOfAMultiLegSecurity
        |"3"B -> MultiLegReportingType.MultiLegSecurity
        | x -> failwith (sprintf "ReadMultiLegReportingType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMultiLegReportingType (dest:byte array) (nextFreeIdx:int) (xxIn:MultiLegReportingType) : int =
    match xxIn with
    | MultiLegReportingType.SingleSecurity ->
        let tag = "442=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegReportingType.IndividualLegOfAMultiLegSecurity ->
        let tag = "442=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegReportingType.MultiLegSecurity ->
        let tag = "442=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikeTime (pos:int) (bs:byte[]) : (int*StrikeTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StrikeTime.StrikeTime


let WriteStrikeTime (dest:byte []) (nextFreeIdx:int) (valIn:StrikeTime) : int = 
   let tag = "443="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadListStatusText (pos:int) (bs:byte[]) : (int*ListStatusText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ListStatusText.ListStatusText


let WriteListStatusText (dest:byte []) (nextFreeIdx:int) (valIn:ListStatusText) : int = 
   let tag = "444="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedListStatusText (dest:byte []) (nextFreeIdx:int) (fld:EncodedListStatusText) : int =
    // write the string length part of the compound msg
    let lenTag = "445="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedListStatusText (pos:int) (bs:byte[]) : (int * EncodedListStatusText) =
    ReadLengthStringCompoundField "446"B (pos:int) (bs:byte[]) EncodedListStatusText.EncodedListStatusText


let ReadPartyIDSource (pos:int) (bs:byte[]) : (int * PartyIDSource) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"B"B -> PartyIDSource.Bic
        |"C"B -> PartyIDSource.GenerallyAcceptedMarketParticipantIdentifier
        |"D"B -> PartyIDSource.ProprietaryCustomCode
        |"E"B -> PartyIDSource.IsoCountryCode
        |"F"B -> PartyIDSource.SettlementEntityLocation
        |"G"B -> PartyIDSource.Mic
        |"H"B -> PartyIDSource.CsdParticipantMemberCode
        |"1"B -> PartyIDSource.KoreanInvestorId
        |"2"B -> PartyIDSource.TaiwaneseQualifiedForeignInvestorIdQfiiFid
        |"3"B -> PartyIDSource.TaiwaneseTradingAccount
        |"4"B -> PartyIDSource.MalaysianCentralDepositoryNumber
        |"5"B -> PartyIDSource.ChineseBShare
        |"6"B -> PartyIDSource.UkNationalInsuranceOrPensionNumber
        |"7"B -> PartyIDSource.UsSocialSecurityNumber
        |"8"B -> PartyIDSource.UsEmployerIdentificationNumber
        |"9"B -> PartyIDSource.AustralianBusinessNumber
        |"A"B -> PartyIDSource.AustralianTaxFileNumber
        |"I"B -> PartyIDSource.DirectedBroker
        | x -> failwith (sprintf "ReadPartyIDSource unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePartyIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:PartyIDSource) : int =
    match xxIn with
    | PartyIDSource.Bic ->
        let tag = "447=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.GenerallyAcceptedMarketParticipantIdentifier ->
        let tag = "447=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.ProprietaryCustomCode ->
        let tag = "447=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.IsoCountryCode ->
        let tag = "447=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.SettlementEntityLocation ->
        let tag = "447=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.Mic ->
        let tag = "447=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.CsdParticipantMemberCode ->
        let tag = "447=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.KoreanInvestorId ->
        let tag = "447=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.TaiwaneseQualifiedForeignInvestorIdQfiiFid ->
        let tag = "447=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.TaiwaneseTradingAccount ->
        let tag = "447=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.MalaysianCentralDepositoryNumber ->
        let tag = "447=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.ChineseBShare ->
        let tag = "447=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UkNationalInsuranceOrPensionNumber ->
        let tag = "447=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UsSocialSecurityNumber ->
        let tag = "447=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UsEmployerIdentificationNumber ->
        let tag = "447=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.AustralianBusinessNumber ->
        let tag = "447=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.AustralianTaxFileNumber ->
        let tag = "447=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.DirectedBroker ->
        let tag = "447=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPartyID (pos:int) (bs:byte[]) : (int*PartyID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PartyID.PartyID


let WritePartyID (dest:byte []) (nextFreeIdx:int) (valIn:PartyID) : int = 
   let tag = "448="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetChgPrevDay (pos:int) (bs:byte[]) : (int*NetChgPrevDay) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) NetChgPrevDay.NetChgPrevDay


let WriteNetChgPrevDay (dest:byte []) (nextFreeIdx:int) (valIn:NetChgPrevDay) : int = 
   let tag = "451="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPartyRole (pos:int) (bs:byte[]) : (int * PartyRole) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PartyRole.ExecutingFirm
        |"2"B -> PartyRole.BrokerOfCredit
        |"3"B -> PartyRole.ClientId
        |"4"B -> PartyRole.ClearingFirm
        |"5"B -> PartyRole.InvestorId
        |"6"B -> PartyRole.IntroducingFirm
        |"7"B -> PartyRole.EnteringFirm
        |"8"B -> PartyRole.LocateLendingFirm
        |"9"B -> PartyRole.FundManagerClientId
        |"10"B -> PartyRole.SettlementLocation
        |"11"B -> PartyRole.OrderOriginationTrader
        |"12"B -> PartyRole.ExecutingTrader
        |"13"B -> PartyRole.OrderOriginationFirm
        |"14"B -> PartyRole.GiveupClearingFirm
        |"15"B -> PartyRole.CorrespondantClearingFirm
        |"16"B -> PartyRole.ExecutingSystem
        |"17"B -> PartyRole.ContraFirm
        |"18"B -> PartyRole.ContraClearingFirm
        |"19"B -> PartyRole.SponsoringFirm
        |"20"B -> PartyRole.UnderlyingContraFirm
        |"21"B -> PartyRole.ClearingOrganization
        |"22"B -> PartyRole.Exchange
        |"24"B -> PartyRole.CustomerAccount
        |"25"B -> PartyRole.CorrespondentClearingOrganization
        |"26"B -> PartyRole.CorrespondentBroker
        |"27"B -> PartyRole.BuyerSeller
        |"28"B -> PartyRole.Custodian
        |"29"B -> PartyRole.Intermediary
        |"30"B -> PartyRole.Agent
        |"31"B -> PartyRole.SubCustodian
        |"32"B -> PartyRole.Beneficiary
        |"33"B -> PartyRole.InterestedParty
        |"34"B -> PartyRole.RegulatoryBody
        |"35"B -> PartyRole.LiquidityProvider
        |"36"B -> PartyRole.EnteringTrader
        |"37"B -> PartyRole.ContraTrader
        |"38"B -> PartyRole.PositionAccount
        | x -> failwith (sprintf "ReadPartyRole unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePartyRole (dest:byte array) (nextFreeIdx:int) (xxIn:PartyRole) : int =
    match xxIn with
    | PartyRole.ExecutingFirm ->
        let tag = "452=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.BrokerOfCredit ->
        let tag = "452=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClientId ->
        let tag = "452=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClearingFirm ->
        let tag = "452=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.InvestorId ->
        let tag = "452=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.IntroducingFirm ->
        let tag = "452=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.EnteringFirm ->
        let tag = "452=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.LocateLendingFirm ->
        let tag = "452=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.FundManagerClientId ->
        let tag = "452=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SettlementLocation ->
        let tag = "452=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.OrderOriginationTrader ->
        let tag = "452=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ExecutingTrader ->
        let tag = "452=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.OrderOriginationFirm ->
        let tag = "452=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.GiveupClearingFirm ->
        let tag = "452=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondantClearingFirm ->
        let tag = "452=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ExecutingSystem ->
        let tag = "452=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraFirm ->
        let tag = "452=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraClearingFirm ->
        let tag = "452=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SponsoringFirm ->
        let tag = "452=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.UnderlyingContraFirm ->
        let tag = "452=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClearingOrganization ->
        let tag = "452=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Exchange ->
        let tag = "452=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CustomerAccount ->
        let tag = "452=24"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondentClearingOrganization ->
        let tag = "452=25"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondentBroker ->
        let tag = "452=26"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.BuyerSeller ->
        let tag = "452=27"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Custodian ->
        let tag = "452=28"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Intermediary ->
        let tag = "452=29"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Agent ->
        let tag = "452=30"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SubCustodian ->
        let tag = "452=31"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Beneficiary ->
        let tag = "452=32"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.InterestedParty ->
        let tag = "452=33"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.RegulatoryBody ->
        let tag = "452=34"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.LiquidityProvider ->
        let tag = "452=35"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.EnteringTrader ->
        let tag = "452=36"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraTrader ->
        let tag = "452=37"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.PositionAccount ->
        let tag = "452=38"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoPartyIDs (pos:int) (bs:byte[]) : (int*NoPartyIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoPartyIDs.NoPartyIDs


let WriteNoPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoPartyIDs) : int = 
   let tag = "453="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoSecurityAltID (pos:int) (bs:byte[]) : (int*NoSecurityAltID) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoSecurityAltID.NoSecurityAltID


let WriteNoSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoSecurityAltID) : int = 
   let tag = "454="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityAltID (pos:int) (bs:byte[]) : (int*SecurityAltID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityAltID.SecurityAltID


let WriteSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityAltID) : int = 
   let tag = "455="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityAltIDSource (pos:int) (bs:byte[]) : (int*SecurityAltIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecurityAltIDSource.SecurityAltIDSource


let WriteSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:SecurityAltIDSource) : int = 
   let tag = "456="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoUnderlyingSecurityAltID (pos:int) (bs:byte[]) : (int*NoUnderlyingSecurityAltID) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoUnderlyingSecurityAltID.NoUnderlyingSecurityAltID


let WriteNoUnderlyingSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyingSecurityAltID) : int = 
   let tag = "457="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityAltID (pos:int) (bs:byte[]) : (int*UnderlyingSecurityAltID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityAltID.UnderlyingSecurityAltID


let WriteUnderlyingSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityAltID) : int = 
   let tag = "458="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityAltIDSource (pos:int) (bs:byte[]) : (int*UnderlyingSecurityAltIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecurityAltIDSource.UnderlyingSecurityAltIDSource


let WriteUnderlyingSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityAltIDSource) : int = 
   let tag = "459="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadProduct (pos:int) (bs:byte[]) : (int * Product) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> Product.Agency
        |"2"B -> Product.Commodity
        |"3"B -> Product.Corporate
        |"4"B -> Product.Currency
        |"5"B -> Product.Equity
        |"6"B -> Product.Government
        |"7"B -> Product.Index
        |"8"B -> Product.Loan
        |"9"B -> Product.Moneymarket
        |"10"B -> Product.Mortgage
        |"11"B -> Product.Municipal
        |"12"B -> Product.Other
        |"13"B -> Product.Financing
        | x -> failwith (sprintf "ReadProduct unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteProduct (dest:byte array) (nextFreeIdx:int) (xxIn:Product) : int =
    match xxIn with
    | Product.Agency ->
        let tag = "460=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Commodity ->
        let tag = "460=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Corporate ->
        let tag = "460=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Currency ->
        let tag = "460=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Equity ->
        let tag = "460=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Government ->
        let tag = "460=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Index ->
        let tag = "460=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Loan ->
        let tag = "460=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Moneymarket ->
        let tag = "460=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Mortgage ->
        let tag = "460=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Municipal ->
        let tag = "460=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Other ->
        let tag = "460=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Financing ->
        let tag = "460=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCFICode (pos:int) (bs:byte[]) : (int*CFICode) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CFICode.CFICode


let WriteCFICode (dest:byte []) (nextFreeIdx:int) (valIn:CFICode) : int = 
   let tag = "461="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingProduct (pos:int) (bs:byte[]) : (int*UnderlyingProduct) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingProduct.UnderlyingProduct


let WriteUnderlyingProduct (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingProduct) : int = 
   let tag = "462="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCFICode (pos:int) (bs:byte[]) : (int*UnderlyingCFICode) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCFICode.UnderlyingCFICode


let WriteUnderlyingCFICode (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCFICode) : int = 
   let tag = "463="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTestMessageIndicator (pos:int) (bs:byte[]) : (int*TestMessageIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) TestMessageIndicator.TestMessageIndicator


let WriteTestMessageIndicator (dest:byte []) (nextFreeIdx:int) (valIn:TestMessageIndicator) : int = 
   let tag = "464="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuantityType (pos:int) (bs:byte[]) : (int * QuantityType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuantityType.Shares
        |"2"B -> QuantityType.Bonds
        |"3"B -> QuantityType.Currentface
        |"4"B -> QuantityType.Originalface
        |"5"B -> QuantityType.Currency
        |"6"B -> QuantityType.Contracts
        |"7"B -> QuantityType.Other
        |"8"B -> QuantityType.Par
        | x -> failwith (sprintf "ReadQuantityType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuantityType (dest:byte array) (nextFreeIdx:int) (xxIn:QuantityType) : int =
    match xxIn with
    | QuantityType.Shares ->
        let tag = "465=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Bonds ->
        let tag = "465=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Currentface ->
        let tag = "465=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Originalface ->
        let tag = "465=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Currency ->
        let tag = "465=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Contracts ->
        let tag = "465=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Other ->
        let tag = "465=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Par ->
        let tag = "465=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingRefID (pos:int) (bs:byte[]) : (int*BookingRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BookingRefID.BookingRefID


let WriteBookingRefID (dest:byte []) (nextFreeIdx:int) (valIn:BookingRefID) : int = 
   let tag = "466="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadIndividualAllocID (pos:int) (bs:byte[]) : (int*IndividualAllocID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) IndividualAllocID.IndividualAllocID


let WriteIndividualAllocID (dest:byte []) (nextFreeIdx:int) (valIn:IndividualAllocID) : int = 
   let tag = "467="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRoundingDirection (pos:int) (bs:byte[]) : (int * RoundingDirection) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> RoundingDirection.RoundToNearest
        |"1"B -> RoundingDirection.RoundDown
        |"2"B -> RoundingDirection.RoundUp
        | x -> failwith (sprintf "ReadRoundingDirection unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteRoundingDirection (dest:byte array) (nextFreeIdx:int) (xxIn:RoundingDirection) : int =
    match xxIn with
    | RoundingDirection.RoundToNearest ->
        let tag = "468=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoundingDirection.RoundDown ->
        let tag = "468=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoundingDirection.RoundUp ->
        let tag = "468=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoundingModulus (pos:int) (bs:byte[]) : (int*RoundingModulus) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) RoundingModulus.RoundingModulus


let WriteRoundingModulus (dest:byte []) (nextFreeIdx:int) (valIn:RoundingModulus) : int = 
   let tag = "469="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCountryOfIssue (pos:int) (bs:byte[]) : (int*CountryOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CountryOfIssue.CountryOfIssue


let WriteCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:CountryOfIssue) : int = 
   let tag = "470="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStateOrProvinceOfIssue (pos:int) (bs:byte[]) : (int*StateOrProvinceOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StateOrProvinceOfIssue.StateOrProvinceOfIssue


let WriteStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:StateOrProvinceOfIssue) : int = 
   let tag = "471="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLocaleOfIssue (pos:int) (bs:byte[]) : (int*LocaleOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LocaleOfIssue.LocaleOfIssue


let WriteLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LocaleOfIssue) : int = 
   let tag = "472="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoRegistDtls (pos:int) (bs:byte[]) : (int*NoRegistDtls) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoRegistDtls.NoRegistDtls


let WriteNoRegistDtls (dest:byte []) (nextFreeIdx:int) (valIn:NoRegistDtls) : int = 
   let tag = "473="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMailingDtls (pos:int) (bs:byte[]) : (int*MailingDtls) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MailingDtls.MailingDtls


let WriteMailingDtls (dest:byte []) (nextFreeIdx:int) (valIn:MailingDtls) : int = 
   let tag = "474="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadInvestorCountryOfResidence (pos:int) (bs:byte[]) : (int*InvestorCountryOfResidence) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) InvestorCountryOfResidence.InvestorCountryOfResidence


let WriteInvestorCountryOfResidence (dest:byte []) (nextFreeIdx:int) (valIn:InvestorCountryOfResidence) : int = 
   let tag = "475="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPaymentRef (pos:int) (bs:byte[]) : (int*PaymentRef) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PaymentRef.PaymentRef


let WritePaymentRef (dest:byte []) (nextFreeIdx:int) (valIn:PaymentRef) : int = 
   let tag = "476="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDistribPaymentMethod (pos:int) (bs:byte[]) : (int * DistribPaymentMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> DistribPaymentMethod.Crest
        |"2"B -> DistribPaymentMethod.Nscc
        |"3"B -> DistribPaymentMethod.Euroclear
        |"4"B -> DistribPaymentMethod.Clearstream
        |"5"B -> DistribPaymentMethod.Cheque
        |"6"B -> DistribPaymentMethod.TelegraphicTransfer
        |"7"B -> DistribPaymentMethod.Fedwire
        |"8"B -> DistribPaymentMethod.DirectCredit
        |"9"B -> DistribPaymentMethod.AchCredit
        |"10"B -> DistribPaymentMethod.Bpay
        |"11"B -> DistribPaymentMethod.HighValueClearingSystem
        |"12"B -> DistribPaymentMethod.ReinvestInFund
        | x -> failwith (sprintf "ReadDistribPaymentMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDistribPaymentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:DistribPaymentMethod) : int =
    match xxIn with
    | DistribPaymentMethod.Crest ->
        let tag = "477=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Nscc ->
        let tag = "477=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Euroclear ->
        let tag = "477=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Clearstream ->
        let tag = "477=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Cheque ->
        let tag = "477=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.TelegraphicTransfer ->
        let tag = "477=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Fedwire ->
        let tag = "477=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.DirectCredit ->
        let tag = "477=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.AchCredit ->
        let tag = "477=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Bpay ->
        let tag = "477=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.HighValueClearingSystem ->
        let tag = "477=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.ReinvestInFund ->
        let tag = "477=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCashDistribCurr (pos:int) (bs:byte[]) : (int*CashDistribCurr) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribCurr.CashDistribCurr


let WriteCashDistribCurr (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribCurr) : int = 
   let tag = "478="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCommCurrency (pos:int) (bs:byte[]) : (int*CommCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CommCurrency.CommCurrency


let WriteCommCurrency (dest:byte []) (nextFreeIdx:int) (valIn:CommCurrency) : int = 
   let tag = "479="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCancellationRights (pos:int) (bs:byte[]) : (int * CancellationRights) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"Y"B -> CancellationRights.Yes
        |"N"B -> CancellationRights.NoExecutionOnly
        |"M"B -> CancellationRights.NoWaiverAgreement
        |"O"B -> CancellationRights.NoInstitutional
        | x -> failwith (sprintf "ReadCancellationRights unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCancellationRights (dest:byte array) (nextFreeIdx:int) (xxIn:CancellationRights) : int =
    match xxIn with
    | CancellationRights.Yes ->
        let tag = "480=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoExecutionOnly ->
        let tag = "480=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoWaiverAgreement ->
        let tag = "480=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoInstitutional ->
        let tag = "480=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMoneyLaunderingStatus (pos:int) (bs:byte[]) : (int * MoneyLaunderingStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"Y"B -> MoneyLaunderingStatus.Passed
        |"N"B -> MoneyLaunderingStatus.NotChecked
        |"1"B -> MoneyLaunderingStatus.ExemptBelowTheLimit
        |"2"B -> MoneyLaunderingStatus.ExemptClientMoneyTypeExemption
        |"3"B -> MoneyLaunderingStatus.ExemptAuthorisedCreditOrFinancialInstitution
        | x -> failwith (sprintf "ReadMoneyLaunderingStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMoneyLaunderingStatus (dest:byte array) (nextFreeIdx:int) (xxIn:MoneyLaunderingStatus) : int =
    match xxIn with
    | MoneyLaunderingStatus.Passed ->
        let tag = "481=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.NotChecked ->
        let tag = "481=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptBelowTheLimit ->
        let tag = "481=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptClientMoneyTypeExemption ->
        let tag = "481=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptAuthorisedCreditOrFinancialInstitution ->
        let tag = "481=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMailingInst (pos:int) (bs:byte[]) : (int*MailingInst) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MailingInst.MailingInst


let WriteMailingInst (dest:byte []) (nextFreeIdx:int) (valIn:MailingInst) : int = 
   let tag = "482="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTransBkdTime (pos:int) (bs:byte[]) : (int*TransBkdTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TransBkdTime.TransBkdTime


let WriteTransBkdTime (dest:byte []) (nextFreeIdx:int) (valIn:TransBkdTime) : int = 
   let tag = "483="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExecPriceType (pos:int) (bs:byte[]) : (int * ExecPriceType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"B"B -> ExecPriceType.BidPrice
        |"C"B -> ExecPriceType.CreationPrice
        |"D"B -> ExecPriceType.CreationPricePlusAdjustmentPercent
        |"E"B -> ExecPriceType.CreationPricePlusAdjustmentAmount
        |"O"B -> ExecPriceType.OfferPrice
        |"P"B -> ExecPriceType.OfferPriceMinusAdjustmentPercent
        |"Q"B -> ExecPriceType.OfferPriceMinusAdjustmentAmount
        |"S"B -> ExecPriceType.SinglePrice
        | x -> failwith (sprintf "ReadExecPriceType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExecPriceType (dest:byte array) (nextFreeIdx:int) (xxIn:ExecPriceType) : int =
    match xxIn with
    | ExecPriceType.BidPrice ->
        let tag = "484=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPrice ->
        let tag = "484=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPricePlusAdjustmentPercent ->
        let tag = "484=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPricePlusAdjustmentAmount ->
        let tag = "484=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPrice ->
        let tag = "484=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPriceMinusAdjustmentPercent ->
        let tag = "484=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPriceMinusAdjustmentAmount ->
        let tag = "484=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.SinglePrice ->
        let tag = "484=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecPriceAdjustment (pos:int) (bs:byte[]) : (int*ExecPriceAdjustment) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ExecPriceAdjustment.ExecPriceAdjustment


let WriteExecPriceAdjustment (dest:byte []) (nextFreeIdx:int) (valIn:ExecPriceAdjustment) : int = 
   let tag = "485="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDateOfBirth (pos:int) (bs:byte[]) : (int*DateOfBirth) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DateOfBirth.DateOfBirth


let WriteDateOfBirth (dest:byte []) (nextFreeIdx:int) (valIn:DateOfBirth) : int = 
   let tag = "486="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeReportTransType (pos:int) (bs:byte[]) : (int * TradeReportTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeReportTransType.New
        |"1"B -> TradeReportTransType.Cancel
        |"2"B -> TradeReportTransType.Replace
        |"3"B -> TradeReportTransType.Release
        |"4"B -> TradeReportTransType.Reverse
        | x -> failwith (sprintf "ReadTradeReportTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeReportTransType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportTransType) : int =
    match xxIn with
    | TradeReportTransType.New ->
        let tag = "487=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Cancel ->
        let tag = "487=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Replace ->
        let tag = "487=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Release ->
        let tag = "487=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Reverse ->
        let tag = "487=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCardHolderName (pos:int) (bs:byte[]) : (int*CardHolderName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CardHolderName.CardHolderName


let WriteCardHolderName (dest:byte []) (nextFreeIdx:int) (valIn:CardHolderName) : int = 
   let tag = "488="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCardNumber (pos:int) (bs:byte[]) : (int*CardNumber) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CardNumber.CardNumber


let WriteCardNumber (dest:byte []) (nextFreeIdx:int) (valIn:CardNumber) : int = 
   let tag = "489="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCardExpDate (pos:int) (bs:byte[]) : (int*CardExpDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CardExpDate.CardExpDate


let WriteCardExpDate (dest:byte []) (nextFreeIdx:int) (valIn:CardExpDate) : int = 
   let tag = "490="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCardIssNum (pos:int) (bs:byte[]) : (int*CardIssNum) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CardIssNum.CardIssNum


let WriteCardIssNum (dest:byte []) (nextFreeIdx:int) (valIn:CardIssNum) : int = 
   let tag = "491="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPaymentMethod (pos:int) (bs:byte[]) : (int * PaymentMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PaymentMethod.Crest
        |"2"B -> PaymentMethod.Nscc
        |"3"B -> PaymentMethod.Euroclear
        |"4"B -> PaymentMethod.Clearstream
        |"5"B -> PaymentMethod.Cheque
        |"6"B -> PaymentMethod.TelegraphicTransfer
        |"7"B -> PaymentMethod.Fedwire
        |"8"B -> PaymentMethod.DebitCard
        |"9"B -> PaymentMethod.DirectDebit
        |"10"B -> PaymentMethod.DirectCredit
        |"11"B -> PaymentMethod.CreditCard
        |"12"B -> PaymentMethod.AchDebit
        |"13"B -> PaymentMethod.AchCredit
        |"14"B -> PaymentMethod.Bpay
        |"15"B -> PaymentMethod.HighValueClearingSystem
        | x -> failwith (sprintf "ReadPaymentMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePaymentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:PaymentMethod) : int =
    match xxIn with
    | PaymentMethod.Crest ->
        let tag = "492=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Nscc ->
        let tag = "492=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Euroclear ->
        let tag = "492=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Clearstream ->
        let tag = "492=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Cheque ->
        let tag = "492=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.TelegraphicTransfer ->
        let tag = "492=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Fedwire ->
        let tag = "492=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DebitCard ->
        let tag = "492=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DirectDebit ->
        let tag = "492=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DirectCredit ->
        let tag = "492=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.CreditCard ->
        let tag = "492=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.AchDebit ->
        let tag = "492=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.AchCredit ->
        let tag = "492=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Bpay ->
        let tag = "492=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.HighValueClearingSystem ->
        let tag = "492=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistAcctType (pos:int) (bs:byte[]) : (int*RegistAcctType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistAcctType.RegistAcctType


let WriteRegistAcctType (dest:byte []) (nextFreeIdx:int) (valIn:RegistAcctType) : int = 
   let tag = "493="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDesignation (pos:int) (bs:byte[]) : (int*Designation) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Designation.Designation


let WriteDesignation (dest:byte []) (nextFreeIdx:int) (valIn:Designation) : int = 
   let tag = "494="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTaxAdvantageType (pos:int) (bs:byte[]) : (int * TaxAdvantageType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TaxAdvantageType.NNone
        |"1"B -> TaxAdvantageType.MaxiIsa
        |"2"B -> TaxAdvantageType.Tessa
        |"3"B -> TaxAdvantageType.MiniCashIsa
        |"4"B -> TaxAdvantageType.MiniStocksAndSharesIsa
        |"5"B -> TaxAdvantageType.MiniInsuranceIsa
        |"6"B -> TaxAdvantageType.CurrentYearPayment
        |"7"B -> TaxAdvantageType.PriorYearPayment
        |"8"B -> TaxAdvantageType.AssetTransfer
        |"9"B -> TaxAdvantageType.EmployeePriorYear
        |"999"B -> TaxAdvantageType.Other
        | x -> failwith (sprintf "ReadTaxAdvantageType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTaxAdvantageType (dest:byte array) (nextFreeIdx:int) (xxIn:TaxAdvantageType) : int =
    match xxIn with
    | TaxAdvantageType.NNone ->
        let tag = "495=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MaxiIsa ->
        let tag = "495=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.Tessa ->
        let tag = "495=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniCashIsa ->
        let tag = "495=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniStocksAndSharesIsa ->
        let tag = "495=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniInsuranceIsa ->
        let tag = "495=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.CurrentYearPayment ->
        let tag = "495=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.PriorYearPayment ->
        let tag = "495=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.AssetTransfer ->
        let tag = "495=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.EmployeePriorYear ->
        let tag = "495=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.Other ->
        let tag = "495=999"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRejReasonText (pos:int) (bs:byte[]) : (int*RegistRejReasonText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistRejReasonText.RegistRejReasonText


let WriteRegistRejReasonText (dest:byte []) (nextFreeIdx:int) (valIn:RegistRejReasonText) : int = 
   let tag = "496="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadFundRenewWaiv (pos:int) (bs:byte[]) : (int * FundRenewWaiv) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"Y"B -> FundRenewWaiv.Yes
        |"N"B -> FundRenewWaiv.No
        | x -> failwith (sprintf "ReadFundRenewWaiv unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteFundRenewWaiv (dest:byte array) (nextFreeIdx:int) (xxIn:FundRenewWaiv) : int =
    match xxIn with
    | FundRenewWaiv.Yes ->
        let tag = "497=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | FundRenewWaiv.No ->
        let tag = "497=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCashDistribAgentName (pos:int) (bs:byte[]) : (int*CashDistribAgentName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribAgentName.CashDistribAgentName


let WriteCashDistribAgentName (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentName) : int = 
   let tag = "498="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashDistribAgentCode (pos:int) (bs:byte[]) : (int*CashDistribAgentCode) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribAgentCode.CashDistribAgentCode


let WriteCashDistribAgentCode (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentCode) : int = 
   let tag = "499="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashDistribAgentAcctNumber (pos:int) (bs:byte[]) : (int*CashDistribAgentAcctNumber) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribAgentAcctNumber.CashDistribAgentAcctNumber


let WriteCashDistribAgentAcctNumber (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentAcctNumber) : int = 
   let tag = "500="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashDistribPayRef (pos:int) (bs:byte[]) : (int*CashDistribPayRef) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribPayRef.CashDistribPayRef


let WriteCashDistribPayRef (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribPayRef) : int = 
   let tag = "501="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashDistribAgentAcctName (pos:int) (bs:byte[]) : (int*CashDistribAgentAcctName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CashDistribAgentAcctName.CashDistribAgentAcctName


let WriteCashDistribAgentAcctName (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentAcctName) : int = 
   let tag = "502="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCardStartDate (pos:int) (bs:byte[]) : (int*CardStartDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CardStartDate.CardStartDate


let WriteCardStartDate (dest:byte []) (nextFreeIdx:int) (valIn:CardStartDate) : int = 
   let tag = "503="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPaymentDate (pos:int) (bs:byte[]) : (int*PaymentDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PaymentDate.PaymentDate


let WritePaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:PaymentDate) : int = 
   let tag = "504="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPaymentRemitterID (pos:int) (bs:byte[]) : (int*PaymentRemitterID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PaymentRemitterID.PaymentRemitterID


let WritePaymentRemitterID (dest:byte []) (nextFreeIdx:int) (valIn:PaymentRemitterID) : int = 
   let tag = "505="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRegistStatus (pos:int) (bs:byte[]) : (int * RegistStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> RegistStatus.Accepted
        |"R"B -> RegistStatus.Rejected
        |"H"B -> RegistStatus.Held
        |"N"B -> RegistStatus.Reminder
        | x -> failwith (sprintf "ReadRegistStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteRegistStatus (dest:byte array) (nextFreeIdx:int) (xxIn:RegistStatus) : int =
    match xxIn with
    | RegistStatus.Accepted ->
        let tag = "506=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Rejected ->
        let tag = "506=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Held ->
        let tag = "506=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Reminder ->
        let tag = "506=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRejReasonCode (pos:int) (bs:byte[]) : (int * RegistRejReasonCode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> RegistRejReasonCode.InvalidUnacceptableAccountType
        |"2"B -> RegistRejReasonCode.InvalidUnacceptableTaxExemptType
        |"3"B -> RegistRejReasonCode.InvalidUnacceptableOwnershipType
        |"4"B -> RegistRejReasonCode.InvalidUnacceptableNoRegDetls
        |"5"B -> RegistRejReasonCode.InvalidUnacceptableRegSeqNo
        |"6"B -> RegistRejReasonCode.InvalidUnacceptableRegDtls
        |"7"B -> RegistRejReasonCode.InvalidUnacceptableMailingDtls
        |"8"B -> RegistRejReasonCode.InvalidUnacceptableMailingInst
        |"9"B -> RegistRejReasonCode.InvalidUnacceptableInvestorId
        |"10"B -> RegistRejReasonCode.InvalidUnacceptableInvestorIdSource
        |"11"B -> RegistRejReasonCode.InvalidUnacceptableDateOfBirth
        |"12"B -> RegistRejReasonCode.InvalidUnacceptableInvestorCountryOfResidence
        |"13"B -> RegistRejReasonCode.InvalidUnacceptableNodistribinstns
        |"14"B -> RegistRejReasonCode.InvalidUnacceptableDistribPercentage
        |"15"B -> RegistRejReasonCode.InvalidUnacceptableDistribPaymentMethod
        |"16"B -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctName
        |"17"B -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentCode
        |"18"B -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctNum
        |"99"B -> RegistRejReasonCode.Other
        | x -> failwith (sprintf "ReadRegistRejReasonCode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteRegistRejReasonCode (dest:byte array) (nextFreeIdx:int) (xxIn:RegistRejReasonCode) : int =
    match xxIn with
    | RegistRejReasonCode.InvalidUnacceptableAccountType ->
        let tag = "507=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableTaxExemptType ->
        let tag = "507=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableOwnershipType ->
        let tag = "507=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableNoRegDetls ->
        let tag = "507=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableRegSeqNo ->
        let tag = "507=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableRegDtls ->
        let tag = "507=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableMailingDtls ->
        let tag = "507=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableMailingInst ->
        let tag = "507=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorId ->
        let tag = "507=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorIdSource ->
        let tag = "507=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDateOfBirth ->
        let tag = "507=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorCountryOfResidence ->
        let tag = "507=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableNodistribinstns ->
        let tag = "507=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDistribPercentage ->
        let tag = "507=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDistribPaymentMethod ->
        let tag = "507=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctName ->
        let tag = "507=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentCode ->
        let tag = "507=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctNum ->
        let tag = "507=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.Other ->
        let tag = "507=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRefID (pos:int) (bs:byte[]) : (int*RegistRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistRefID.RegistRefID


let WriteRegistRefID (dest:byte []) (nextFreeIdx:int) (valIn:RegistRefID) : int = 
   let tag = "508="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRegistDtls (pos:int) (bs:byte[]) : (int*RegistDtls) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistDtls.RegistDtls


let WriteRegistDtls (dest:byte []) (nextFreeIdx:int) (valIn:RegistDtls) : int = 
   let tag = "509="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoDistribInsts (pos:int) (bs:byte[]) : (int*NoDistribInsts) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoDistribInsts.NoDistribInsts


let WriteNoDistribInsts (dest:byte []) (nextFreeIdx:int) (valIn:NoDistribInsts) : int = 
   let tag = "510="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRegistEmail (pos:int) (bs:byte[]) : (int*RegistEmail) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistEmail.RegistEmail


let WriteRegistEmail (dest:byte []) (nextFreeIdx:int) (valIn:RegistEmail) : int = 
   let tag = "511="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDistribPercentage (pos:int) (bs:byte[]) : (int*DistribPercentage) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DistribPercentage.DistribPercentage


let WriteDistribPercentage (dest:byte []) (nextFreeIdx:int) (valIn:DistribPercentage) : int = 
   let tag = "512="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRegistID (pos:int) (bs:byte[]) : (int*RegistID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RegistID.RegistID


let WriteRegistID (dest:byte []) (nextFreeIdx:int) (valIn:RegistID) : int = 
   let tag = "513="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRegistTransType (pos:int) (bs:byte[]) : (int * RegistTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> RegistTransType.New
        |"1"B -> RegistTransType.Replace
        |"2"B -> RegistTransType.Cancel
        | x -> failwith (sprintf "ReadRegistTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteRegistTransType (dest:byte array) (nextFreeIdx:int) (xxIn:RegistTransType) : int =
    match xxIn with
    | RegistTransType.New ->
        let tag = "514=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistTransType.Replace ->
        let tag = "514=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistTransType.Cancel ->
        let tag = "514=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecValuationPoint (pos:int) (bs:byte[]) : (int*ExecValuationPoint) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExecValuationPoint.ExecValuationPoint


let WriteExecValuationPoint (dest:byte []) (nextFreeIdx:int) (valIn:ExecValuationPoint) : int = 
   let tag = "515="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderPercent (pos:int) (bs:byte[]) : (int*OrderPercent) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderPercent.OrderPercent


let WriteOrderPercent (dest:byte []) (nextFreeIdx:int) (valIn:OrderPercent) : int = 
   let tag = "516="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOwnershipType (pos:int) (bs:byte[]) : (int * OwnershipType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"J"B -> OwnershipType.JointInvestors
        |"T"B -> OwnershipType.TenantsInCommon
        |"2"B -> OwnershipType.JointTrustees
        | x -> failwith (sprintf "ReadOwnershipType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOwnershipType (dest:byte array) (nextFreeIdx:int) (xxIn:OwnershipType) : int =
    match xxIn with
    | OwnershipType.JointInvestors ->
        let tag = "517=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnershipType.TenantsInCommon ->
        let tag = "517=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnershipType.JointTrustees ->
        let tag = "517=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoContAmts (pos:int) (bs:byte[]) : (int*NoContAmts) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoContAmts.NoContAmts


let WriteNoContAmts (dest:byte []) (nextFreeIdx:int) (valIn:NoContAmts) : int = 
   let tag = "518="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContAmtType (pos:int) (bs:byte[]) : (int * ContAmtType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ContAmtType.CommissionAmount
        |"2"B -> ContAmtType.CommissionPercent
        |"3"B -> ContAmtType.InitialChargeAmount
        |"4"B -> ContAmtType.InitialChargePercent
        |"5"B -> ContAmtType.DiscountAmount
        |"6"B -> ContAmtType.DiscountPercent
        |"7"B -> ContAmtType.DilutionLevyAmount
        |"8"B -> ContAmtType.DilutionLevyPercent
        |"9"B -> ContAmtType.ExitChargeAmount
        | x -> failwith (sprintf "ReadContAmtType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteContAmtType (dest:byte array) (nextFreeIdx:int) (xxIn:ContAmtType) : int =
    match xxIn with
    | ContAmtType.CommissionAmount ->
        let tag = "519=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.CommissionPercent ->
        let tag = "519=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.InitialChargeAmount ->
        let tag = "519=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.InitialChargePercent ->
        let tag = "519=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DiscountAmount ->
        let tag = "519=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DiscountPercent ->
        let tag = "519=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DilutionLevyAmount ->
        let tag = "519=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DilutionLevyPercent ->
        let tag = "519=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.ExitChargeAmount ->
        let tag = "519=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContAmtValue (pos:int) (bs:byte[]) : (int*ContAmtValue) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ContAmtValue.ContAmtValue


let WriteContAmtValue (dest:byte []) (nextFreeIdx:int) (valIn:ContAmtValue) : int = 
   let tag = "520="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContAmtCurr (pos:int) (bs:byte[]) : (int*ContAmtCurr) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContAmtCurr.ContAmtCurr


let WriteContAmtCurr (dest:byte []) (nextFreeIdx:int) (valIn:ContAmtCurr) : int = 
   let tag = "521="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOwnerType (pos:int) (bs:byte[]) : (int * OwnerType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> OwnerType.IndividualInvestor
        |"2"B -> OwnerType.PublicCompany
        |"3"B -> OwnerType.PrivateCompany
        |"4"B -> OwnerType.IndividualTrustee
        |"5"B -> OwnerType.CompanyTrustee
        |"6"B -> OwnerType.PensionPlan
        |"7"B -> OwnerType.CustodianUnderGiftsToMinorsAct
        |"8"B -> OwnerType.Trusts
        |"9"B -> OwnerType.Fiduciaries
        |"10"B -> OwnerType.NetworkingSubAccount
        |"11"B -> OwnerType.NonProfitOrganization
        |"12"B -> OwnerType.CorporateBody
        |"13"B -> OwnerType.Nominee
        | x -> failwith (sprintf "ReadOwnerType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOwnerType (dest:byte array) (nextFreeIdx:int) (xxIn:OwnerType) : int =
    match xxIn with
    | OwnerType.IndividualInvestor ->
        let tag = "522=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PublicCompany ->
        let tag = "522=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PrivateCompany ->
        let tag = "522=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.IndividualTrustee ->
        let tag = "522=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CompanyTrustee ->
        let tag = "522=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PensionPlan ->
        let tag = "522=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CustodianUnderGiftsToMinorsAct ->
        let tag = "522=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Trusts ->
        let tag = "522=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Fiduciaries ->
        let tag = "522=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.NetworkingSubAccount ->
        let tag = "522=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.NonProfitOrganization ->
        let tag = "522=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CorporateBody ->
        let tag = "522=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Nominee ->
        let tag = "522=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPartySubID (pos:int) (bs:byte[]) : (int*PartySubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PartySubID.PartySubID


let WritePartySubID (dest:byte []) (nextFreeIdx:int) (valIn:PartySubID) : int = 
   let tag = "523="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNestedPartyID (pos:int) (bs:byte[]) : (int*NestedPartyID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) NestedPartyID.NestedPartyID


let WriteNestedPartyID (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyID) : int = 
   let tag = "524="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNestedPartyIDSource (pos:int) (bs:byte[]) : (int*NestedPartyIDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NestedPartyIDSource.NestedPartyIDSource


let WriteNestedPartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyIDSource) : int = 
   let tag = "525="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecondaryClOrdID (pos:int) (bs:byte[]) : (int*SecondaryClOrdID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryClOrdID.SecondaryClOrdID


let WriteSecondaryClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryClOrdID) : int = 
   let tag = "526="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecondaryExecID (pos:int) (bs:byte[]) : (int*SecondaryExecID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryExecID.SecondaryExecID


let WriteSecondaryExecID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryExecID) : int = 
   let tag = "527="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderCapacity (pos:int) (bs:byte[]) : (int * OrderCapacity) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> OrderCapacity.Agency
        |"G"B -> OrderCapacity.Proprietary
        |"I"B -> OrderCapacity.Individual
        |"P"B -> OrderCapacity.Principal
        |"R"B -> OrderCapacity.RisklessPrincipal
        |"W"B -> OrderCapacity.AgentForOtherMember
        | x -> failwith (sprintf "ReadOrderCapacity unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOrderCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:OrderCapacity) : int =
    match xxIn with
    | OrderCapacity.Agency ->
        let tag = "528=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Proprietary ->
        let tag = "528=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Individual ->
        let tag = "528=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Principal ->
        let tag = "528=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.RisklessPrincipal ->
        let tag = "528=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.AgentForOtherMember ->
        let tag = "528=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrderRestrictions (pos:int) (bs:byte[]) : (int * OrderRestrictions) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> OrderRestrictions.ProgramTrade
        |"2"B -> OrderRestrictions.IndexArbitrage
        |"3"B -> OrderRestrictions.NonIndexArbitrage
        |"4"B -> OrderRestrictions.CompetingMarketMaker
        |"5"B -> OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheSecurity
        |"6"B -> OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheUnderlyingSecurityOfADerivativeSecurity
        |"7"B -> OrderRestrictions.ForeignEntity
        |"8"B -> OrderRestrictions.ExternalMarketParticipant
        |"9"B -> OrderRestrictions.ExternalInterConnectedMarketLinkage
        |"A"B -> OrderRestrictions.RisklessArbitrage
        | x -> failwith (sprintf "ReadOrderRestrictions unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteOrderRestrictions (dest:byte array) (nextFreeIdx:int) (xxIn:OrderRestrictions) : int =
    match xxIn with
    | OrderRestrictions.ProgramTrade ->
        let tag = "529=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.IndexArbitrage ->
        let tag = "529=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.NonIndexArbitrage ->
        let tag = "529=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.CompetingMarketMaker ->
        let tag = "529=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheSecurity ->
        let tag = "529=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheUnderlyingSecurityOfADerivativeSecurity ->
        let tag = "529=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ForeignEntity ->
        let tag = "529=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ExternalMarketParticipant ->
        let tag = "529=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ExternalInterConnectedMarketLinkage ->
        let tag = "529=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.RisklessArbitrage ->
        let tag = "529=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelRequestType (pos:int) (bs:byte[]) : (int * MassCancelRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> MassCancelRequestType.CancelOrdersForASecurity
        |"2"B -> MassCancelRequestType.CancelOrdersForAnUnderlyingSecurity
        |"3"B -> MassCancelRequestType.CancelOrdersForAProduct
        |"4"B -> MassCancelRequestType.CancelOrdersForACficode
        |"5"B -> MassCancelRequestType.CancelOrdersForASecuritytype
        |"6"B -> MassCancelRequestType.CancelOrdersForATradingSession
        |"7"B -> MassCancelRequestType.CancelAllOrders
        | x -> failwith (sprintf "ReadMassCancelRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMassCancelRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelRequestType) : int =
    match xxIn with
    | MassCancelRequestType.CancelOrdersForASecurity ->
        let tag = "530=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForAnUnderlyingSecurity ->
        let tag = "530=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForAProduct ->
        let tag = "530=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForACficode ->
        let tag = "530=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForASecuritytype ->
        let tag = "530=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForATradingSession ->
        let tag = "530=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelAllOrders ->
        let tag = "530=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelResponse (pos:int) (bs:byte[]) : (int * MassCancelResponse) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MassCancelResponse.CancelRequestRejected
        |"1"B -> MassCancelResponse.CancelOrdersForASecurity
        |"2"B -> MassCancelResponse.CancelOrdersForAnUnderlyingSecurity
        |"3"B -> MassCancelResponse.CancelOrdersForAProduct
        |"4"B -> MassCancelResponse.CancelOrdersForACficode
        |"5"B -> MassCancelResponse.CancelOrdersForASecuritytype
        |"6"B -> MassCancelResponse.CancelOrdersForATradingSession
        |"7"B -> MassCancelResponse.CancelAllOrders
        | x -> failwith (sprintf "ReadMassCancelResponse unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMassCancelResponse (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelResponse) : int =
    match xxIn with
    | MassCancelResponse.CancelRequestRejected ->
        let tag = "531=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForASecurity ->
        let tag = "531=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForAnUnderlyingSecurity ->
        let tag = "531=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForAProduct ->
        let tag = "531=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForACficode ->
        let tag = "531=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForASecuritytype ->
        let tag = "531=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForATradingSession ->
        let tag = "531=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelAllOrders ->
        let tag = "531=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelRejectReason (pos:int) (bs:byte[]) : (int * MassCancelRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MassCancelRejectReason.MassCancelNotSupported
        |"1"B -> MassCancelRejectReason.InvalidOrUnknownSecurity
        |"2"B -> MassCancelRejectReason.InvalidOrUnknownUnderlying
        |"3"B -> MassCancelRejectReason.InvalidOrUnknownProduct
        |"4"B -> MassCancelRejectReason.InvalidOrUnknownCficode
        |"5"B -> MassCancelRejectReason.InvalidOrUnknownSecurityType
        |"6"B -> MassCancelRejectReason.InvalidOrUnknownTradingSession
        |"99"B -> MassCancelRejectReason.Other
        | x -> failwith (sprintf "ReadMassCancelRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMassCancelRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelRejectReason) : int =
    match xxIn with
    | MassCancelRejectReason.MassCancelNotSupported ->
        let tag = "532=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownSecurity ->
        let tag = "532=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownUnderlying ->
        let tag = "532=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownProduct ->
        let tag = "532=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownCficode ->
        let tag = "532=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownSecurityType ->
        let tag = "532=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownTradingSession ->
        let tag = "532=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.Other ->
        let tag = "532=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotalAffectedOrders (pos:int) (bs:byte[]) : (int*TotalAffectedOrders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotalAffectedOrders.TotalAffectedOrders


let WriteTotalAffectedOrders (dest:byte []) (nextFreeIdx:int) (valIn:TotalAffectedOrders) : int = 
   let tag = "533="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoAffectedOrders (pos:int) (bs:byte[]) : (int*NoAffectedOrders) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoAffectedOrders.NoAffectedOrders


let WriteNoAffectedOrders (dest:byte []) (nextFreeIdx:int) (valIn:NoAffectedOrders) : int = 
   let tag = "534="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAffectedOrderID (pos:int) (bs:byte[]) : (int*AffectedOrderID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AffectedOrderID.AffectedOrderID


let WriteAffectedOrderID (dest:byte []) (nextFreeIdx:int) (valIn:AffectedOrderID) : int = 
   let tag = "535="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAffectedSecondaryOrderID (pos:int) (bs:byte[]) : (int*AffectedSecondaryOrderID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AffectedSecondaryOrderID.AffectedSecondaryOrderID


let WriteAffectedSecondaryOrderID (dest:byte []) (nextFreeIdx:int) (valIn:AffectedSecondaryOrderID) : int = 
   let tag = "536="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteType (pos:int) (bs:byte[]) : (int * QuoteType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> QuoteType.Indicative
        |"1"B -> QuoteType.Tradeable
        |"2"B -> QuoteType.RestrictedTradeable
        |"3"B -> QuoteType.Counter
        | x -> failwith (sprintf "ReadQuoteType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteType) : int =
    match xxIn with
    | QuoteType.Indicative ->
        let tag = "537=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.Tradeable ->
        let tag = "537=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.RestrictedTradeable ->
        let tag = "537=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.Counter ->
        let tag = "537=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNestedPartyRole (pos:int) (bs:byte[]) : (int*NestedPartyRole) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NestedPartyRole.NestedPartyRole


let WriteNestedPartyRole (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyRole) : int = 
   let tag = "538="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNestedPartyIDs (pos:int) (bs:byte[]) : (int*NoNestedPartyIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNestedPartyIDs.NoNestedPartyIDs


let WriteNoNestedPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNestedPartyIDs) : int = 
   let tag = "539="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotalAccruedInterestAmt (pos:int) (bs:byte[]) : (int*TotalAccruedInterestAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotalAccruedInterestAmt.TotalAccruedInterestAmt


let WriteTotalAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:TotalAccruedInterestAmt) : int = 
   let tag = "540="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMaturityDate (pos:int) (bs:byte[]) : (int*MaturityDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MaturityDate.MaturityDate


let WriteMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:MaturityDate) : int = 
   let tag = "541="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingMaturityDate (pos:int) (bs:byte[]) : (int*UnderlyingMaturityDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingMaturityDate.UnderlyingMaturityDate


let WriteUnderlyingMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingMaturityDate) : int = 
   let tag = "542="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadInstrRegistry (pos:int) (bs:byte[]) : (int*InstrRegistry) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) InstrRegistry.InstrRegistry


let WriteInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:InstrRegistry) : int = 
   let tag = "543="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashMargin (pos:int) (bs:byte[]) : (int * CashMargin) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> CashMargin.Cash
        |"2"B -> CashMargin.MarginOpen
        |"3"B -> CashMargin.MarginClose
        | x -> failwith (sprintf "ReadCashMargin unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCashMargin (dest:byte array) (nextFreeIdx:int) (xxIn:CashMargin) : int =
    match xxIn with
    | CashMargin.Cash ->
        let tag = "544=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CashMargin.MarginOpen ->
        let tag = "544=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CashMargin.MarginClose ->
        let tag = "544=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNestedPartySubID (pos:int) (bs:byte[]) : (int*NestedPartySubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) NestedPartySubID.NestedPartySubID


let WriteNestedPartySubID (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartySubID) : int = 
   let tag = "545="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadScope (pos:int) (bs:byte[]) : (int * Scope) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> Scope.Local
        |"2"B -> Scope.National
        |"3"B -> Scope.Global
        | x -> failwith (sprintf "ReadScope unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteScope (dest:byte array) (nextFreeIdx:int) (xxIn:Scope) : int =
    match xxIn with
    | Scope.Local ->
        let tag = "546=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Scope.National ->
        let tag = "546=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Scope.Global ->
        let tag = "546=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDImplicitDelete (pos:int) (bs:byte[]) : (int*MDImplicitDelete) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) MDImplicitDelete.MDImplicitDelete


let WriteMDImplicitDelete (dest:byte []) (nextFreeIdx:int) (valIn:MDImplicitDelete) : int = 
   let tag = "547="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCrossID (pos:int) (bs:byte[]) : (int*CrossID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CrossID.CrossID


let WriteCrossID (dest:byte []) (nextFreeIdx:int) (valIn:CrossID) : int = 
   let tag = "548="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCrossType (pos:int) (bs:byte[]) : (int * CrossType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> CrossType.CrossTradeWhichIsExecutedCompletelyOrNot
        |"2"B -> CrossType.CrossTradeWhichIsExecutedPartiallyAndTheRestIsCancelled
        |"3"B -> CrossType.CrossTradeWhichIsPartiallyExecutedWithTheUnfilledPortionsRemainingActive
        |"4"B -> CrossType.CrossTradeIsExecutedWithExistingOrdersWithTheSamePrice
        | x -> failwith (sprintf "ReadCrossType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCrossType (dest:byte array) (nextFreeIdx:int) (xxIn:CrossType) : int =
    match xxIn with
    | CrossType.CrossTradeWhichIsExecutedCompletelyOrNot ->
        let tag = "549=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeWhichIsExecutedPartiallyAndTheRestIsCancelled ->
        let tag = "549=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeWhichIsPartiallyExecutedWithTheUnfilledPortionsRemainingActive ->
        let tag = "549=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeIsExecutedWithExistingOrdersWithTheSamePrice ->
        let tag = "549=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCrossPrioritization (pos:int) (bs:byte[]) : (int * CrossPrioritization) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CrossPrioritization.NNone
        |"1"B -> CrossPrioritization.BuySideIsPrioritized
        |"2"B -> CrossPrioritization.SellSideIsPrioritized
        | x -> failwith (sprintf "ReadCrossPrioritization unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCrossPrioritization (dest:byte array) (nextFreeIdx:int) (xxIn:CrossPrioritization) : int =
    match xxIn with
    | CrossPrioritization.NNone ->
        let tag = "550=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossPrioritization.BuySideIsPrioritized ->
        let tag = "550=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossPrioritization.SellSideIsPrioritized ->
        let tag = "550=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigCrossID (pos:int) (bs:byte[]) : (int*OrigCrossID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigCrossID.OrigCrossID


let WriteOrigCrossID (dest:byte []) (nextFreeIdx:int) (valIn:OrigCrossID) : int = 
   let tag = "551="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoSides (pos:int) (bs:byte[]) : (int * NoSides) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> NoSides.OneSide
        |"2"B -> NoSides.BothSides
        | x -> failwith (sprintf "ReadNoSides unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteNoSides (dest:byte array) (nextFreeIdx:int) (xxIn:NoSides) : int =
    match xxIn with
    | NoSides.OneSide ->
        let tag = "552=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NoSides.BothSides ->
        let tag = "552=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUsername (pos:int) (bs:byte[]) : (int*Username) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Username.Username


let WriteUsername (dest:byte []) (nextFreeIdx:int) (valIn:Username) : int = 
   let tag = "553="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPassword (pos:int) (bs:byte[]) : (int*Password) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Password.Password


let WritePassword (dest:byte []) (nextFreeIdx:int) (valIn:Password) : int = 
   let tag = "554="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoLegs (pos:int) (bs:byte[]) : (int*NoLegs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoLegs.NoLegs


let WriteNoLegs (dest:byte []) (nextFreeIdx:int) (valIn:NoLegs) : int = 
   let tag = "555="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCurrency (pos:int) (bs:byte[]) : (int*LegCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegCurrency.LegCurrency


let WriteLegCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegCurrency) : int = 
   let tag = "556="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotNoSecurityTypes (pos:int) (bs:byte[]) : (int*TotNoSecurityTypes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoSecurityTypes.TotNoSecurityTypes


let WriteTotNoSecurityTypes (dest:byte []) (nextFreeIdx:int) (valIn:TotNoSecurityTypes) : int = 
   let tag = "557="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoSecurityTypes (pos:int) (bs:byte[]) : (int*NoSecurityTypes) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoSecurityTypes.NoSecurityTypes


let WriteNoSecurityTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoSecurityTypes) : int = 
   let tag = "558="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecurityListRequestType (pos:int) (bs:byte[]) : (int * SecurityListRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SecurityListRequestType.Symbol
        |"1"B -> SecurityListRequestType.SecuritytypeAndOrCficode
        |"2"B -> SecurityListRequestType.Product
        |"3"B -> SecurityListRequestType.Tradingsessionid
        |"4"B -> SecurityListRequestType.AllSecurities
        | x -> failwith (sprintf "ReadSecurityListRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityListRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityListRequestType) : int =
    match xxIn with
    | SecurityListRequestType.Symbol ->
        let tag = "559=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.SecuritytypeAndOrCficode ->
        let tag = "559=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.Product ->
        let tag = "559=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.Tradingsessionid ->
        let tag = "559=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.AllSecurities ->
        let tag = "559=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityRequestResult (pos:int) (bs:byte[]) : (int * SecurityRequestResult) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SecurityRequestResult.ValidRequest
        |"1"B -> SecurityRequestResult.InvalidOrUnsupportedRequest
        |"2"B -> SecurityRequestResult.NoInstrumentsFoundThatMatchSelectionCriteria
        |"3"B -> SecurityRequestResult.NotAuthorizedToRetrieveInstrumentData
        |"4"B -> SecurityRequestResult.InstrumentDataTemporarilyUnavailable
        |"5"B -> SecurityRequestResult.RequestForInstrumentDataNotSupported
        | x -> failwith (sprintf "ReadSecurityRequestResult unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSecurityRequestResult (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityRequestResult) : int =
    match xxIn with
    | SecurityRequestResult.ValidRequest ->
        let tag = "560=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.InvalidOrUnsupportedRequest ->
        let tag = "560=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.NoInstrumentsFoundThatMatchSelectionCriteria ->
        let tag = "560=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.NotAuthorizedToRetrieveInstrumentData ->
        let tag = "560=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.InstrumentDataTemporarilyUnavailable ->
        let tag = "560=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.RequestForInstrumentDataNotSupported ->
        let tag = "560=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoundLot (pos:int) (bs:byte[]) : (int*RoundLot) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) RoundLot.RoundLot


let WriteRoundLot (dest:byte []) (nextFreeIdx:int) (valIn:RoundLot) : int = 
   let tag = "561="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMinTradeVol (pos:int) (bs:byte[]) : (int*MinTradeVol) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MinTradeVol.MinTradeVol


let WriteMinTradeVol (dest:byte []) (nextFreeIdx:int) (valIn:MinTradeVol) : int = 
   let tag = "562="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMultiLegRptTypeReq (pos:int) (bs:byte[]) : (int * MultiLegRptTypeReq) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MultiLegRptTypeReq.ReportByMulitlegSecurityOnly
        |"1"B -> MultiLegRptTypeReq.ReportByMultilegSecurityAndByInstrumentLegsBelongingToTheMultilegSecurity
        |"2"B -> MultiLegRptTypeReq.ReportByInstrumentLegsBelongingToTheMultilegSecurityOnly
        | x -> failwith (sprintf "ReadMultiLegRptTypeReq unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMultiLegRptTypeReq (dest:byte array) (nextFreeIdx:int) (xxIn:MultiLegRptTypeReq) : int =
    match xxIn with
    | MultiLegRptTypeReq.ReportByMulitlegSecurityOnly ->
        let tag = "563=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegRptTypeReq.ReportByMultilegSecurityAndByInstrumentLegsBelongingToTheMultilegSecurity ->
        let tag = "563=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegRptTypeReq.ReportByInstrumentLegsBelongingToTheMultilegSecurityOnly ->
        let tag = "563=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLegPositionEffect (pos:int) (bs:byte[]) : (int*LegPositionEffect) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegPositionEffect.LegPositionEffect


let WriteLegPositionEffect (dest:byte []) (nextFreeIdx:int) (valIn:LegPositionEffect) : int = 
   let tag = "564="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCoveredOrUncovered (pos:int) (bs:byte[]) : (int*LegCoveredOrUncovered) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegCoveredOrUncovered.LegCoveredOrUncovered


let WriteLegCoveredOrUncovered (dest:byte []) (nextFreeIdx:int) (valIn:LegCoveredOrUncovered) : int = 
   let tag = "565="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegPrice (pos:int) (bs:byte[]) : (int*LegPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegPrice.LegPrice


let WriteLegPrice (dest:byte []) (nextFreeIdx:int) (valIn:LegPrice) : int = 
   let tag = "566="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradSesStatusRejReason (pos:int) (bs:byte[]) : (int * TradSesStatusRejReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> TradSesStatusRejReason.UnknownOrInvalidTradingsessionid
        | x -> failwith (sprintf "ReadTradSesStatusRejReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradSesStatusRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesStatusRejReason) : int =
    match xxIn with
    | TradSesStatusRejReason.UnknownOrInvalidTradingsessionid ->
        let tag = "567=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeRequestID (pos:int) (bs:byte[]) : (int*TradeRequestID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeRequestID.TradeRequestID


let WriteTradeRequestID (dest:byte []) (nextFreeIdx:int) (valIn:TradeRequestID) : int = 
   let tag = "568="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeRequestType (pos:int) (bs:byte[]) : (int * TradeRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeRequestType.AllTrades
        |"1"B -> TradeRequestType.MatchedTradesMatchingCriteriaProvidedOnRequest
        |"2"B -> TradeRequestType.UnmatchedTradesThatMatchCriteria
        |"3"B -> TradeRequestType.UnreportedTradesThatMatchCriteria
        |"4"B -> TradeRequestType.AdvisoriesThatMatchCriteria
        | x -> failwith (sprintf "ReadTradeRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestType) : int =
    match xxIn with
    | TradeRequestType.AllTrades ->
        let tag = "569=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.MatchedTradesMatchingCriteriaProvidedOnRequest ->
        let tag = "569=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.UnmatchedTradesThatMatchCriteria ->
        let tag = "569=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.UnreportedTradesThatMatchCriteria ->
        let tag = "569=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.AdvisoriesThatMatchCriteria ->
        let tag = "569=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPreviouslyReported (pos:int) (bs:byte[]) : (int*PreviouslyReported) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) PreviouslyReported.PreviouslyReported


let WritePreviouslyReported (dest:byte []) (nextFreeIdx:int) (valIn:PreviouslyReported) : int = 
   let tag = "570="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeReportID (pos:int) (bs:byte[]) : (int*TradeReportID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeReportID.TradeReportID


let WriteTradeReportID (dest:byte []) (nextFreeIdx:int) (valIn:TradeReportID) : int = 
   let tag = "571="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeReportRefID (pos:int) (bs:byte[]) : (int*TradeReportRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeReportRefID.TradeReportRefID


let WriteTradeReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:TradeReportRefID) : int = 
   let tag = "572="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMatchStatus (pos:int) (bs:byte[]) : (int * MatchStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MatchStatus.ComparedMatchedOrAffirmed
        |"1"B -> MatchStatus.UncomparedUnmatchedOrUnaffirmed
        |"2"B -> MatchStatus.AdvisoryOrAlert
        | x -> failwith (sprintf "ReadMatchStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMatchStatus (dest:byte array) (nextFreeIdx:int) (xxIn:MatchStatus) : int =
    match xxIn with
    | MatchStatus.ComparedMatchedOrAffirmed ->
        let tag = "573=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MatchStatus.UncomparedUnmatchedOrUnaffirmed ->
        let tag = "573=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MatchStatus.AdvisoryOrAlert ->
        let tag = "573=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMatchType (pos:int) (bs:byte[]) : (int*MatchType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MatchType.MatchType


let WriteMatchType (dest:byte []) (nextFreeIdx:int) (valIn:MatchType) : int = 
   let tag = "574="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOddLot (pos:int) (bs:byte[]) : (int*OddLot) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) OddLot.OddLot


let WriteOddLot (dest:byte []) (nextFreeIdx:int) (valIn:OddLot) : int = 
   let tag = "575="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoClearingInstructions (pos:int) (bs:byte[]) : (int*NoClearingInstructions) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoClearingInstructions.NoClearingInstructions


let WriteNoClearingInstructions (dest:byte []) (nextFreeIdx:int) (valIn:NoClearingInstructions) : int = 
   let tag = "576="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadClearingInstruction (pos:int) (bs:byte[]) : (int * ClearingInstruction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ClearingInstruction.ProcessNormally
        |"1"B -> ClearingInstruction.ExcludeFromAllNetting
        |"2"B -> ClearingInstruction.BilateralNettingOnly
        |"3"B -> ClearingInstruction.ExClearing
        |"4"B -> ClearingInstruction.SpecialTrade
        |"5"B -> ClearingInstruction.MultilateralNetting
        |"6"B -> ClearingInstruction.ClearAgainstCentralCounterparty
        |"7"B -> ClearingInstruction.ExcludeFromCentralCounterparty
        |"8"B -> ClearingInstruction.ManualMode
        |"9"B -> ClearingInstruction.AutomaticPostingMode
        |"10"B -> ClearingInstruction.AutomaticGiveUpMode
        |"11"B -> ClearingInstruction.QualifiedServiceRepresentative
        |"12"B -> ClearingInstruction.CustomerTrade
        |"13"B -> ClearingInstruction.SelfClearing
        | x -> failwith (sprintf "ReadClearingInstruction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteClearingInstruction (dest:byte array) (nextFreeIdx:int) (xxIn:ClearingInstruction) : int =
    match xxIn with
    | ClearingInstruction.ProcessNormally ->
        let tag = "577=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExcludeFromAllNetting ->
        let tag = "577=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.BilateralNettingOnly ->
        let tag = "577=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExClearing ->
        let tag = "577=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.SpecialTrade ->
        let tag = "577=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.MultilateralNetting ->
        let tag = "577=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ClearAgainstCentralCounterparty ->
        let tag = "577=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExcludeFromCentralCounterparty ->
        let tag = "577=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ManualMode ->
        let tag = "577=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.AutomaticPostingMode ->
        let tag = "577=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.AutomaticGiveUpMode ->
        let tag = "577=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.QualifiedServiceRepresentative ->
        let tag = "577=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.CustomerTrade ->
        let tag = "577=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.SelfClearing ->
        let tag = "577=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeInputSource (pos:int) (bs:byte[]) : (int*TradeInputSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeInputSource.TradeInputSource


let WriteTradeInputSource (dest:byte []) (nextFreeIdx:int) (valIn:TradeInputSource) : int = 
   let tag = "578="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeInputDevice (pos:int) (bs:byte[]) : (int*TradeInputDevice) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeInputDevice.TradeInputDevice


let WriteTradeInputDevice (dest:byte []) (nextFreeIdx:int) (valIn:TradeInputDevice) : int = 
   let tag = "579="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoDates (pos:int) (bs:byte[]) : (int*NoDates) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoDates.NoDates


let WriteNoDates (dest:byte []) (nextFreeIdx:int) (valIn:NoDates) : int = 
   let tag = "580="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAccountType (pos:int) (bs:byte[]) : (int * AccountType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AccountType.AccountIsCarriedOnCustomerSideOfBooks
        |"2"B -> AccountType.AccountIsCarriedOnNonCustomerSideOfBooks
        |"3"B -> AccountType.HouseTrader
        |"4"B -> AccountType.FloorTrader
        |"6"B -> AccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined
        |"7"B -> AccountType.AccountIsHouseTraderAndIsCrossMargined
        |"8"B -> AccountType.JointBackofficeAccount
        | x -> failwith (sprintf "ReadAccountType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAccountType (dest:byte array) (nextFreeIdx:int) (xxIn:AccountType) : int =
    match xxIn with
    | AccountType.AccountIsCarriedOnCustomerSideOfBooks ->
        let tag = "581=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsCarriedOnNonCustomerSideOfBooks ->
        let tag = "581=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.HouseTrader ->
        let tag = "581=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.FloorTrader ->
        let tag = "581=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined ->
        let tag = "581=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsHouseTraderAndIsCrossMargined ->
        let tag = "581=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.JointBackofficeAccount ->
        let tag = "581=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCustOrderCapacity (pos:int) (bs:byte[]) : (int * CustOrderCapacity) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> CustOrderCapacity.MemberTradingForTheirOwnAccount
        |"2"B -> CustOrderCapacity.ClearingFirmTradingForItsProprietaryAccount
        |"3"B -> CustOrderCapacity.MemberTradingForAnotherMember
        |"4"B -> CustOrderCapacity.AllOther
        | x -> failwith (sprintf "ReadCustOrderCapacity unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCustOrderCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:CustOrderCapacity) : int =
    match xxIn with
    | CustOrderCapacity.MemberTradingForTheirOwnAccount ->
        let tag = "582=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.ClearingFirmTradingForItsProprietaryAccount ->
        let tag = "582=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.MemberTradingForAnotherMember ->
        let tag = "582=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.AllOther ->
        let tag = "582=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadClOrdLinkID (pos:int) (bs:byte[]) : (int*ClOrdLinkID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ClOrdLinkID.ClOrdLinkID


let WriteClOrdLinkID (dest:byte []) (nextFreeIdx:int) (valIn:ClOrdLinkID) : int = 
   let tag = "583="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMassStatusReqID (pos:int) (bs:byte[]) : (int*MassStatusReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) MassStatusReqID.MassStatusReqID


let WriteMassStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:MassStatusReqID) : int = 
   let tag = "584="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMassStatusReqType (pos:int) (bs:byte[]) : (int * MassStatusReqType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> MassStatusReqType.StatusForOrdersForASecurity
        |"2"B -> MassStatusReqType.StatusForOrdersForAnUnderlyingSecurity
        |"3"B -> MassStatusReqType.StatusForOrdersForAProduct
        |"4"B -> MassStatusReqType.StatusForOrdersForACficode
        |"5"B -> MassStatusReqType.StatusForOrdersForASecuritytype
        |"6"B -> MassStatusReqType.StatusForOrdersForATradingSession
        |"7"B -> MassStatusReqType.StatusForAllOrders
        |"8"B -> MassStatusReqType.StatusForOrdersForAPartyid
        | x -> failwith (sprintf "ReadMassStatusReqType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMassStatusReqType (dest:byte array) (nextFreeIdx:int) (xxIn:MassStatusReqType) : int =
    match xxIn with
    | MassStatusReqType.StatusForOrdersForASecurity ->
        let tag = "585=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAnUnderlyingSecurity ->
        let tag = "585=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAProduct ->
        let tag = "585=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForACficode ->
        let tag = "585=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForASecuritytype ->
        let tag = "585=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForATradingSession ->
        let tag = "585=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForAllOrders ->
        let tag = "585=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAPartyid ->
        let tag = "585=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigOrdModTime (pos:int) (bs:byte[]) : (int*OrigOrdModTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigOrdModTime.OrigOrdModTime


let WriteOrigOrdModTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigOrdModTime) : int = 
   let tag = "586="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSettlType (pos:int) (bs:byte[]) : (int*LegSettlType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegSettlType.LegSettlType


let WriteLegSettlType (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlType) : int = 
   let tag = "587="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSettlDate (pos:int) (bs:byte[]) : (int*LegSettlDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSettlDate.LegSettlDate


let WriteLegSettlDate (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlDate) : int = 
   let tag = "588="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDayBookingInst (pos:int) (bs:byte[]) : (int * DayBookingInst) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DayBookingInst.CanTriggerBookingWithoutReferenceToTheOrderInitiator
        |"1"B -> DayBookingInst.SpeakWithOrderInitiatorBeforeBooking
        |"2"B -> DayBookingInst.Accumulate
        | x -> failwith (sprintf "ReadDayBookingInst unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDayBookingInst (dest:byte array) (nextFreeIdx:int) (xxIn:DayBookingInst) : int =
    match xxIn with
    | DayBookingInst.CanTriggerBookingWithoutReferenceToTheOrderInitiator ->
        let tag = "589=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DayBookingInst.SpeakWithOrderInitiatorBeforeBooking ->
        let tag = "589=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DayBookingInst.Accumulate ->
        let tag = "589=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingUnit (pos:int) (bs:byte[]) : (int * BookingUnit) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> BookingUnit.EachPartialExecutionIsABookableUnit
        |"1"B -> BookingUnit.AggregatePartialExecutionsOnThisOrderAndBookOneTradePerOrder
        |"2"B -> BookingUnit.AggregateExecutionsForThisSymbolSideAndSettlementDate
        | x -> failwith (sprintf "ReadBookingUnit unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBookingUnit (dest:byte array) (nextFreeIdx:int) (xxIn:BookingUnit) : int =
    match xxIn with
    | BookingUnit.EachPartialExecutionIsABookableUnit ->
        let tag = "590=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingUnit.AggregatePartialExecutionsOnThisOrderAndBookOneTradePerOrder ->
        let tag = "590=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingUnit.AggregateExecutionsForThisSymbolSideAndSettlementDate ->
        let tag = "590=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPreallocMethod (pos:int) (bs:byte[]) : (int * PreallocMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PreallocMethod.ProRata
        |"1"B -> PreallocMethod.DoNotProRata
        | x -> failwith (sprintf "ReadPreallocMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePreallocMethod (dest:byte array) (nextFreeIdx:int) (xxIn:PreallocMethod) : int =
    match xxIn with
    | PreallocMethod.ProRata ->
        let tag = "591=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PreallocMethod.DoNotProRata ->
        let tag = "591=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingCountryOfIssue (pos:int) (bs:byte[]) : (int*UnderlyingCountryOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCountryOfIssue.UnderlyingCountryOfIssue


let WriteUnderlyingCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCountryOfIssue) : int = 
   let tag = "592="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingStateOrProvinceOfIssue (pos:int) (bs:byte[]) : (int*UnderlyingStateOrProvinceOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingStateOrProvinceOfIssue.UnderlyingStateOrProvinceOfIssue


let WriteUnderlyingStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStateOrProvinceOfIssue) : int = 
   let tag = "593="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingLocaleOfIssue (pos:int) (bs:byte[]) : (int*UnderlyingLocaleOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingLocaleOfIssue.UnderlyingLocaleOfIssue


let WriteUnderlyingLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLocaleOfIssue) : int = 
   let tag = "594="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingInstrRegistry (pos:int) (bs:byte[]) : (int*UnderlyingInstrRegistry) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingInstrRegistry.UnderlyingInstrRegistry


let WriteUnderlyingInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingInstrRegistry) : int = 
   let tag = "595="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCountryOfIssue (pos:int) (bs:byte[]) : (int*LegCountryOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegCountryOfIssue.LegCountryOfIssue


let WriteLegCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegCountryOfIssue) : int = 
   let tag = "596="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegStateOrProvinceOfIssue (pos:int) (bs:byte[]) : (int*LegStateOrProvinceOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegStateOrProvinceOfIssue.LegStateOrProvinceOfIssue


let WriteLegStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegStateOrProvinceOfIssue) : int = 
   let tag = "597="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegLocaleOfIssue (pos:int) (bs:byte[]) : (int*LegLocaleOfIssue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegLocaleOfIssue.LegLocaleOfIssue


let WriteLegLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegLocaleOfIssue) : int = 
   let tag = "598="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegInstrRegistry (pos:int) (bs:byte[]) : (int*LegInstrRegistry) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegInstrRegistry.LegInstrRegistry


let WriteLegInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:LegInstrRegistry) : int = 
   let tag = "599="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSymbol (pos:int) (bs:byte[]) : (int*LegSymbol) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSymbol.LegSymbol


let WriteLegSymbol (dest:byte []) (nextFreeIdx:int) (valIn:LegSymbol) : int = 
   let tag = "600="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSymbolSfx (pos:int) (bs:byte[]) : (int*LegSymbolSfx) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSymbolSfx.LegSymbolSfx


let WriteLegSymbolSfx (dest:byte []) (nextFreeIdx:int) (valIn:LegSymbolSfx) : int = 
   let tag = "601="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityID (pos:int) (bs:byte[]) : (int*LegSecurityID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityID.LegSecurityID


let WriteLegSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityID) : int = 
   let tag = "602="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityIDSource (pos:int) (bs:byte[]) : (int*LegSecurityIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityIDSource.LegSecurityIDSource


let WriteLegSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityIDSource) : int = 
   let tag = "603="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoLegSecurityAltID (pos:int) (bs:byte[]) : (int*NoLegSecurityAltID) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoLegSecurityAltID.NoLegSecurityAltID


let WriteNoLegSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoLegSecurityAltID) : int = 
   let tag = "604="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityAltID (pos:int) (bs:byte[]) : (int*LegSecurityAltID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityAltID.LegSecurityAltID


let WriteLegSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityAltID) : int = 
   let tag = "605="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityAltIDSource (pos:int) (bs:byte[]) : (int*LegSecurityAltIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityAltIDSource.LegSecurityAltIDSource


let WriteLegSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityAltIDSource) : int = 
   let tag = "606="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegProduct (pos:int) (bs:byte[]) : (int*LegProduct) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegProduct.LegProduct


let WriteLegProduct (dest:byte []) (nextFreeIdx:int) (valIn:LegProduct) : int = 
   let tag = "607="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCFICode (pos:int) (bs:byte[]) : (int*LegCFICode) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegCFICode.LegCFICode


let WriteLegCFICode (dest:byte []) (nextFreeIdx:int) (valIn:LegCFICode) : int = 
   let tag = "608="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityType (pos:int) (bs:byte[]) : (int*LegSecurityType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityType.LegSecurityType


let WriteLegSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityType) : int = 
   let tag = "609="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegMaturityMonthYear (pos:int) (bs:byte[]) : (int*LegMaturityMonthYear) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegMaturityMonthYear.LegMaturityMonthYear


let WriteLegMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:LegMaturityMonthYear) : int = 
   let tag = "610="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegMaturityDate (pos:int) (bs:byte[]) : (int*LegMaturityDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegMaturityDate.LegMaturityDate


let WriteLegMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:LegMaturityDate) : int = 
   let tag = "611="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegStrikePrice (pos:int) (bs:byte[]) : (int*LegStrikePrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegStrikePrice.LegStrikePrice


let WriteLegStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:LegStrikePrice) : int = 
   let tag = "612="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegOptAttribute (pos:int) (bs:byte[]) : (int*LegOptAttribute) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegOptAttribute.LegOptAttribute


let WriteLegOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:LegOptAttribute) : int = 
   let tag = "613="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegContractMultiplier (pos:int) (bs:byte[]) : (int*LegContractMultiplier) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegContractMultiplier.LegContractMultiplier


let WriteLegContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:LegContractMultiplier) : int = 
   let tag = "614="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegCouponRate (pos:int) (bs:byte[]) : (int*LegCouponRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegCouponRate.LegCouponRate


let WriteLegCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:LegCouponRate) : int = 
   let tag = "615="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecurityExchange (pos:int) (bs:byte[]) : (int*LegSecurityExchange) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityExchange.LegSecurityExchange


let WriteLegSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityExchange) : int = 
   let tag = "616="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegIssuer (pos:int) (bs:byte[]) : (int*LegIssuer) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegIssuer.LegIssuer


let WriteLegIssuer (dest:byte []) (nextFreeIdx:int) (valIn:LegIssuer) : int = 
   let tag = "617="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedLegIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedLegIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "618="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedLegIssuer (pos:int) (bs:byte[]) : (int * EncodedLegIssuer) =
    ReadLengthStringCompoundField "619"B (pos:int) (bs:byte[]) EncodedLegIssuer.EncodedLegIssuer


let ReadLegSecurityDesc (pos:int) (bs:byte[]) : (int*LegSecurityDesc) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecurityDesc.LegSecurityDesc


let WriteLegSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityDesc) : int = 
   let tag = "620="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedLegSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedLegSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "621="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedLegSecurityDesc (pos:int) (bs:byte[]) : (int * EncodedLegSecurityDesc) =
    ReadLengthStringCompoundField "622"B (pos:int) (bs:byte[]) EncodedLegSecurityDesc.EncodedLegSecurityDesc


let ReadLegRatioQty (pos:int) (bs:byte[]) : (int*LegRatioQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegRatioQty.LegRatioQty


let WriteLegRatioQty (dest:byte []) (nextFreeIdx:int) (valIn:LegRatioQty) : int = 
   let tag = "623="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSide (pos:int) (bs:byte[]) : (int*LegSide) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegSide.LegSide


let WriteLegSide (dest:byte []) (nextFreeIdx:int) (valIn:LegSide) : int = 
   let tag = "624="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradingSessionSubID (pos:int) (bs:byte[]) : (int*TradingSessionSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradingSessionSubID.TradingSessionSubID


let WriteTradingSessionSubID (dest:byte []) (nextFreeIdx:int) (valIn:TradingSessionSubID) : int = 
   let tag = "625="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocType (pos:int) (bs:byte[]) : (int * AllocType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AllocType.Calculated
        |"2"B -> AllocType.Preliminary
        |"5"B -> AllocType.ReadyToBookSingleOrder
        |"7"B -> AllocType.WarehouseInstruction
        |"8"B -> AllocType.RequestToIntermediary
        | x -> failwith (sprintf "ReadAllocType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocType) : int =
    match xxIn with
    | AllocType.Calculated ->
        let tag = "626=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.Preliminary ->
        let tag = "626=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.ReadyToBookSingleOrder ->
        let tag = "626=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.WarehouseInstruction ->
        let tag = "626=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.RequestToIntermediary ->
        let tag = "626=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoHops (pos:int) (bs:byte[]) : (int*NoHops) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoHops.NoHops


let WriteNoHops (dest:byte []) (nextFreeIdx:int) (valIn:NoHops) : int = 
   let tag = "627="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHopCompID (pos:int) (bs:byte[]) : (int*HopCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) HopCompID.HopCompID


let WriteHopCompID (dest:byte []) (nextFreeIdx:int) (valIn:HopCompID) : int = 
   let tag = "628="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHopSendingTime (pos:int) (bs:byte[]) : (int*HopSendingTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) HopSendingTime.HopSendingTime


let WriteHopSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:HopSendingTime) : int = 
   let tag = "629="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadHopRefID (pos:int) (bs:byte[]) : (int*HopRefID) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) HopRefID.HopRefID


let WriteHopRefID (dest:byte []) (nextFreeIdx:int) (valIn:HopRefID) : int = 
   let tag = "630="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMidPx (pos:int) (bs:byte[]) : (int*MidPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MidPx.MidPx


let WriteMidPx (dest:byte []) (nextFreeIdx:int) (valIn:MidPx) : int = 
   let tag = "631="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidYield (pos:int) (bs:byte[]) : (int*BidYield) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidYield.BidYield


let WriteBidYield (dest:byte []) (nextFreeIdx:int) (valIn:BidYield) : int = 
   let tag = "632="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMidYield (pos:int) (bs:byte[]) : (int*MidYield) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MidYield.MidYield


let WriteMidYield (dest:byte []) (nextFreeIdx:int) (valIn:MidYield) : int = 
   let tag = "633="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferYield (pos:int) (bs:byte[]) : (int*OfferYield) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferYield.OfferYield


let WriteOfferYield (dest:byte []) (nextFreeIdx:int) (valIn:OfferYield) : int = 
   let tag = "634="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadClearingFeeIndicator (pos:int) (bs:byte[]) : (int * ClearingFeeIndicator) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"B"B -> ClearingFeeIndicator.CboeMember
        |"C"B -> ClearingFeeIndicator.NonMemberAndCustomer
        |"E"B -> ClearingFeeIndicator.EquityMemberAndClearingMember
        |"F"B -> ClearingFeeIndicator.FullAndAssociateMemberTradingForOwnAccountAndAsFloorBrokers
        |"H"B -> ClearingFeeIndicator.Firms106hAnd106j
        |"I"B -> ClearingFeeIndicator.GimIdemAndComMembershipInterestHolders
        |"L"B -> ClearingFeeIndicator.LesseeAnd106fEmployees
        |"M"B -> ClearingFeeIndicator.AllOtherOwnershipTypes
        | x -> failwith (sprintf "ReadClearingFeeIndicator unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteClearingFeeIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:ClearingFeeIndicator) : int =
    match xxIn with
    | ClearingFeeIndicator.CboeMember ->
        let tag = "635=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.NonMemberAndCustomer ->
        let tag = "635=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.EquityMemberAndClearingMember ->
        let tag = "635=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.FullAndAssociateMemberTradingForOwnAccountAndAsFloorBrokers ->
        let tag = "635=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.Firms106hAnd106j ->
        let tag = "635=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.GimIdemAndComMembershipInterestHolders ->
        let tag = "635=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.LesseeAnd106fEmployees ->
        let tag = "635=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.AllOtherOwnershipTypes ->
        let tag = "635=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWorkingIndicator (pos:int) (bs:byte[]) : (int*WorkingIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) WorkingIndicator.WorkingIndicator


let WriteWorkingIndicator (dest:byte []) (nextFreeIdx:int) (valIn:WorkingIndicator) : int = 
   let tag = "636="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegLastPx (pos:int) (bs:byte[]) : (int*LegLastPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegLastPx.LegLastPx


let WriteLegLastPx (dest:byte []) (nextFreeIdx:int) (valIn:LegLastPx) : int = 
   let tag = "637="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPriorityIndicator (pos:int) (bs:byte[]) : (int * PriorityIndicator) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PriorityIndicator.PriorityUnchanged
        |"1"B -> PriorityIndicator.LostPriorityAsResultOfOrderChange
        | x -> failwith (sprintf "ReadPriorityIndicator unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePriorityIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:PriorityIndicator) : int =
    match xxIn with
    | PriorityIndicator.PriorityUnchanged ->
        let tag = "638=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriorityIndicator.LostPriorityAsResultOfOrderChange ->
        let tag = "638=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPriceImprovement (pos:int) (bs:byte[]) : (int*PriceImprovement) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PriceImprovement.PriceImprovement


let WritePriceImprovement (dest:byte []) (nextFreeIdx:int) (valIn:PriceImprovement) : int = 
   let tag = "639="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPrice2 (pos:int) (bs:byte[]) : (int*Price2) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) Price2.Price2


let WritePrice2 (dest:byte []) (nextFreeIdx:int) (valIn:Price2) : int = 
   let tag = "640="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastForwardPoints2 (pos:int) (bs:byte[]) : (int*LastForwardPoints2) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastForwardPoints2.LastForwardPoints2


let WriteLastForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:LastForwardPoints2) : int = 
   let tag = "641="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBidForwardPoints2 (pos:int) (bs:byte[]) : (int*BidForwardPoints2) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BidForwardPoints2.BidForwardPoints2


let WriteBidForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:BidForwardPoints2) : int = 
   let tag = "642="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOfferForwardPoints2 (pos:int) (bs:byte[]) : (int*OfferForwardPoints2) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OfferForwardPoints2.OfferForwardPoints2


let WriteOfferForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:OfferForwardPoints2) : int = 
   let tag = "643="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRFQReqID (pos:int) (bs:byte[]) : (int*RFQReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RFQReqID.RFQReqID


let WriteRFQReqID (dest:byte []) (nextFreeIdx:int) (valIn:RFQReqID) : int = 
   let tag = "644="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMktBidPx (pos:int) (bs:byte[]) : (int*MktBidPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MktBidPx.MktBidPx


let WriteMktBidPx (dest:byte []) (nextFreeIdx:int) (valIn:MktBidPx) : int = 
   let tag = "645="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMktOfferPx (pos:int) (bs:byte[]) : (int*MktOfferPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MktOfferPx.MktOfferPx


let WriteMktOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:MktOfferPx) : int = 
   let tag = "646="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMinBidSize (pos:int) (bs:byte[]) : (int*MinBidSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MinBidSize.MinBidSize


let WriteMinBidSize (dest:byte []) (nextFreeIdx:int) (valIn:MinBidSize) : int = 
   let tag = "647="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMinOfferSize (pos:int) (bs:byte[]) : (int*MinOfferSize) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MinOfferSize.MinOfferSize


let WriteMinOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:MinOfferSize) : int = 
   let tag = "648="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteStatusReqID (pos:int) (bs:byte[]) : (int*QuoteStatusReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteStatusReqID.QuoteStatusReqID


let WriteQuoteStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteStatusReqID) : int = 
   let tag = "649="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegalConfirm (pos:int) (bs:byte[]) : (int*LegalConfirm) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) LegalConfirm.LegalConfirm


let WriteLegalConfirm (dest:byte []) (nextFreeIdx:int) (valIn:LegalConfirm) : int = 
   let tag = "650="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingLastPx (pos:int) (bs:byte[]) : (int*UnderlyingLastPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingLastPx.UnderlyingLastPx


let WriteUnderlyingLastPx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLastPx) : int = 
   let tag = "651="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingLastQty (pos:int) (bs:byte[]) : (int*UnderlyingLastQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingLastQty.UnderlyingLastQty


let WriteUnderlyingLastQty (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLastQty) : int = 
   let tag = "652="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegRefID (pos:int) (bs:byte[]) : (int*LegRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegRefID.LegRefID


let WriteLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:LegRefID) : int = 
   let tag = "654="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadContraLegRefID (pos:int) (bs:byte[]) : (int*ContraLegRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContraLegRefID.ContraLegRefID


let WriteContraLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:ContraLegRefID) : int = 
   let tag = "655="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrBidFxRate (pos:int) (bs:byte[]) : (int*SettlCurrBidFxRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) SettlCurrBidFxRate.SettlCurrBidFxRate


let WriteSettlCurrBidFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrBidFxRate) : int = 
   let tag = "656="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlCurrOfferFxRate (pos:int) (bs:byte[]) : (int*SettlCurrOfferFxRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) SettlCurrOfferFxRate.SettlCurrOfferFxRate


let WriteSettlCurrOfferFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrOfferFxRate) : int = 
   let tag = "657="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteRequestRejectReason (pos:int) (bs:byte[]) : (int * QuoteRequestRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteRequestRejectReason.UnknownSymbol
        |"2"B -> QuoteRequestRejectReason.ExchangeClosed
        |"3"B -> QuoteRequestRejectReason.QuoteRequestExceedsLimit
        |"4"B -> QuoteRequestRejectReason.TooLateToEnter
        |"5"B -> QuoteRequestRejectReason.InvalidPrice
        |"6"B -> QuoteRequestRejectReason.NotAuthorizedToRequestQuote
        |"7"B -> QuoteRequestRejectReason.NoMatchForInquiry
        |"8"B -> QuoteRequestRejectReason.NoMarketForInstrument
        |"9"B -> QuoteRequestRejectReason.NoInventory
        |"10"B -> QuoteRequestRejectReason.Pass
        |"99"B -> QuoteRequestRejectReason.Other
        | x -> failwith (sprintf "ReadQuoteRequestRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteRequestRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRequestRejectReason) : int =
    match xxIn with
    | QuoteRequestRejectReason.UnknownSymbol ->
        let tag = "658=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.ExchangeClosed ->
        let tag = "658=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.QuoteRequestExceedsLimit ->
        let tag = "658=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.TooLateToEnter ->
        let tag = "658=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.InvalidPrice ->
        let tag = "658=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NotAuthorizedToRequestQuote ->
        let tag = "658=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoMatchForInquiry ->
        let tag = "658=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoMarketForInstrument ->
        let tag = "658=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoInventory ->
        let tag = "658=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.Pass ->
        let tag = "658=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.Other ->
        let tag = "658=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSideComplianceID (pos:int) (bs:byte[]) : (int*SideComplianceID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SideComplianceID.SideComplianceID


let WriteSideComplianceID (dest:byte []) (nextFreeIdx:int) (valIn:SideComplianceID) : int = 
   let tag = "659="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAcctIDSource (pos:int) (bs:byte[]) : (int * AcctIDSource) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AcctIDSource.Bic
        |"2"B -> AcctIDSource.SidCode
        |"3"B -> AcctIDSource.Tfm
        |"4"B -> AcctIDSource.Omgeo
        |"5"B -> AcctIDSource.DtccCode
        |"99"B -> AcctIDSource.Other
        | x -> failwith (sprintf "ReadAcctIDSource unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAcctIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:AcctIDSource) : int =
    match xxIn with
    | AcctIDSource.Bic ->
        let tag = "660=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.SidCode ->
        let tag = "660=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Tfm ->
        let tag = "660=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Omgeo ->
        let tag = "660=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.DtccCode ->
        let tag = "660=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Other ->
        let tag = "660=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocAcctIDSource (pos:int) (bs:byte[]) : (int*AllocAcctIDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllocAcctIDSource.AllocAcctIDSource


let WriteAllocAcctIDSource (dest:byte []) (nextFreeIdx:int) (valIn:AllocAcctIDSource) : int = 
   let tag = "661="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkPrice (pos:int) (bs:byte[]) : (int*BenchmarkPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) BenchmarkPrice.BenchmarkPrice


let WriteBenchmarkPrice (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkPrice) : int = 
   let tag = "662="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkPriceType (pos:int) (bs:byte[]) : (int*BenchmarkPriceType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) BenchmarkPriceType.BenchmarkPriceType


let WriteBenchmarkPriceType (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkPriceType) : int = 
   let tag = "663="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConfirmID (pos:int) (bs:byte[]) : (int*ConfirmID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ConfirmID.ConfirmID


let WriteConfirmID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmID) : int = 
   let tag = "664="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConfirmStatus (pos:int) (bs:byte[]) : (int * ConfirmStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ConfirmStatus.Received
        |"2"B -> ConfirmStatus.MismatchedAccount
        |"3"B -> ConfirmStatus.MissingSettlementInstructions
        |"4"B -> ConfirmStatus.Confirmed
        |"5"B -> ConfirmStatus.RequestRejected
        | x -> failwith (sprintf "ReadConfirmStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteConfirmStatus (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmStatus) : int =
    match xxIn with
    | ConfirmStatus.Received ->
        let tag = "665=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.MismatchedAccount ->
        let tag = "665=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.MissingSettlementInstructions ->
        let tag = "665=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.Confirmed ->
        let tag = "665=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.RequestRejected ->
        let tag = "665=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadConfirmTransType (pos:int) (bs:byte[]) : (int * ConfirmTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ConfirmTransType.New
        |"1"B -> ConfirmTransType.Replace
        |"2"B -> ConfirmTransType.Cancel
        | x -> failwith (sprintf "ReadConfirmTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteConfirmTransType (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmTransType) : int =
    match xxIn with
    | ConfirmTransType.New ->
        let tag = "666=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmTransType.Replace ->
        let tag = "666=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmTransType.Cancel ->
        let tag = "666=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContractSettlMonth (pos:int) (bs:byte[]) : (int*ContractSettlMonth) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ContractSettlMonth.ContractSettlMonth


let WriteContractSettlMonth (dest:byte []) (nextFreeIdx:int) (valIn:ContractSettlMonth) : int = 
   let tag = "667="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeliveryForm (pos:int) (bs:byte[]) : (int * DeliveryForm) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> DeliveryForm.Bookentry
        |"2"B -> DeliveryForm.Bearer
        | x -> failwith (sprintf "ReadDeliveryForm unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDeliveryForm (dest:byte array) (nextFreeIdx:int) (xxIn:DeliveryForm) : int =
    match xxIn with
    | DeliveryForm.Bookentry ->
        let tag = "668=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryForm.Bearer ->
        let tag = "668=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastParPx (pos:int) (bs:byte[]) : (int*LastParPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LastParPx.LastParPx


let WriteLastParPx (dest:byte []) (nextFreeIdx:int) (valIn:LastParPx) : int = 
   let tag = "669="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoLegAllocs (pos:int) (bs:byte[]) : (int*NoLegAllocs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoLegAllocs.NoLegAllocs


let WriteNoLegAllocs (dest:byte []) (nextFreeIdx:int) (valIn:NoLegAllocs) : int = 
   let tag = "670="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegAllocAccount (pos:int) (bs:byte[]) : (int*LegAllocAccount) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegAllocAccount.LegAllocAccount


let WriteLegAllocAccount (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocAccount) : int = 
   let tag = "671="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegIndividualAllocID (pos:int) (bs:byte[]) : (int*LegIndividualAllocID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegIndividualAllocID.LegIndividualAllocID


let WriteLegIndividualAllocID (dest:byte []) (nextFreeIdx:int) (valIn:LegIndividualAllocID) : int = 
   let tag = "672="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegAllocQty (pos:int) (bs:byte[]) : (int*LegAllocQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegAllocQty.LegAllocQty


let WriteLegAllocQty (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocQty) : int = 
   let tag = "673="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegAllocAcctIDSource (pos:int) (bs:byte[]) : (int*LegAllocAcctIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegAllocAcctIDSource.LegAllocAcctIDSource


let WriteLegAllocAcctIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocAcctIDSource) : int = 
   let tag = "674="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSettlCurrency (pos:int) (bs:byte[]) : (int*LegSettlCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSettlCurrency.LegSettlCurrency


let WriteLegSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlCurrency) : int = 
   let tag = "675="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurveCurrency (pos:int) (bs:byte[]) : (int*LegBenchmarkCurveCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegBenchmarkCurveCurrency.LegBenchmarkCurveCurrency


let WriteLegBenchmarkCurveCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurveCurrency) : int = 
   let tag = "676="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurveName (pos:int) (bs:byte[]) : (int*LegBenchmarkCurveName) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegBenchmarkCurveName.LegBenchmarkCurveName


let WriteLegBenchmarkCurveName (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurveName) : int = 
   let tag = "677="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurvePoint (pos:int) (bs:byte[]) : (int*LegBenchmarkCurvePoint) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegBenchmarkCurvePoint.LegBenchmarkCurvePoint


let WriteLegBenchmarkCurvePoint (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurvePoint) : int = 
   let tag = "678="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBenchmarkPrice (pos:int) (bs:byte[]) : (int*LegBenchmarkPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegBenchmarkPrice.LegBenchmarkPrice


let WriteLegBenchmarkPrice (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkPrice) : int = 
   let tag = "679="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBenchmarkPriceType (pos:int) (bs:byte[]) : (int*LegBenchmarkPriceType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegBenchmarkPriceType.LegBenchmarkPriceType


let WriteLegBenchmarkPriceType (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkPriceType) : int = 
   let tag = "680="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegBidPx (pos:int) (bs:byte[]) : (int*LegBidPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegBidPx.LegBidPx


let WriteLegBidPx (dest:byte []) (nextFreeIdx:int) (valIn:LegBidPx) : int = 
   let tag = "681="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegIOIQty (pos:int) (bs:byte[]) : (int*LegIOIQty) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegIOIQty.LegIOIQty


let WriteLegIOIQty (dest:byte []) (nextFreeIdx:int) (valIn:LegIOIQty) : int = 
   let tag = "682="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoLegStipulations (pos:int) (bs:byte[]) : (int*NoLegStipulations) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoLegStipulations.NoLegStipulations


let WriteNoLegStipulations (dest:byte []) (nextFreeIdx:int) (valIn:NoLegStipulations) : int = 
   let tag = "683="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegOfferPx (pos:int) (bs:byte[]) : (int*LegOfferPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegOfferPx.LegOfferPx


let WriteLegOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:LegOfferPx) : int = 
   let tag = "684="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegOrderQty (pos:int) (bs:byte[]) : (int*LegOrderQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegOrderQty.LegOrderQty


let WriteLegOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:LegOrderQty) : int = 
   let tag = "685="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegPriceType (pos:int) (bs:byte[]) : (int*LegPriceType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) LegPriceType.LegPriceType


let WriteLegPriceType (dest:byte []) (nextFreeIdx:int) (valIn:LegPriceType) : int = 
   let tag = "686="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegQty (pos:int) (bs:byte[]) : (int*LegQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LegQty.LegQty


let WriteLegQty (dest:byte []) (nextFreeIdx:int) (valIn:LegQty) : int = 
   let tag = "687="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegStipulationType (pos:int) (bs:byte[]) : (int*LegStipulationType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegStipulationType.LegStipulationType


let WriteLegStipulationType (dest:byte []) (nextFreeIdx:int) (valIn:LegStipulationType) : int = 
   let tag = "688="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegStipulationValue (pos:int) (bs:byte[]) : (int*LegStipulationValue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegStipulationValue.LegStipulationValue


let WriteLegStipulationValue (dest:byte []) (nextFreeIdx:int) (valIn:LegStipulationValue) : int = 
   let tag = "689="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSwapType (pos:int) (bs:byte[]) : (int * LegSwapType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> LegSwapType.ParForPar
        |"2"B -> LegSwapType.ModifiedDuration
        |"4"B -> LegSwapType.Risk
        |"5"B -> LegSwapType.Proceeds
        | x -> failwith (sprintf "ReadLegSwapType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteLegSwapType (dest:byte array) (nextFreeIdx:int) (xxIn:LegSwapType) : int =
    match xxIn with
    | LegSwapType.ParForPar ->
        let tag = "690=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.ModifiedDuration ->
        let tag = "690=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.Risk ->
        let tag = "690=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.Proceeds ->
        let tag = "690=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPool (pos:int) (bs:byte[]) : (int*Pool) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Pool.Pool


let WritePool (dest:byte []) (nextFreeIdx:int) (valIn:Pool) : int = 
   let tag = "691="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuotePriceType (pos:int) (bs:byte[]) : (int * QuotePriceType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuotePriceType.Percent
        |"2"B -> QuotePriceType.PerShare
        |"3"B -> QuotePriceType.FixedAmount
        |"4"B -> QuotePriceType.Discount
        |"5"B -> QuotePriceType.Premium
        |"6"B -> QuotePriceType.BasisPointsRelativeToBenchmark
        |"7"B -> QuotePriceType.TedPrice
        |"8"B -> QuotePriceType.TedYield
        |"9"B -> QuotePriceType.YieldSpread
        |"10"B -> QuotePriceType.Yield
        | x -> failwith (sprintf "ReadQuotePriceType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuotePriceType (dest:byte array) (nextFreeIdx:int) (xxIn:QuotePriceType) : int =
    match xxIn with
    | QuotePriceType.Percent ->
        let tag = "692=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.PerShare ->
        let tag = "692=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.FixedAmount ->
        let tag = "692=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Discount ->
        let tag = "692=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Premium ->
        let tag = "692=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.BasisPointsRelativeToBenchmark ->
        let tag = "692=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.TedPrice ->
        let tag = "692=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.TedYield ->
        let tag = "692=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.YieldSpread ->
        let tag = "692=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Yield ->
        let tag = "692=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteRespID (pos:int) (bs:byte[]) : (int*QuoteRespID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) QuoteRespID.QuoteRespID


let WriteQuoteRespID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteRespID) : int = 
   let tag = "693="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadQuoteRespType (pos:int) (bs:byte[]) : (int * QuoteRespType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> QuoteRespType.HitLift
        |"2"B -> QuoteRespType.Counter
        |"3"B -> QuoteRespType.Expired
        |"4"B -> QuoteRespType.Cover
        |"5"B -> QuoteRespType.DoneAway
        |"6"B -> QuoteRespType.Pass
        | x -> failwith (sprintf "ReadQuoteRespType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQuoteRespType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRespType) : int =
    match xxIn with
    | QuoteRespType.HitLift ->
        let tag = "694=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Counter ->
        let tag = "694=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Expired ->
        let tag = "694=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Cover ->
        let tag = "694=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.DoneAway ->
        let tag = "694=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Pass ->
        let tag = "694=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteQualifier (pos:int) (bs:byte[]) : (int*QuoteQualifier) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) QuoteQualifier.QuoteQualifier


let WriteQuoteQualifier (dest:byte []) (nextFreeIdx:int) (valIn:QuoteQualifier) : int = 
   let tag = "695="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadYieldRedemptionDate (pos:int) (bs:byte[]) : (int*YieldRedemptionDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) YieldRedemptionDate.YieldRedemptionDate


let WriteYieldRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionDate) : int = 
   let tag = "696="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadYieldRedemptionPrice (pos:int) (bs:byte[]) : (int*YieldRedemptionPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) YieldRedemptionPrice.YieldRedemptionPrice


let WriteYieldRedemptionPrice (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionPrice) : int = 
   let tag = "697="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadYieldRedemptionPriceType (pos:int) (bs:byte[]) : (int*YieldRedemptionPriceType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) YieldRedemptionPriceType.YieldRedemptionPriceType


let WriteYieldRedemptionPriceType (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionPriceType) : int = 
   let tag = "698="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkSecurityID (pos:int) (bs:byte[]) : (int*BenchmarkSecurityID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BenchmarkSecurityID.BenchmarkSecurityID


let WriteBenchmarkSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkSecurityID) : int = 
   let tag = "699="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadReversalIndicator (pos:int) (bs:byte[]) : (int*ReversalIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ReversalIndicator.ReversalIndicator


let WriteReversalIndicator (dest:byte []) (nextFreeIdx:int) (valIn:ReversalIndicator) : int = 
   let tag = "700="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadYieldCalcDate (pos:int) (bs:byte[]) : (int*YieldCalcDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) YieldCalcDate.YieldCalcDate


let WriteYieldCalcDate (dest:byte []) (nextFreeIdx:int) (valIn:YieldCalcDate) : int = 
   let tag = "701="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoPositions (pos:int) (bs:byte[]) : (int*NoPositions) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoPositions.NoPositions


let WriteNoPositions (dest:byte []) (nextFreeIdx:int) (valIn:NoPositions) : int = 
   let tag = "702="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosType (pos:int) (bs:byte[]) : (int * PosType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"TQ"B -> PosType.TransactionQuantity
        |"IAS"B -> PosType.IntraSpreadQty
        |"IES"B -> PosType.InterSpreadQty
        |"FIN"B -> PosType.EndOfDayQty
        |"SOD"B -> PosType.StartOfDayQty
        |"EX"B -> PosType.OptionExerciseQty
        |"AS"B -> PosType.OptionAssignment
        |"TX"B -> PosType.TransactionFromExercise
        |"TA"B -> PosType.TransactionFromAssignment
        |"PIT"B -> PosType.PitTradeQty
        |"TRF"B -> PosType.TransferTradeQty
        |"ETR"B -> PosType.ElectronicTradeQty
        |"ALC"B -> PosType.AllocationTradeQty
        |"PA"B -> PosType.AdjustmentQty
        |"ASF"B -> PosType.AsOfTradeQty
        |"DLV"B -> PosType.DeliveryQty
        |"TOT"B -> PosType.TotalTransactionQty
        |"XM"B -> PosType.CrossMarginQty
        |"SPL"B -> PosType.IntegralSplit
        | x -> failwith (sprintf "ReadPosType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosType (dest:byte array) (nextFreeIdx:int) (xxIn:PosType) : int =
    match xxIn with
    | PosType.TransactionQuantity ->
        let tag = "703=TQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.IntraSpreadQty ->
        let tag = "703=IAS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.InterSpreadQty ->
        let tag = "703=IES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.EndOfDayQty ->
        let tag = "703=FIN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.StartOfDayQty ->
        let tag = "703=SOD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.OptionExerciseQty ->
        let tag = "703=EX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.OptionAssignment ->
        let tag = "703=AS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransactionFromExercise ->
        let tag = "703=TX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransactionFromAssignment ->
        let tag = "703=TA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.PitTradeQty ->
        let tag = "703=PIT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransferTradeQty ->
        let tag = "703=TRF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.ElectronicTradeQty ->
        let tag = "703=ETR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AllocationTradeQty ->
        let tag = "703=ALC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AdjustmentQty ->
        let tag = "703=PA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AsOfTradeQty ->
        let tag = "703=ASF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.DeliveryQty ->
        let tag = "703=DLV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TotalTransactionQty ->
        let tag = "703=TOT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.CrossMarginQty ->
        let tag = "703=XM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.IntegralSplit ->
        let tag = "703=SPL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLongQty (pos:int) (bs:byte[]) : (int*LongQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) LongQty.LongQty


let WriteLongQty (dest:byte []) (nextFreeIdx:int) (valIn:LongQty) : int = 
   let tag = "704="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadShortQty (pos:int) (bs:byte[]) : (int*ShortQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ShortQty.ShortQty


let WriteShortQty (dest:byte []) (nextFreeIdx:int) (valIn:ShortQty) : int = 
   let tag = "705="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosQtyStatus (pos:int) (bs:byte[]) : (int * PosQtyStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosQtyStatus.Submitted
        |"1"B -> PosQtyStatus.Accepted
        |"2"B -> PosQtyStatus.Rejected
        | x -> failwith (sprintf "ReadPosQtyStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosQtyStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosQtyStatus) : int =
    match xxIn with
    | PosQtyStatus.Submitted ->
        let tag = "706=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosQtyStatus.Accepted ->
        let tag = "706=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosQtyStatus.Rejected ->
        let tag = "706=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosAmtType (pos:int) (bs:byte[]) : (int * PosAmtType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"FMTM"B -> PosAmtType.FinalMarkToMarketAmount
        |"IMTM"B -> PosAmtType.IncrementalMarkToMarketAmount
        |"TVAR"B -> PosAmtType.TradeVariationAmount
        |"SMTM"B -> PosAmtType.StartOfDayMarkToMarketAmount
        |"PREM"B -> PosAmtType.PremiumAmount
        |"CRES"B -> PosAmtType.CashResidualAmount
        |"CASH"B -> PosAmtType.CashAmount
        |"VADJ"B -> PosAmtType.ValueAdjustedAmount
        | x -> failwith (sprintf "ReadPosAmtType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosAmtType (dest:byte array) (nextFreeIdx:int) (xxIn:PosAmtType) : int =
    match xxIn with
    | PosAmtType.FinalMarkToMarketAmount ->
        let tag = "707=FMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.IncrementalMarkToMarketAmount ->
        let tag = "707=IMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.TradeVariationAmount ->
        let tag = "707=TVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.StartOfDayMarkToMarketAmount ->
        let tag = "707=SMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.PremiumAmount ->
        let tag = "707=PREM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.CashResidualAmount ->
        let tag = "707=CRES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.CashAmount ->
        let tag = "707=CASH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.ValueAdjustedAmount ->
        let tag = "707=VADJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosAmt (pos:int) (bs:byte[]) : (int*PosAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) PosAmt.PosAmt


let WritePosAmt (dest:byte []) (nextFreeIdx:int) (valIn:PosAmt) : int = 
   let tag = "708="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosTransType (pos:int) (bs:byte[]) : (int * PosTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PosTransType.Exercise
        |"2"B -> PosTransType.DoNotExercise
        |"3"B -> PosTransType.PositionAdjustment
        |"4"B -> PosTransType.PositionChangeSubmissionMarginDisposition
        |"5"B -> PosTransType.Pledge
        | x -> failwith (sprintf "ReadPosTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosTransType (dest:byte array) (nextFreeIdx:int) (xxIn:PosTransType) : int =
    match xxIn with
    | PosTransType.Exercise ->
        let tag = "709=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.DoNotExercise ->
        let tag = "709=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.PositionAdjustment ->
        let tag = "709=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.PositionChangeSubmissionMarginDisposition ->
        let tag = "709=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.Pledge ->
        let tag = "709=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqID (pos:int) (bs:byte[]) : (int*PosReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PosReqID.PosReqID


let WritePosReqID (dest:byte []) (nextFreeIdx:int) (valIn:PosReqID) : int = 
   let tag = "710="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoUnderlyings (pos:int) (bs:byte[]) : (int*NoUnderlyings) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoUnderlyings.NoUnderlyings


let WriteNoUnderlyings (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyings) : int = 
   let tag = "711="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosMaintAction (pos:int) (bs:byte[]) : (int * PosMaintAction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PosMaintAction.New
        |"2"B -> PosMaintAction.Replace
        |"3"B -> PosMaintAction.Cancel
        | x -> failwith (sprintf "ReadPosMaintAction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosMaintAction (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintAction) : int =
    match xxIn with
    | PosMaintAction.New ->
        let tag = "712=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintAction.Replace ->
        let tag = "712=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintAction.Cancel ->
        let tag = "712=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigPosReqRefID (pos:int) (bs:byte[]) : (int*OrigPosReqRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrigPosReqRefID.OrigPosReqRefID


let WriteOrigPosReqRefID (dest:byte []) (nextFreeIdx:int) (valIn:OrigPosReqRefID) : int = 
   let tag = "713="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosMaintRptRefID (pos:int) (bs:byte[]) : (int*PosMaintRptRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PosMaintRptRefID.PosMaintRptRefID


let WritePosMaintRptRefID (dest:byte []) (nextFreeIdx:int) (valIn:PosMaintRptRefID) : int = 
   let tag = "714="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadClearingBusinessDate (pos:int) (bs:byte[]) : (int*ClearingBusinessDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ClearingBusinessDate.ClearingBusinessDate


let WriteClearingBusinessDate (dest:byte []) (nextFreeIdx:int) (valIn:ClearingBusinessDate) : int = 
   let tag = "715="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlSessID (pos:int) (bs:byte[]) : (int*SettlSessID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlSessID.SettlSessID


let WriteSettlSessID (dest:byte []) (nextFreeIdx:int) (valIn:SettlSessID) : int = 
   let tag = "716="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlSessSubID (pos:int) (bs:byte[]) : (int*SettlSessSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlSessSubID.SettlSessSubID


let WriteSettlSessSubID (dest:byte []) (nextFreeIdx:int) (valIn:SettlSessSubID) : int = 
   let tag = "717="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAdjustmentType (pos:int) (bs:byte[]) : (int * AdjustmentType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AdjustmentType.ProcessRequestAsMarginDisposition
        |"1"B -> AdjustmentType.DeltaPlus
        |"2"B -> AdjustmentType.DeltaMinus
        |"3"B -> AdjustmentType.Final
        | x -> failwith (sprintf "ReadAdjustmentType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAdjustmentType (dest:byte array) (nextFreeIdx:int) (xxIn:AdjustmentType) : int =
    match xxIn with
    | AdjustmentType.ProcessRequestAsMarginDisposition ->
        let tag = "718=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.DeltaPlus ->
        let tag = "718=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.DeltaMinus ->
        let tag = "718=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.Final ->
        let tag = "718=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContraryInstructionIndicator (pos:int) (bs:byte[]) : (int*ContraryInstructionIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) ContraryInstructionIndicator.ContraryInstructionIndicator


let WriteContraryInstructionIndicator (dest:byte []) (nextFreeIdx:int) (valIn:ContraryInstructionIndicator) : int = 
   let tag = "719="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPriorSpreadIndicator (pos:int) (bs:byte[]) : (int*PriorSpreadIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) PriorSpreadIndicator.PriorSpreadIndicator


let WritePriorSpreadIndicator (dest:byte []) (nextFreeIdx:int) (valIn:PriorSpreadIndicator) : int = 
   let tag = "720="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosMaintRptID (pos:int) (bs:byte[]) : (int*PosMaintRptID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) PosMaintRptID.PosMaintRptID


let WritePosMaintRptID (dest:byte []) (nextFreeIdx:int) (valIn:PosMaintRptID) : int = 
   let tag = "721="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosMaintStatus (pos:int) (bs:byte[]) : (int * PosMaintStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosMaintStatus.Accepted
        |"1"B -> PosMaintStatus.AcceptedWithWarnings
        |"2"B -> PosMaintStatus.Rejected
        |"3"B -> PosMaintStatus.Completed
        |"4"B -> PosMaintStatus.CompletedWithWarnings
        | x -> failwith (sprintf "ReadPosMaintStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosMaintStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintStatus) : int =
    match xxIn with
    | PosMaintStatus.Accepted ->
        let tag = "722=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.AcceptedWithWarnings ->
        let tag = "722=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.Rejected ->
        let tag = "722=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.Completed ->
        let tag = "722=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.CompletedWithWarnings ->
        let tag = "722=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosMaintResult (pos:int) (bs:byte[]) : (int * PosMaintResult) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosMaintResult.SuccessfulCompletionNoWarningsOrErrors
        |"1"B -> PosMaintResult.Rejected
        |"99"B -> PosMaintResult.Other
        | x -> failwith (sprintf "ReadPosMaintResult unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosMaintResult (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintResult) : int =
    match xxIn with
    | PosMaintResult.SuccessfulCompletionNoWarningsOrErrors ->
        let tag = "723=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintResult.Rejected ->
        let tag = "723=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintResult.Other ->
        let tag = "723=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqType (pos:int) (bs:byte[]) : (int * PosReqType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosReqType.Positions
        |"1"B -> PosReqType.Trades
        |"2"B -> PosReqType.Exercises
        |"3"B -> PosReqType.Assignments
        | x -> failwith (sprintf "ReadPosReqType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosReqType (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqType) : int =
    match xxIn with
    | PosReqType.Positions ->
        let tag = "724=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Trades ->
        let tag = "724=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Exercises ->
        let tag = "724=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Assignments ->
        let tag = "724=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadResponseTransportType (pos:int) (bs:byte[]) : (int * ResponseTransportType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ResponseTransportType.Inband
        |"1"B -> ResponseTransportType.OutOfBand
        | x -> failwith (sprintf "ReadResponseTransportType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteResponseTransportType (dest:byte array) (nextFreeIdx:int) (xxIn:ResponseTransportType) : int =
    match xxIn with
    | ResponseTransportType.Inband ->
        let tag = "725=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ResponseTransportType.OutOfBand ->
        let tag = "725=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadResponseDestination (pos:int) (bs:byte[]) : (int*ResponseDestination) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ResponseDestination.ResponseDestination


let WriteResponseDestination (dest:byte []) (nextFreeIdx:int) (valIn:ResponseDestination) : int = 
   let tag = "726="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotalNumPosReports (pos:int) (bs:byte[]) : (int*TotalNumPosReports) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotalNumPosReports.TotalNumPosReports


let WriteTotalNumPosReports (dest:byte []) (nextFreeIdx:int) (valIn:TotalNumPosReports) : int = 
   let tag = "727="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPosReqResult (pos:int) (bs:byte[]) : (int * PosReqResult) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosReqResult.ValidRequest
        |"1"B -> PosReqResult.InvalidOrUnsupportedRequest
        |"2"B -> PosReqResult.NoPositionsFoundThatMatchCriteria
        |"3"B -> PosReqResult.NotAuthorizedToRequestPositions
        |"4"B -> PosReqResult.RequestForPositionNotSupported
        |"99"B -> PosReqResult.Other
        | x -> failwith (sprintf "ReadPosReqResult unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosReqResult (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqResult) : int =
    match xxIn with
    | PosReqResult.ValidRequest ->
        let tag = "728=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.InvalidOrUnsupportedRequest ->
        let tag = "728=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.NoPositionsFoundThatMatchCriteria ->
        let tag = "728=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.NotAuthorizedToRequestPositions ->
        let tag = "728=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.RequestForPositionNotSupported ->
        let tag = "728=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.Other ->
        let tag = "728=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqStatus (pos:int) (bs:byte[]) : (int * PosReqStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PosReqStatus.Completed
        |"1"B -> PosReqStatus.CompletedWithWarnings
        |"2"B -> PosReqStatus.Rejected
        | x -> failwith (sprintf "ReadPosReqStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePosReqStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqStatus) : int =
    match xxIn with
    | PosReqStatus.Completed ->
        let tag = "729=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqStatus.CompletedWithWarnings ->
        let tag = "729=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqStatus.Rejected ->
        let tag = "729=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSettlPrice (pos:int) (bs:byte[]) : (int*SettlPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) SettlPrice.SettlPrice


let WriteSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:SettlPrice) : int = 
   let tag = "730="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPriceType (pos:int) (bs:byte[]) : (int * SettlPriceType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SettlPriceType.Final
        |"2"B -> SettlPriceType.Theoretical
        | x -> failwith (sprintf "ReadSettlPriceType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlPriceType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlPriceType) : int =
    match xxIn with
    | SettlPriceType.Final ->
        let tag = "731=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlPriceType.Theoretical ->
        let tag = "731=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingSettlPrice (pos:int) (bs:byte[]) : (int*UnderlyingSettlPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingSettlPrice.UnderlyingSettlPrice


let WriteUnderlyingSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSettlPrice) : int = 
   let tag = "732="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSettlPriceType (pos:int) (bs:byte[]) : (int*UnderlyingSettlPriceType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingSettlPriceType.UnderlyingSettlPriceType


let WriteUnderlyingSettlPriceType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSettlPriceType) : int = 
   let tag = "733="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPriorSettlPrice (pos:int) (bs:byte[]) : (int*PriorSettlPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PriorSettlPrice.PriorSettlPrice


let WritePriorSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:PriorSettlPrice) : int = 
   let tag = "734="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoQuoteQualifiers (pos:int) (bs:byte[]) : (int*NoQuoteQualifiers) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoQuoteQualifiers.NoQuoteQualifiers


let WriteNoQuoteQualifiers (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteQualifiers) : int = 
   let tag = "735="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocSettlCurrency (pos:int) (bs:byte[]) : (int*AllocSettlCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocSettlCurrency.AllocSettlCurrency


let WriteAllocSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:AllocSettlCurrency) : int = 
   let tag = "736="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocSettlCurrAmt (pos:int) (bs:byte[]) : (int*AllocSettlCurrAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllocSettlCurrAmt.AllocSettlCurrAmt


let WriteAllocSettlCurrAmt (dest:byte []) (nextFreeIdx:int) (valIn:AllocSettlCurrAmt) : int = 
   let tag = "737="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadInterestAtMaturity (pos:int) (bs:byte[]) : (int*InterestAtMaturity) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) InterestAtMaturity.InterestAtMaturity


let WriteInterestAtMaturity (dest:byte []) (nextFreeIdx:int) (valIn:InterestAtMaturity) : int = 
   let tag = "738="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegDatedDate (pos:int) (bs:byte[]) : (int*LegDatedDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegDatedDate.LegDatedDate


let WriteLegDatedDate (dest:byte []) (nextFreeIdx:int) (valIn:LegDatedDate) : int = 
   let tag = "739="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegPool (pos:int) (bs:byte[]) : (int*LegPool) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegPool.LegPool


let WriteLegPool (dest:byte []) (nextFreeIdx:int) (valIn:LegPool) : int = 
   let tag = "740="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocInterestAtMaturity (pos:int) (bs:byte[]) : (int*AllocInterestAtMaturity) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllocInterestAtMaturity.AllocInterestAtMaturity


let WriteAllocInterestAtMaturity (dest:byte []) (nextFreeIdx:int) (valIn:AllocInterestAtMaturity) : int = 
   let tag = "741="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocAccruedInterestAmt (pos:int) (bs:byte[]) : (int*AllocAccruedInterestAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllocAccruedInterestAmt.AllocAccruedInterestAmt


let WriteAllocAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:AllocAccruedInterestAmt) : int = 
   let tag = "742="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeliveryDate (pos:int) (bs:byte[]) : (int*DeliveryDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DeliveryDate.DeliveryDate


let WriteDeliveryDate (dest:byte []) (nextFreeIdx:int) (valIn:DeliveryDate) : int = 
   let tag = "743="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAssignmentMethod (pos:int) (bs:byte[]) : (int * AssignmentMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"R"B -> AssignmentMethod.Random
        |"P"B -> AssignmentMethod.Prorata
        | x -> failwith (sprintf "ReadAssignmentMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAssignmentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:AssignmentMethod) : int =
    match xxIn with
    | AssignmentMethod.Random ->
        let tag = "744=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AssignmentMethod.Prorata ->
        let tag = "744=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAssignmentUnit (pos:int) (bs:byte[]) : (int*AssignmentUnit) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AssignmentUnit.AssignmentUnit


let WriteAssignmentUnit (dest:byte []) (nextFreeIdx:int) (valIn:AssignmentUnit) : int = 
   let tag = "745="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOpenInterest (pos:int) (bs:byte[]) : (int*OpenInterest) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) OpenInterest.OpenInterest


let WriteOpenInterest (dest:byte []) (nextFreeIdx:int) (valIn:OpenInterest) : int = 
   let tag = "746="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExerciseMethod (pos:int) (bs:byte[]) : (int * ExerciseMethod) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"A"B -> ExerciseMethod.Automatic
        |"M"B -> ExerciseMethod.Manual
        | x -> failwith (sprintf "ReadExerciseMethod unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExerciseMethod (dest:byte array) (nextFreeIdx:int) (xxIn:ExerciseMethod) : int =
    match xxIn with
    | ExerciseMethod.Automatic ->
        let tag = "747=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExerciseMethod.Manual ->
        let tag = "747=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNumTradeReports (pos:int) (bs:byte[]) : (int*TotNumTradeReports) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNumTradeReports.TotNumTradeReports


let WriteTotNumTradeReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumTradeReports) : int = 
   let tag = "748="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeRequestResult (pos:int) (bs:byte[]) : (int * TradeRequestResult) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeRequestResult.Successful
        |"1"B -> TradeRequestResult.InvalidOrUnknownInstrument
        |"2"B -> TradeRequestResult.InvalidTypeOfTradeRequested
        |"3"B -> TradeRequestResult.InvalidParties
        |"4"B -> TradeRequestResult.InvalidTransportTypeRequested
        |"5"B -> TradeRequestResult.InvalidDestinationRequested
        |"8"B -> TradeRequestResult.TraderequesttypeNotSupported
        |"9"B -> TradeRequestResult.UnauthorizedForTradeCaptureReportRequest
        |"10"B -> TradeRequestResult.Yield
        | x -> failwith (sprintf "ReadTradeRequestResult unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeRequestResult (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestResult) : int =
    match xxIn with
    | TradeRequestResult.Successful ->
        let tag = "749=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidOrUnknownInstrument ->
        let tag = "749=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidTypeOfTradeRequested ->
        let tag = "749=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidParties ->
        let tag = "749=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidTransportTypeRequested ->
        let tag = "749=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidDestinationRequested ->
        let tag = "749=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.TraderequesttypeNotSupported ->
        let tag = "749=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.UnauthorizedForTradeCaptureReportRequest ->
        let tag = "749=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.Yield ->
        let tag = "749=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeRequestStatus (pos:int) (bs:byte[]) : (int * TradeRequestStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeRequestStatus.Accepted
        |"1"B -> TradeRequestStatus.Completed
        |"2"B -> TradeRequestStatus.Rejected
        | x -> failwith (sprintf "ReadTradeRequestStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeRequestStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestStatus) : int =
    match xxIn with
    | TradeRequestStatus.Accepted ->
        let tag = "750=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestStatus.Completed ->
        let tag = "750=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestStatus.Rejected ->
        let tag = "750=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeReportRejectReason (pos:int) (bs:byte[]) : (int * TradeReportRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeReportRejectReason.Successful
        |"1"B -> TradeReportRejectReason.InvalidPartyInformation
        |"2"B -> TradeReportRejectReason.UnknownInstrument
        |"3"B -> TradeReportRejectReason.UnauthorizedToReportTrades
        |"4"B -> TradeReportRejectReason.InvalidTradeType
        |"10"B -> TradeReportRejectReason.Yield
        | x -> failwith (sprintf "ReadTradeReportRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeReportRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportRejectReason) : int =
    match xxIn with
    | TradeReportRejectReason.Successful ->
        let tag = "751=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.InvalidPartyInformation ->
        let tag = "751=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.UnknownInstrument ->
        let tag = "751=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.UnauthorizedToReportTrades ->
        let tag = "751=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.InvalidTradeType ->
        let tag = "751=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.Yield ->
        let tag = "751=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSideMultiLegReportingType (pos:int) (bs:byte[]) : (int * SideMultiLegReportingType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> SideMultiLegReportingType.SingleSecurity
        |"2"B -> SideMultiLegReportingType.IndividualLegOfAMultiLegSecurity
        |"3"B -> SideMultiLegReportingType.MultiLegSecurity
        | x -> failwith (sprintf "ReadSideMultiLegReportingType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSideMultiLegReportingType (dest:byte array) (nextFreeIdx:int) (xxIn:SideMultiLegReportingType) : int =
    match xxIn with
    | SideMultiLegReportingType.SingleSecurity ->
        let tag = "752=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideMultiLegReportingType.IndividualLegOfAMultiLegSecurity ->
        let tag = "752=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideMultiLegReportingType.MultiLegSecurity ->
        let tag = "752=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoPosAmt (pos:int) (bs:byte[]) : (int*NoPosAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoPosAmt.NoPosAmt


let WriteNoPosAmt (dest:byte []) (nextFreeIdx:int) (valIn:NoPosAmt) : int = 
   let tag = "753="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAutoAcceptIndicator (pos:int) (bs:byte[]) : (int*AutoAcceptIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) AutoAcceptIndicator.AutoAcceptIndicator


let WriteAutoAcceptIndicator (dest:byte []) (nextFreeIdx:int) (valIn:AutoAcceptIndicator) : int = 
   let tag = "754="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocReportID (pos:int) (bs:byte[]) : (int*AllocReportID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocReportID.AllocReportID


let WriteAllocReportID (dest:byte []) (nextFreeIdx:int) (valIn:AllocReportID) : int = 
   let tag = "755="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNested2PartyIDs (pos:int) (bs:byte[]) : (int*NoNested2PartyIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNested2PartyIDs.NoNested2PartyIDs


let WriteNoNested2PartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested2PartyIDs) : int = 
   let tag = "756="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested2PartyID (pos:int) (bs:byte[]) : (int*Nested2PartyID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Nested2PartyID.Nested2PartyID


let WriteNested2PartyID (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyID) : int = 
   let tag = "757="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested2PartyIDSource (pos:int) (bs:byte[]) : (int*Nested2PartyIDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested2PartyIDSource.Nested2PartyIDSource


let WriteNested2PartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyIDSource) : int = 
   let tag = "758="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested2PartyRole (pos:int) (bs:byte[]) : (int*Nested2PartyRole) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested2PartyRole.Nested2PartyRole


let WriteNested2PartyRole (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyRole) : int = 
   let tag = "759="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested2PartySubID (pos:int) (bs:byte[]) : (int*Nested2PartySubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Nested2PartySubID.Nested2PartySubID


let WriteNested2PartySubID (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartySubID) : int = 
   let tag = "760="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadBenchmarkSecurityIDSource (pos:int) (bs:byte[]) : (int*BenchmarkSecurityIDSource) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) BenchmarkSecurityIDSource.BenchmarkSecurityIDSource


let WriteBenchmarkSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkSecurityIDSource) : int = 
   let tag = "761="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecuritySubType (pos:int) (bs:byte[]) : (int*SecuritySubType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecuritySubType.SecuritySubType


let WriteSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:SecuritySubType) : int = 
   let tag = "762="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingSecuritySubType (pos:int) (bs:byte[]) : (int*UnderlyingSecuritySubType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingSecuritySubType.UnderlyingSecuritySubType


let WriteUnderlyingSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecuritySubType) : int = 
   let tag = "763="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegSecuritySubType (pos:int) (bs:byte[]) : (int*LegSecuritySubType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegSecuritySubType.LegSecuritySubType


let WriteLegSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:LegSecuritySubType) : int = 
   let tag = "764="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessPct (pos:int) (bs:byte[]) : (int*AllowableOneSidednessPct) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AllowableOneSidednessPct.AllowableOneSidednessPct


let WriteAllowableOneSidednessPct (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessPct) : int = 
   let tag = "765="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessValue (pos:int) (bs:byte[]) : (int*AllowableOneSidednessValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) AllowableOneSidednessValue.AllowableOneSidednessValue


let WriteAllowableOneSidednessValue (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessValue) : int = 
   let tag = "766="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessCurr (pos:int) (bs:byte[]) : (int*AllowableOneSidednessCurr) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllowableOneSidednessCurr.AllowableOneSidednessCurr


let WriteAllowableOneSidednessCurr (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessCurr) : int = 
   let tag = "767="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoTrdRegTimestamps (pos:int) (bs:byte[]) : (int*NoTrdRegTimestamps) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoTrdRegTimestamps.NoTrdRegTimestamps


let WriteNoTrdRegTimestamps (dest:byte []) (nextFreeIdx:int) (valIn:NoTrdRegTimestamps) : int = 
   let tag = "768="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTrdRegTimestamp (pos:int) (bs:byte[]) : (int*TrdRegTimestamp) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TrdRegTimestamp.TrdRegTimestamp


let WriteTrdRegTimestamp (dest:byte []) (nextFreeIdx:int) (valIn:TrdRegTimestamp) : int = 
   let tag = "769="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTrdRegTimestampType (pos:int) (bs:byte[]) : (int * TrdRegTimestampType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> TrdRegTimestampType.ExecutionTime
        |"2"B -> TrdRegTimestampType.TimeIn
        |"3"B -> TrdRegTimestampType.TimeOut
        |"4"B -> TrdRegTimestampType.BrokerReceipt
        |"5"B -> TrdRegTimestampType.BrokerExecution
        | x -> failwith (sprintf "ReadTrdRegTimestampType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTrdRegTimestampType (dest:byte array) (nextFreeIdx:int) (xxIn:TrdRegTimestampType) : int =
    match xxIn with
    | TrdRegTimestampType.ExecutionTime ->
        let tag = "770=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.TimeIn ->
        let tag = "770=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.TimeOut ->
        let tag = "770=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.BrokerReceipt ->
        let tag = "770=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.BrokerExecution ->
        let tag = "770=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdRegTimestampOrigin (pos:int) (bs:byte[]) : (int*TrdRegTimestampOrigin) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TrdRegTimestampOrigin.TrdRegTimestampOrigin


let WriteTrdRegTimestampOrigin (dest:byte []) (nextFreeIdx:int) (valIn:TrdRegTimestampOrigin) : int = 
   let tag = "771="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConfirmRefID (pos:int) (bs:byte[]) : (int*ConfirmRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ConfirmRefID.ConfirmRefID


let WriteConfirmRefID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmRefID) : int = 
   let tag = "772="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConfirmType (pos:int) (bs:byte[]) : (int * ConfirmType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ConfirmType.Status
        |"2"B -> ConfirmType.Confirmation
        |"3"B -> ConfirmType.ConfirmationRequestRejected
        | x -> failwith (sprintf "ReadConfirmType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteConfirmType (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmType) : int =
    match xxIn with
    | ConfirmType.Status ->
        let tag = "773=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmType.Confirmation ->
        let tag = "773=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmType.ConfirmationRequestRejected ->
        let tag = "773=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadConfirmRejReason (pos:int) (bs:byte[]) : (int * ConfirmRejReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> ConfirmRejReason.MismatchedAccount
        |"2"B -> ConfirmRejReason.MissingSettlementInstructions
        |"99"B -> ConfirmRejReason.Other
        | x -> failwith (sprintf "ReadConfirmRejReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteConfirmRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmRejReason) : int =
    match xxIn with
    | ConfirmRejReason.MismatchedAccount ->
        let tag = "774=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmRejReason.MissingSettlementInstructions ->
        let tag = "774=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmRejReason.Other ->
        let tag = "774=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingType (pos:int) (bs:byte[]) : (int * BookingType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> BookingType.RegularBooking
        |"1"B -> BookingType.Cfd
        |"2"B -> BookingType.TotalReturnSwap
        | x -> failwith (sprintf "ReadBookingType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteBookingType (dest:byte array) (nextFreeIdx:int) (xxIn:BookingType) : int =
    match xxIn with
    | BookingType.RegularBooking ->
        let tag = "775=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingType.Cfd ->
        let tag = "775=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingType.TotalReturnSwap ->
        let tag = "775=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIndividualAllocRejCode (pos:int) (bs:byte[]) : (int*IndividualAllocRejCode) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) IndividualAllocRejCode.IndividualAllocRejCode


let WriteIndividualAllocRejCode (dest:byte []) (nextFreeIdx:int) (valIn:IndividualAllocRejCode) : int = 
   let tag = "776="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstMsgID (pos:int) (bs:byte[]) : (int*SettlInstMsgID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlInstMsgID.SettlInstMsgID


let WriteSettlInstMsgID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstMsgID) : int = 
   let tag = "777="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoSettlInst (pos:int) (bs:byte[]) : (int*NoSettlInst) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoSettlInst.NoSettlInst


let WriteNoSettlInst (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlInst) : int = 
   let tag = "778="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastUpdateTime (pos:int) (bs:byte[]) : (int*LastUpdateTime) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LastUpdateTime.LastUpdateTime


let WriteLastUpdateTime (dest:byte []) (nextFreeIdx:int) (valIn:LastUpdateTime) : int = 
   let tag = "779="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocSettlInstType (pos:int) (bs:byte[]) : (int * AllocSettlInstType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocSettlInstType.UseDefaultInstructions
        |"1"B -> AllocSettlInstType.DeriveFromParametersProvided
        |"2"B -> AllocSettlInstType.FullDetailsProvided
        |"3"B -> AllocSettlInstType.SsiDbIdsProvided
        |"4"B -> AllocSettlInstType.PhoneForInstructions
        | x -> failwith (sprintf "ReadAllocSettlInstType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocSettlInstType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocSettlInstType) : int =
    match xxIn with
    | AllocSettlInstType.UseDefaultInstructions ->
        let tag = "780=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.DeriveFromParametersProvided ->
        let tag = "780=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.FullDetailsProvided ->
        let tag = "780=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.SsiDbIdsProvided ->
        let tag = "780=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.PhoneForInstructions ->
        let tag = "780=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoSettlPartyIDs (pos:int) (bs:byte[]) : (int*NoSettlPartyIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoSettlPartyIDs.NoSettlPartyIDs


let WriteNoSettlPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlPartyIDs) : int = 
   let tag = "781="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPartyID (pos:int) (bs:byte[]) : (int*SettlPartyID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlPartyID.SettlPartyID


let WriteSettlPartyID (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyID) : int = 
   let tag = "782="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPartyIDSource (pos:int) (bs:byte[]) : (int*SettlPartyIDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SettlPartyIDSource.SettlPartyIDSource


let WriteSettlPartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyIDSource) : int = 
   let tag = "783="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPartyRole (pos:int) (bs:byte[]) : (int*SettlPartyRole) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SettlPartyRole.SettlPartyRole


let WriteSettlPartyRole (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyRole) : int = 
   let tag = "784="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPartySubID (pos:int) (bs:byte[]) : (int*SettlPartySubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlPartySubID.SettlPartySubID


let WriteSettlPartySubID (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartySubID) : int = 
   let tag = "785="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlPartySubIDType (pos:int) (bs:byte[]) : (int*SettlPartySubIDType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SettlPartySubIDType.SettlPartySubIDType


let WriteSettlPartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartySubIDType) : int = 
   let tag = "786="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDlvyInstType (pos:int) (bs:byte[]) : (int * DlvyInstType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"S"B -> DlvyInstType.Securities
        |"C"B -> DlvyInstType.Cash
        | x -> failwith (sprintf "ReadDlvyInstType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDlvyInstType (dest:byte array) (nextFreeIdx:int) (xxIn:DlvyInstType) : int =
    match xxIn with
    | DlvyInstType.Securities ->
        let tag = "787=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DlvyInstType.Cash ->
        let tag = "787=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTerminationType (pos:int) (bs:byte[]) : (int * TerminationType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> TerminationType.Overnight
        |"2"B -> TerminationType.Term
        |"3"B -> TerminationType.Flexible
        |"4"B -> TerminationType.Open
        | x -> failwith (sprintf "ReadTerminationType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTerminationType (dest:byte array) (nextFreeIdx:int) (xxIn:TerminationType) : int =
    match xxIn with
    | TerminationType.Overnight ->
        let tag = "788=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Term ->
        let tag = "788=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Flexible ->
        let tag = "788=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Open ->
        let tag = "788=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNextExpectedMsgSeqNum (pos:int) (bs:byte[]) : (int*NextExpectedMsgSeqNum) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NextExpectedMsgSeqNum.NextExpectedMsgSeqNum


let WriteNextExpectedMsgSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:NextExpectedMsgSeqNum) : int = 
   let tag = "789="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrdStatusReqID (pos:int) (bs:byte[]) : (int*OrdStatusReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrdStatusReqID.OrdStatusReqID


let WriteOrdStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:OrdStatusReqID) : int = 
   let tag = "790="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstReqID (pos:int) (bs:byte[]) : (int*SettlInstReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SettlInstReqID.SettlInstReqID


let WriteSettlInstReqID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstReqID) : int = 
   let tag = "791="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSettlInstReqRejCode (pos:int) (bs:byte[]) : (int * SettlInstReqRejCode) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> SettlInstReqRejCode.UnableToProcessRequest
        |"1"B -> SettlInstReqRejCode.UnknownAccount
        |"2"B -> SettlInstReqRejCode.NoMatchingSettlementInstructionsFound
        |"99"B -> SettlInstReqRejCode.Other
        | x -> failwith (sprintf "ReadSettlInstReqRejCode unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteSettlInstReqRejCode (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstReqRejCode) : int =
    match xxIn with
    | SettlInstReqRejCode.UnableToProcessRequest ->
        let tag = "792=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.UnknownAccount ->
        let tag = "792=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.NoMatchingSettlementInstructionsFound ->
        let tag = "792=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.Other ->
        let tag = "792=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryAllocID (pos:int) (bs:byte[]) : (int*SecondaryAllocID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryAllocID.SecondaryAllocID


let WriteSecondaryAllocID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryAllocID) : int = 
   let tag = "793="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocReportType (pos:int) (bs:byte[]) : (int * AllocReportType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"3"B -> AllocReportType.SellsideCalculatedUsingPreliminary
        |"4"B -> AllocReportType.SellsideCalculatedWithoutPreliminary
        |"5"B -> AllocReportType.WarehouseRecap
        |"8"B -> AllocReportType.RequestToIntermediary
        | x -> failwith (sprintf "ReadAllocReportType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocReportType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocReportType) : int =
    match xxIn with
    | AllocReportType.SellsideCalculatedUsingPreliminary ->
        let tag = "794=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.SellsideCalculatedWithoutPreliminary ->
        let tag = "794=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.WarehouseRecap ->
        let tag = "794=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.RequestToIntermediary ->
        let tag = "794=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocReportRefID (pos:int) (bs:byte[]) : (int*AllocReportRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AllocReportRefID.AllocReportRefID


let WriteAllocReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:AllocReportRefID) : int = 
   let tag = "795="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocCancReplaceReason (pos:int) (bs:byte[]) : (int * AllocCancReplaceReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AllocCancReplaceReason.OriginalDetailsIncompleteIncorrect
        |"2"B -> AllocCancReplaceReason.ChangeInUnderlyingOrderDetails
        | x -> failwith (sprintf "ReadAllocCancReplaceReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocCancReplaceReason (dest:byte array) (nextFreeIdx:int) (xxIn:AllocCancReplaceReason) : int =
    match xxIn with
    | AllocCancReplaceReason.OriginalDetailsIncompleteIncorrect ->
        let tag = "796=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocCancReplaceReason.ChangeInUnderlyingOrderDetails ->
        let tag = "796=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCopyMsgIndicator (pos:int) (bs:byte[]) : (int*CopyMsgIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) CopyMsgIndicator.CopyMsgIndicator


let WriteCopyMsgIndicator (dest:byte []) (nextFreeIdx:int) (valIn:CopyMsgIndicator) : int = 
   let tag = "797="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocAccountType (pos:int) (bs:byte[]) : (int * AllocAccountType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AllocAccountType.AccountIsCarriedOnCustomerSideOfBooks
        |"2"B -> AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooks
        |"3"B -> AllocAccountType.HouseTrader
        |"4"B -> AllocAccountType.FloorTrader
        |"6"B -> AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined
        |"7"B -> AllocAccountType.AccountIsHouseTraderAndIsCrossMargined
        |"8"B -> AllocAccountType.JointBackofficeAccount
        | x -> failwith (sprintf "ReadAllocAccountType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocAccountType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocAccountType) : int =
    match xxIn with
    | AllocAccountType.AccountIsCarriedOnCustomerSideOfBooks ->
        let tag = "798=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooks ->
        let tag = "798=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.HouseTrader ->
        let tag = "798=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.FloorTrader ->
        let tag = "798=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined ->
        let tag = "798=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsHouseTraderAndIsCrossMargined ->
        let tag = "798=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.JointBackofficeAccount ->
        let tag = "798=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrderAvgPx (pos:int) (bs:byte[]) : (int*OrderAvgPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderAvgPx.OrderAvgPx


let WriteOrderAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:OrderAvgPx) : int = 
   let tag = "799="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderBookingQty (pos:int) (bs:byte[]) : (int*OrderBookingQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderBookingQty.OrderBookingQty


let WriteOrderBookingQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderBookingQty) : int = 
   let tag = "800="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoSettlPartySubIDs (pos:int) (bs:byte[]) : (int*NoSettlPartySubIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoSettlPartySubIDs.NoSettlPartySubIDs


let WriteNoSettlPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlPartySubIDs) : int = 
   let tag = "801="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoPartySubIDs (pos:int) (bs:byte[]) : (int*NoPartySubIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoPartySubIDs.NoPartySubIDs


let WriteNoPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoPartySubIDs) : int = 
   let tag = "802="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPartySubIDType (pos:int) (bs:byte[]) : (int*PartySubIDType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) PartySubIDType.PartySubIDType


let WritePartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:PartySubIDType) : int = 
   let tag = "803="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNestedPartySubIDs (pos:int) (bs:byte[]) : (int*NoNestedPartySubIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNestedPartySubIDs.NoNestedPartySubIDs


let WriteNoNestedPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNestedPartySubIDs) : int = 
   let tag = "804="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNestedPartySubIDType (pos:int) (bs:byte[]) : (int*NestedPartySubIDType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NestedPartySubIDType.NestedPartySubIDType


let WriteNestedPartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartySubIDType) : int = 
   let tag = "805="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNested2PartySubIDs (pos:int) (bs:byte[]) : (int*NoNested2PartySubIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNested2PartySubIDs.NoNested2PartySubIDs


let WriteNoNested2PartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested2PartySubIDs) : int = 
   let tag = "806="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested2PartySubIDType (pos:int) (bs:byte[]) : (int*Nested2PartySubIDType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested2PartySubIDType.Nested2PartySubIDType


let WriteNested2PartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartySubIDType) : int = 
   let tag = "807="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAllocIntermedReqType (pos:int) (bs:byte[]) : (int * AllocIntermedReqType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AllocIntermedReqType.PendingAccept
        |"2"B -> AllocIntermedReqType.PendingRelease
        |"3"B -> AllocIntermedReqType.PendingReversal
        |"4"B -> AllocIntermedReqType.Accept
        |"5"B -> AllocIntermedReqType.BlockLevelReject
        |"6"B -> AllocIntermedReqType.AccountLevelReject
        | x -> failwith (sprintf "ReadAllocIntermedReqType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocIntermedReqType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocIntermedReqType) : int =
    match xxIn with
    | AllocIntermedReqType.PendingAccept ->
        let tag = "808=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.PendingRelease ->
        let tag = "808=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.PendingReversal ->
        let tag = "808=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.Accept ->
        let tag = "808=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.BlockLevelReject ->
        let tag = "808=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.AccountLevelReject ->
        let tag = "808=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingPx (pos:int) (bs:byte[]) : (int*UnderlyingPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingPx.UnderlyingPx


let WriteUnderlyingPx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingPx) : int = 
   let tag = "810="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPriceDelta (pos:int) (bs:byte[]) : (int*PriceDelta) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PriceDelta.PriceDelta


let WritePriceDelta (dest:byte []) (nextFreeIdx:int) (valIn:PriceDelta) : int = 
   let tag = "811="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadApplQueueMax (pos:int) (bs:byte[]) : (int*ApplQueueMax) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) ApplQueueMax.ApplQueueMax


let WriteApplQueueMax (dest:byte []) (nextFreeIdx:int) (valIn:ApplQueueMax) : int = 
   let tag = "812="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadApplQueueDepth (pos:int) (bs:byte[]) : (int*ApplQueueDepth) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) ApplQueueDepth.ApplQueueDepth


let WriteApplQueueDepth (dest:byte []) (nextFreeIdx:int) (valIn:ApplQueueDepth) : int = 
   let tag = "813="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadApplQueueResolution (pos:int) (bs:byte[]) : (int * ApplQueueResolution) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ApplQueueResolution.NoActionTaken
        |"1"B -> ApplQueueResolution.QueueFlushed
        |"2"B -> ApplQueueResolution.OverlayLast
        |"3"B -> ApplQueueResolution.EndSession
        | x -> failwith (sprintf "ReadApplQueueResolution unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteApplQueueResolution (dest:byte array) (nextFreeIdx:int) (xxIn:ApplQueueResolution) : int =
    match xxIn with
    | ApplQueueResolution.NoActionTaken ->
        let tag = "814=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.QueueFlushed ->
        let tag = "814=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.OverlayLast ->
        let tag = "814=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.EndSession ->
        let tag = "814=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadApplQueueAction (pos:int) (bs:byte[]) : (int * ApplQueueAction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ApplQueueAction.NoActionTaken
        |"1"B -> ApplQueueAction.QueueFlushed
        |"2"B -> ApplQueueAction.OverlayLast
        |"3"B -> ApplQueueAction.EndSession
        | x -> failwith (sprintf "ReadApplQueueAction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteApplQueueAction (dest:byte array) (nextFreeIdx:int) (xxIn:ApplQueueAction) : int =
    match xxIn with
    | ApplQueueAction.NoActionTaken ->
        let tag = "815=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.QueueFlushed ->
        let tag = "815=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.OverlayLast ->
        let tag = "815=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.EndSession ->
        let tag = "815=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoAltMDSource (pos:int) (bs:byte[]) : (int*NoAltMDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoAltMDSource.NoAltMDSource


let WriteNoAltMDSource (dest:byte []) (nextFreeIdx:int) (valIn:NoAltMDSource) : int = 
   let tag = "816="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAltMDSourceID (pos:int) (bs:byte[]) : (int*AltMDSourceID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AltMDSourceID.AltMDSourceID


let WriteAltMDSourceID (dest:byte []) (nextFreeIdx:int) (valIn:AltMDSourceID) : int = 
   let tag = "817="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecondaryTradeReportID (pos:int) (bs:byte[]) : (int*SecondaryTradeReportID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryTradeReportID.SecondaryTradeReportID


let WriteSecondaryTradeReportID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTradeReportID) : int = 
   let tag = "818="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAvgPxIndicator (pos:int) (bs:byte[]) : (int * AvgPxIndicator) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AvgPxIndicator.NoAveragePricing
        |"1"B -> AvgPxIndicator.TradeIsPartOfAnAveragePriceGroupIdentifiedByTheTradelinkid
        |"2"B -> AvgPxIndicator.LastTradeInTheAveragePriceGroupIdentifiedByTheTradelinkid
        | x -> failwith (sprintf "ReadAvgPxIndicator unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAvgPxIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:AvgPxIndicator) : int =
    match xxIn with
    | AvgPxIndicator.NoAveragePricing ->
        let tag = "819=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AvgPxIndicator.TradeIsPartOfAnAveragePriceGroupIdentifiedByTheTradelinkid ->
        let tag = "819=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AvgPxIndicator.LastTradeInTheAveragePriceGroupIdentifiedByTheTradelinkid ->
        let tag = "819=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeLinkID (pos:int) (bs:byte[]) : (int*TradeLinkID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeLinkID.TradeLinkID


let WriteTradeLinkID (dest:byte []) (nextFreeIdx:int) (valIn:TradeLinkID) : int = 
   let tag = "820="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderInputDevice (pos:int) (bs:byte[]) : (int*OrderInputDevice) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) OrderInputDevice.OrderInputDevice


let WriteOrderInputDevice (dest:byte []) (nextFreeIdx:int) (valIn:OrderInputDevice) : int = 
   let tag = "821="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingTradingSessionID (pos:int) (bs:byte[]) : (int*UnderlyingTradingSessionID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingTradingSessionID.UnderlyingTradingSessionID


let WriteUnderlyingTradingSessionID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingTradingSessionID) : int = 
   let tag = "822="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingTradingSessionSubID (pos:int) (bs:byte[]) : (int*UnderlyingTradingSessionSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingTradingSessionSubID.UnderlyingTradingSessionSubID


let WriteUnderlyingTradingSessionSubID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingTradingSessionSubID) : int = 
   let tag = "823="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeLegRefID (pos:int) (bs:byte[]) : (int*TradeLegRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TradeLegRefID.TradeLegRefID


let WriteTradeLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:TradeLegRefID) : int = 
   let tag = "824="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadExchangeRule (pos:int) (bs:byte[]) : (int*ExchangeRule) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ExchangeRule.ExchangeRule


let WriteExchangeRule (dest:byte []) (nextFreeIdx:int) (valIn:ExchangeRule) : int = 
   let tag = "825="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeAllocIndicator (pos:int) (bs:byte[]) : (int * TradeAllocIndicator) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeAllocIndicator.AllocationNotRequired
        |"1"B -> TradeAllocIndicator.AllocationRequired
        |"2"B -> TradeAllocIndicator.UseAllocationProvidedWithTheTrade
        | x -> failwith (sprintf "ReadTradeAllocIndicator unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeAllocIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:TradeAllocIndicator) : int =
    match xxIn with
    | TradeAllocIndicator.AllocationNotRequired ->
        let tag = "826=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeAllocIndicator.AllocationRequired ->
        let tag = "826=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeAllocIndicator.UseAllocationProvidedWithTheTrade ->
        let tag = "826=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExpirationCycle (pos:int) (bs:byte[]) : (int * ExpirationCycle) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ExpirationCycle.ExpireOnTradingSessionClose
        |"1"B -> ExpirationCycle.ExpireOnTradingSessionOpen
        | x -> failwith (sprintf "ReadExpirationCycle unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteExpirationCycle (dest:byte array) (nextFreeIdx:int) (xxIn:ExpirationCycle) : int =
    match xxIn with
    | ExpirationCycle.ExpireOnTradingSessionClose ->
        let tag = "827=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExpirationCycle.ExpireOnTradingSessionOpen ->
        let tag = "827=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdType (pos:int) (bs:byte[]) : (int * TrdType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TrdType.RegularTrade
        |"1"B -> TrdType.BlockTrade
        |"2"B -> TrdType.Efp
        |"3"B -> TrdType.Transfer
        |"4"B -> TrdType.LateTrade
        |"5"B -> TrdType.TTrade
        |"6"B -> TrdType.WeightedAveragePriceTrade
        |"7"B -> TrdType.BunchedTrade
        |"8"B -> TrdType.LateBunchedTrade
        |"9"B -> TrdType.PriorReferencePriceTrade
        |"10"B -> TrdType.AfterHoursTrade
        | x -> failwith (sprintf "ReadTrdType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTrdType (dest:byte array) (nextFreeIdx:int) (xxIn:TrdType) : int =
    match xxIn with
    | TrdType.RegularTrade ->
        let tag = "828=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.BlockTrade ->
        let tag = "828=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.Efp ->
        let tag = "828=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.Transfer ->
        let tag = "828=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.LateTrade ->
        let tag = "828=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.TTrade ->
        let tag = "828=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.WeightedAveragePriceTrade ->
        let tag = "828=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.BunchedTrade ->
        let tag = "828=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.LateBunchedTrade ->
        let tag = "828=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.PriorReferencePriceTrade ->
        let tag = "828=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.AfterHoursTrade ->
        let tag = "828=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdSubType (pos:int) (bs:byte[]) : (int*TrdSubType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TrdSubType.TrdSubType


let WriteTrdSubType (dest:byte []) (nextFreeIdx:int) (valIn:TrdSubType) : int = 
   let tag = "829="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTransferReason (pos:int) (bs:byte[]) : (int*TransferReason) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TransferReason.TransferReason


let WriteTransferReason (dest:byte []) (nextFreeIdx:int) (valIn:TransferReason) : int = 
   let tag = "830="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAsgnReqID (pos:int) (bs:byte[]) : (int*AsgnReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AsgnReqID.AsgnReqID


let WriteAsgnReqID (dest:byte []) (nextFreeIdx:int) (valIn:AsgnReqID) : int = 
   let tag = "831="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotNumAssignmentReports (pos:int) (bs:byte[]) : (int*TotNumAssignmentReports) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNumAssignmentReports.TotNumAssignmentReports


let WriteTotNumAssignmentReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumAssignmentReports) : int = 
   let tag = "832="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAsgnRptID (pos:int) (bs:byte[]) : (int*AsgnRptID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AsgnRptID.AsgnRptID


let WriteAsgnRptID (dest:byte []) (nextFreeIdx:int) (valIn:AsgnRptID) : int = 
   let tag = "833="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadThresholdAmount (pos:int) (bs:byte[]) : (int*ThresholdAmount) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ThresholdAmount.ThresholdAmount


let WriteThresholdAmount (dest:byte []) (nextFreeIdx:int) (valIn:ThresholdAmount) : int = 
   let tag = "834="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPegMoveType (pos:int) (bs:byte[]) : (int * PegMoveType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PegMoveType.Floating
        |"1"B -> PegMoveType.Fixed
        | x -> failwith (sprintf "ReadPegMoveType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePegMoveType (dest:byte array) (nextFreeIdx:int) (xxIn:PegMoveType) : int =
    match xxIn with
    | PegMoveType.Floating ->
        let tag = "835=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegMoveType.Fixed ->
        let tag = "835=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegOffsetType (pos:int) (bs:byte[]) : (int * PegOffsetType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PegOffsetType.Price
        |"1"B -> PegOffsetType.BasisPoints
        |"2"B -> PegOffsetType.Ticks
        |"3"B -> PegOffsetType.PriceTierLevel
        | x -> failwith (sprintf "ReadPegOffsetType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePegOffsetType (dest:byte array) (nextFreeIdx:int) (xxIn:PegOffsetType) : int =
    match xxIn with
    | PegOffsetType.Price ->
        let tag = "836=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.BasisPoints ->
        let tag = "836=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.Ticks ->
        let tag = "836=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.PriceTierLevel ->
        let tag = "836=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegLimitType (pos:int) (bs:byte[]) : (int * PegLimitType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> PegLimitType.OrBetter
        |"1"B -> PegLimitType.Strict
        |"2"B -> PegLimitType.OrWorse
        | x -> failwith (sprintf "ReadPegLimitType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePegLimitType (dest:byte array) (nextFreeIdx:int) (xxIn:PegLimitType) : int =
    match xxIn with
    | PegLimitType.OrBetter ->
        let tag = "837=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegLimitType.Strict ->
        let tag = "837=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegLimitType.OrWorse ->
        let tag = "837=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegRoundDirection (pos:int) (bs:byte[]) : (int * PegRoundDirection) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PegRoundDirection.MoreAggressive
        |"2"B -> PegRoundDirection.MorePassive
        | x -> failwith (sprintf "ReadPegRoundDirection unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePegRoundDirection (dest:byte array) (nextFreeIdx:int) (xxIn:PegRoundDirection) : int =
    match xxIn with
    | PegRoundDirection.MoreAggressive ->
        let tag = "838=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegRoundDirection.MorePassive ->
        let tag = "838=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPeggedPrice (pos:int) (bs:byte[]) : (int*PeggedPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PeggedPrice.PeggedPrice


let WritePeggedPrice (dest:byte []) (nextFreeIdx:int) (valIn:PeggedPrice) : int = 
   let tag = "839="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPegScope (pos:int) (bs:byte[]) : (int * PegScope) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> PegScope.Local
        |"2"B -> PegScope.National
        |"3"B -> PegScope.Global
        |"4"B -> PegScope.NationalExcludingLocal
        | x -> failwith (sprintf "ReadPegScope unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WritePegScope (dest:byte array) (nextFreeIdx:int) (xxIn:PegScope) : int =
    match xxIn with
    | PegScope.Local ->
        let tag = "840=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.National ->
        let tag = "840=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.Global ->
        let tag = "840=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.NationalExcludingLocal ->
        let tag = "840=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionMoveType (pos:int) (bs:byte[]) : (int * DiscretionMoveType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DiscretionMoveType.Floating
        |"1"B -> DiscretionMoveType.Fixed
        | x -> failwith (sprintf "ReadDiscretionMoveType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionMoveType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionMoveType) : int =
    match xxIn with
    | DiscretionMoveType.Floating ->
        let tag = "841=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionMoveType.Fixed ->
        let tag = "841=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionOffsetType (pos:int) (bs:byte[]) : (int * DiscretionOffsetType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DiscretionOffsetType.Price
        |"1"B -> DiscretionOffsetType.BasisPoints
        |"2"B -> DiscretionOffsetType.Ticks
        |"3"B -> DiscretionOffsetType.PriceTierLevel
        | x -> failwith (sprintf "ReadDiscretionOffsetType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionOffsetType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionOffsetType) : int =
    match xxIn with
    | DiscretionOffsetType.Price ->
        let tag = "842=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.BasisPoints ->
        let tag = "842=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.Ticks ->
        let tag = "842=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.PriceTierLevel ->
        let tag = "842=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionLimitType (pos:int) (bs:byte[]) : (int * DiscretionLimitType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DiscretionLimitType.OrBetter
        |"1"B -> DiscretionLimitType.Strict
        |"2"B -> DiscretionLimitType.OrWorse
        | x -> failwith (sprintf "ReadDiscretionLimitType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionLimitType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionLimitType) : int =
    match xxIn with
    | DiscretionLimitType.OrBetter ->
        let tag = "843=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionLimitType.Strict ->
        let tag = "843=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionLimitType.OrWorse ->
        let tag = "843=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionRoundDirection (pos:int) (bs:byte[]) : (int * DiscretionRoundDirection) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> DiscretionRoundDirection.MoreAggressive
        |"2"B -> DiscretionRoundDirection.MorePassive
        | x -> failwith (sprintf "ReadDiscretionRoundDirection unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionRoundDirection (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionRoundDirection) : int =
    match xxIn with
    | DiscretionRoundDirection.MoreAggressive ->
        let tag = "844=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionRoundDirection.MorePassive ->
        let tag = "844=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionPrice (pos:int) (bs:byte[]) : (int*DiscretionPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) DiscretionPrice.DiscretionPrice


let WriteDiscretionPrice (dest:byte []) (nextFreeIdx:int) (valIn:DiscretionPrice) : int = 
   let tag = "845="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDiscretionScope (pos:int) (bs:byte[]) : (int * DiscretionScope) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> DiscretionScope.Local
        |"2"B -> DiscretionScope.National
        |"3"B -> DiscretionScope.Global
        |"4"B -> DiscretionScope.NationalExcludingLocal
        | x -> failwith (sprintf "ReadDiscretionScope unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDiscretionScope (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionScope) : int =
    match xxIn with
    | DiscretionScope.Local ->
        let tag = "846=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.National ->
        let tag = "846=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.Global ->
        let tag = "846=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.NationalExcludingLocal ->
        let tag = "846=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTargetStrategy (pos:int) (bs:byte[]) : (int*TargetStrategy) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TargetStrategy.TargetStrategy


let WriteTargetStrategy (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategy) : int = 
   let tag = "847="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTargetStrategyParameters (pos:int) (bs:byte[]) : (int*TargetStrategyParameters) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TargetStrategyParameters.TargetStrategyParameters


let WriteTargetStrategyParameters (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategyParameters) : int = 
   let tag = "848="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadParticipationRate (pos:int) (bs:byte[]) : (int*ParticipationRate) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ParticipationRate.ParticipationRate


let WriteParticipationRate (dest:byte []) (nextFreeIdx:int) (valIn:ParticipationRate) : int = 
   let tag = "849="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTargetStrategyPerformance (pos:int) (bs:byte[]) : (int*TargetStrategyPerformance) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) TargetStrategyPerformance.TargetStrategyPerformance


let WriteTargetStrategyPerformance (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategyPerformance) : int = 
   let tag = "850="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastLiquidityInd (pos:int) (bs:byte[]) : (int * LastLiquidityInd) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> LastLiquidityInd.AddedLiquidity
        |"2"B -> LastLiquidityInd.RemovedLiquidity
        |"3"B -> LastLiquidityInd.LiquidityRoutedOut
        | x -> failwith (sprintf "ReadLastLiquidityInd unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteLastLiquidityInd (dest:byte array) (nextFreeIdx:int) (xxIn:LastLiquidityInd) : int =
    match xxIn with
    | LastLiquidityInd.AddedLiquidity ->
        let tag = "851=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastLiquidityInd.RemovedLiquidity ->
        let tag = "851=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastLiquidityInd.LiquidityRoutedOut ->
        let tag = "851=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPublishTrdIndicator (pos:int) (bs:byte[]) : (int*PublishTrdIndicator) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) PublishTrdIndicator.PublishTrdIndicator


let WritePublishTrdIndicator (dest:byte []) (nextFreeIdx:int) (valIn:PublishTrdIndicator) : int = 
   let tag = "852="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadShortSaleReason (pos:int) (bs:byte[]) : (int * ShortSaleReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> ShortSaleReason.DealerSoldShort
        |"1"B -> ShortSaleReason.DealerSoldShortExempt
        |"2"B -> ShortSaleReason.SellingCustomerSoldShort
        |"3"B -> ShortSaleReason.SellingCustomerSoldShortExempt
        |"4"B -> ShortSaleReason.QualifedServiceRepresentativeOrAutomaticGiveupContraSideSoldShort
        |"5"B -> ShortSaleReason.QsrOrAguContraSideSoldShortExempt
        | x -> failwith (sprintf "ReadShortSaleReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteShortSaleReason (dest:byte array) (nextFreeIdx:int) (xxIn:ShortSaleReason) : int =
    match xxIn with
    | ShortSaleReason.DealerSoldShort ->
        let tag = "853=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.DealerSoldShortExempt ->
        let tag = "853=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.SellingCustomerSoldShort ->
        let tag = "853=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.SellingCustomerSoldShortExempt ->
        let tag = "853=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.QualifedServiceRepresentativeOrAutomaticGiveupContraSideSoldShort ->
        let tag = "853=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.QsrOrAguContraSideSoldShortExempt ->
        let tag = "853=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQtyType (pos:int) (bs:byte[]) : (int * QtyType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> QtyType.Units
        |"1"B -> QtyType.Contracts
        | x -> failwith (sprintf "ReadQtyType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteQtyType (dest:byte array) (nextFreeIdx:int) (xxIn:QtyType) : int =
    match xxIn with
    | QtyType.Units ->
        let tag = "854=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QtyType.Contracts ->
        let tag = "854=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryTrdType (pos:int) (bs:byte[]) : (int*SecondaryTrdType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SecondaryTrdType.SecondaryTrdType


let WriteSecondaryTrdType (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTrdType) : int = 
   let tag = "855="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTradeReportType (pos:int) (bs:byte[]) : (int * TradeReportType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TradeReportType.Submit
        |"1"B -> TradeReportType.Alleged
        |"2"B -> TradeReportType.Accept
        |"3"B -> TradeReportType.Decline
        |"4"B -> TradeReportType.Addendum
        |"5"B -> TradeReportType.NoWas
        |"6"B -> TradeReportType.TradeReportCancel
        |"7"B -> TradeReportType.LockedInTradeBreak
        | x -> failwith (sprintf "ReadTradeReportType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTradeReportType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportType) : int =
    match xxIn with
    | TradeReportType.Submit ->
        let tag = "856=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Alleged ->
        let tag = "856=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Accept ->
        let tag = "856=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Decline ->
        let tag = "856=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Addendum ->
        let tag = "856=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.NoWas ->
        let tag = "856=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.TradeReportCancel ->
        let tag = "856=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.LockedInTradeBreak ->
        let tag = "856=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocNoOrdersType (pos:int) (bs:byte[]) : (int * AllocNoOrdersType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> AllocNoOrdersType.NotSpecified
        |"1"B -> AllocNoOrdersType.ExplicitListProvided
        | x -> failwith (sprintf "ReadAllocNoOrdersType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAllocNoOrdersType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocNoOrdersType) : int =
    match xxIn with
    | AllocNoOrdersType.NotSpecified ->
        let tag = "857=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocNoOrdersType.ExplicitListProvided ->
        let tag = "857=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSharedCommission (pos:int) (bs:byte[]) : (int*SharedCommission) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) SharedCommission.SharedCommission


let WriteSharedCommission (dest:byte []) (nextFreeIdx:int) (valIn:SharedCommission) : int = 
   let tag = "858="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadConfirmReqID (pos:int) (bs:byte[]) : (int*ConfirmReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) ConfirmReqID.ConfirmReqID


let WriteConfirmReqID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmReqID) : int = 
   let tag = "859="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAvgParPx (pos:int) (bs:byte[]) : (int*AvgParPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) AvgParPx.AvgParPx


let WriteAvgParPx (dest:byte []) (nextFreeIdx:int) (valIn:AvgParPx) : int = 
   let tag = "860="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadReportedPx (pos:int) (bs:byte[]) : (int*ReportedPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) ReportedPx.ReportedPx


let WriteReportedPx (dest:byte []) (nextFreeIdx:int) (valIn:ReportedPx) : int = 
   let tag = "861="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoCapacities (pos:int) (bs:byte[]) : (int*NoCapacities) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoCapacities.NoCapacities


let WriteNoCapacities (dest:byte []) (nextFreeIdx:int) (valIn:NoCapacities) : int = 
   let tag = "862="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadOrderCapacityQty (pos:int) (bs:byte[]) : (int*OrderCapacityQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) OrderCapacityQty.OrderCapacityQty


let WriteOrderCapacityQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderCapacityQty) : int = 
   let tag = "863="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoEvents (pos:int) (bs:byte[]) : (int*NoEvents) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoEvents.NoEvents


let WriteNoEvents (dest:byte []) (nextFreeIdx:int) (valIn:NoEvents) : int = 
   let tag = "864="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEventType (pos:int) (bs:byte[]) : (int * EventType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> EventType.Put
        |"2"B -> EventType.Call
        |"3"B -> EventType.Tender
        |"4"B -> EventType.SinkingFundCall
        |"99"B -> EventType.Other
        | x -> failwith (sprintf "ReadEventType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteEventType (dest:byte array) (nextFreeIdx:int) (xxIn:EventType) : int =
    match xxIn with
    | EventType.Put ->
        let tag = "865=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Call ->
        let tag = "865=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Tender ->
        let tag = "865=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.SinkingFundCall ->
        let tag = "865=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Other ->
        let tag = "865=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEventDate (pos:int) (bs:byte[]) : (int*EventDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) EventDate.EventDate


let WriteEventDate (dest:byte []) (nextFreeIdx:int) (valIn:EventDate) : int = 
   let tag = "866="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEventPx (pos:int) (bs:byte[]) : (int*EventPx) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) EventPx.EventPx


let WriteEventPx (dest:byte []) (nextFreeIdx:int) (valIn:EventPx) : int = 
   let tag = "867="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEventText (pos:int) (bs:byte[]) : (int*EventText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) EventText.EventText


let WriteEventText (dest:byte []) (nextFreeIdx:int) (valIn:EventText) : int = 
   let tag = "868="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadPctAtRisk (pos:int) (bs:byte[]) : (int*PctAtRisk) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) PctAtRisk.PctAtRisk


let WritePctAtRisk (dest:byte []) (nextFreeIdx:int) (valIn:PctAtRisk) : int = 
   let tag = "869="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoInstrAttrib (pos:int) (bs:byte[]) : (int*NoInstrAttrib) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoInstrAttrib.NoInstrAttrib


let WriteNoInstrAttrib (dest:byte []) (nextFreeIdx:int) (valIn:NoInstrAttrib) : int = 
   let tag = "870="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadInstrAttribType (pos:int) (bs:byte[]) : (int * InstrAttribType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> InstrAttribType.Flat
        |"2"B -> InstrAttribType.ZeroCoupon
        |"3"B -> InstrAttribType.InterestBearing
        |"4"B -> InstrAttribType.NoPeriodicPayments
        |"5"B -> InstrAttribType.VariableRate
        |"6"B -> InstrAttribType.LessFeeForPut
        |"7"B -> InstrAttribType.SteppedCoupon
        |"8"B -> InstrAttribType.CouponPeriod
        |"9"B -> InstrAttribType.WhenAndIfIssued
        |"10"B -> InstrAttribType.OriginalIssueDiscount
        |"11"B -> InstrAttribType.CallablePuttable
        |"12"B -> InstrAttribType.EscrowedToMaturity
        |"13"B -> InstrAttribType.EscrowedToRedemptionDate
        |"14"B -> InstrAttribType.PreRefunded
        |"15"B -> InstrAttribType.InDefault
        |"16"B -> InstrAttribType.Unrated
        |"17"B -> InstrAttribType.Taxable
        |"18"B -> InstrAttribType.Indexed
        |"19"B -> InstrAttribType.SubjectToAlternativeMinimumTax
        |"20"B -> InstrAttribType.OriginalIssueDiscountPrice
        |"21"B -> InstrAttribType.CallableBelowMaturityValue
        |"22"B -> InstrAttribType.CallableWithoutNoticeByMailToHolderUnlessRegistered
        |"99"B -> InstrAttribType.Text
        | x -> failwith (sprintf "ReadInstrAttribType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteInstrAttribType (dest:byte array) (nextFreeIdx:int) (xxIn:InstrAttribType) : int =
    match xxIn with
    | InstrAttribType.Flat ->
        let tag = "871=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.ZeroCoupon ->
        let tag = "871=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.InterestBearing ->
        let tag = "871=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.NoPeriodicPayments ->
        let tag = "871=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.VariableRate ->
        let tag = "871=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.LessFeeForPut ->
        let tag = "871=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.SteppedCoupon ->
        let tag = "871=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CouponPeriod ->
        let tag = "871=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.WhenAndIfIssued ->
        let tag = "871=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.OriginalIssueDiscount ->
        let tag = "871=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallablePuttable ->
        let tag = "871=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.EscrowedToMaturity ->
        let tag = "871=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.EscrowedToRedemptionDate ->
        let tag = "871=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.PreRefunded ->
        let tag = "871=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.InDefault ->
        let tag = "871=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Unrated ->
        let tag = "871=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Taxable ->
        let tag = "871=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Indexed ->
        let tag = "871=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.SubjectToAlternativeMinimumTax ->
        let tag = "871=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.OriginalIssueDiscountPrice ->
        let tag = "871=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallableBelowMaturityValue ->
        let tag = "871=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallableWithoutNoticeByMailToHolderUnlessRegistered ->
        let tag = "871=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Text ->
        let tag = "871=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadInstrAttribValue (pos:int) (bs:byte[]) : (int*InstrAttribValue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) InstrAttribValue.InstrAttribValue


let WriteInstrAttribValue (dest:byte []) (nextFreeIdx:int) (valIn:InstrAttribValue) : int = 
   let tag = "872="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDatedDate (pos:int) (bs:byte[]) : (int*DatedDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) DatedDate.DatedDate


let WriteDatedDate (dest:byte []) (nextFreeIdx:int) (valIn:DatedDate) : int = 
   let tag = "873="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadInterestAccrualDate (pos:int) (bs:byte[]) : (int*InterestAccrualDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) InterestAccrualDate.InterestAccrualDate


let WriteInterestAccrualDate (dest:byte []) (nextFreeIdx:int) (valIn:InterestAccrualDate) : int = 
   let tag = "874="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCPProgram (pos:int) (bs:byte[]) : (int*CPProgram) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) CPProgram.CPProgram


let WriteCPProgram (dest:byte []) (nextFreeIdx:int) (valIn:CPProgram) : int = 
   let tag = "875="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCPRegType (pos:int) (bs:byte[]) : (int*CPRegType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CPRegType.CPRegType


let WriteCPRegType (dest:byte []) (nextFreeIdx:int) (valIn:CPRegType) : int = 
   let tag = "876="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCPProgram (pos:int) (bs:byte[]) : (int*UnderlyingCPProgram) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCPProgram.UnderlyingCPProgram


let WriteUnderlyingCPProgram (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCPProgram) : int = 
   let tag = "877="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCPRegType (pos:int) (bs:byte[]) : (int*UnderlyingCPRegType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingCPRegType.UnderlyingCPRegType


let WriteUnderlyingCPRegType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCPRegType) : int = 
   let tag = "878="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingQty (pos:int) (bs:byte[]) : (int*UnderlyingQty) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingQty.UnderlyingQty


let WriteUnderlyingQty (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingQty) : int = 
   let tag = "879="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTrdMatchID (pos:int) (bs:byte[]) : (int*TrdMatchID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TrdMatchID.TrdMatchID


let WriteTrdMatchID (dest:byte []) (nextFreeIdx:int) (valIn:TrdMatchID) : int = 
   let tag = "880="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadSecondaryTradeReportRefID (pos:int) (bs:byte[]) : (int*SecondaryTradeReportRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) SecondaryTradeReportRefID.SecondaryTradeReportRefID


let WriteSecondaryTradeReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTradeReportRefID) : int = 
   let tag = "881="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingDirtyPrice (pos:int) (bs:byte[]) : (int*UnderlyingDirtyPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingDirtyPrice.UnderlyingDirtyPrice


let WriteUnderlyingDirtyPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingDirtyPrice) : int = 
   let tag = "882="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingEndPrice (pos:int) (bs:byte[]) : (int*UnderlyingEndPrice) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) UnderlyingEndPrice.UnderlyingEndPrice


let WriteUnderlyingEndPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingEndPrice) : int = 
   let tag = "883="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingStartValue (pos:int) (bs:byte[]) : (int*UnderlyingStartValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingStartValue.UnderlyingStartValue


let WriteUnderlyingStartValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStartValue) : int = 
   let tag = "884="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingCurrentValue (pos:int) (bs:byte[]) : (int*UnderlyingCurrentValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingCurrentValue.UnderlyingCurrentValue


let WriteUnderlyingCurrentValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCurrentValue) : int = 
   let tag = "885="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingEndValue (pos:int) (bs:byte[]) : (int*UnderlyingEndValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) UnderlyingEndValue.UnderlyingEndValue


let WriteUnderlyingEndValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingEndValue) : int = 
   let tag = "886="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoUnderlyingStips (pos:int) (bs:byte[]) : (int*NoUnderlyingStips) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoUnderlyingStips.NoUnderlyingStips


let WriteNoUnderlyingStips (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyingStips) : int = 
   let tag = "887="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingStipType (pos:int) (bs:byte[]) : (int*UnderlyingStipType) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingStipType.UnderlyingStipType


let WriteUnderlyingStipType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStipType) : int = 
   let tag = "888="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUnderlyingStipValue (pos:int) (bs:byte[]) : (int*UnderlyingStipValue) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingStipValue.UnderlyingStipValue


let WriteUnderlyingStipValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStipValue) : int = 
   let tag = "889="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMaturityNetMoney (pos:int) (bs:byte[]) : (int*MaturityNetMoney) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MaturityNetMoney.MaturityNetMoney


let WriteMaturityNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:MaturityNetMoney) : int = 
   let tag = "890="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMiscFeeBasis (pos:int) (bs:byte[]) : (int * MiscFeeBasis) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> MiscFeeBasis.Absolute
        |"1"B -> MiscFeeBasis.PerUnit
        |"2"B -> MiscFeeBasis.Percentage
        | x -> failwith (sprintf "ReadMiscFeeBasis unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteMiscFeeBasis (dest:byte array) (nextFreeIdx:int) (xxIn:MiscFeeBasis) : int =
    match xxIn with
    | MiscFeeBasis.Absolute ->
        let tag = "891=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeBasis.PerUnit ->
        let tag = "891=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeBasis.Percentage ->
        let tag = "891=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNoAllocs (pos:int) (bs:byte[]) : (int*TotNoAllocs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNoAllocs.TotNoAllocs


let WriteTotNoAllocs (dest:byte []) (nextFreeIdx:int) (valIn:TotNoAllocs) : int = 
   let tag = "892="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastFragment (pos:int) (bs:byte[]) : (int*LastFragment) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) LastFragment.LastFragment


let WriteLastFragment (dest:byte []) (nextFreeIdx:int) (valIn:LastFragment) : int = 
   let tag = "893="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollReqID (pos:int) (bs:byte[]) : (int*CollReqID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollReqID.CollReqID


let WriteCollReqID (dest:byte []) (nextFreeIdx:int) (valIn:CollReqID) : int = 
   let tag = "894="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollAsgnReason (pos:int) (bs:byte[]) : (int * CollAsgnReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollAsgnReason.Initial
        |"1"B -> CollAsgnReason.Scheduled
        |"2"B -> CollAsgnReason.TimeWarning
        |"3"B -> CollAsgnReason.MarginDeficiency
        |"4"B -> CollAsgnReason.MarginExcess
        |"5"B -> CollAsgnReason.ForwardCollateralDemand
        |"6"B -> CollAsgnReason.EventOfDefault
        |"7"B -> CollAsgnReason.AdverseTaxEvent
        | x -> failwith (sprintf "ReadCollAsgnReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollAsgnReason (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnReason) : int =
    match xxIn with
    | CollAsgnReason.Initial ->
        let tag = "895=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.Scheduled ->
        let tag = "895=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.TimeWarning ->
        let tag = "895=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.MarginDeficiency ->
        let tag = "895=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.MarginExcess ->
        let tag = "895=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.ForwardCollateralDemand ->
        let tag = "895=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.EventOfDefault ->
        let tag = "895=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.AdverseTaxEvent ->
        let tag = "895=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryQualifier (pos:int) (bs:byte[]) : (int * CollInquiryQualifier) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollInquiryQualifier.Tradedate
        |"1"B -> CollInquiryQualifier.GcInstrument
        |"2"B -> CollInquiryQualifier.Collateralinstrument
        |"3"B -> CollInquiryQualifier.SubstitutionEligible
        |"4"B -> CollInquiryQualifier.NotAssigned
        |"5"B -> CollInquiryQualifier.PartiallyAssigned
        |"6"B -> CollInquiryQualifier.FullyAssigned
        |"7"B -> CollInquiryQualifier.OutstandingTrades
        | x -> failwith (sprintf "ReadCollInquiryQualifier unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollInquiryQualifier (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryQualifier) : int =
    match xxIn with
    | CollInquiryQualifier.Tradedate ->
        let tag = "896=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.GcInstrument ->
        let tag = "896=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.Collateralinstrument ->
        let tag = "896=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.SubstitutionEligible ->
        let tag = "896=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.NotAssigned ->
        let tag = "896=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.PartiallyAssigned ->
        let tag = "896=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.FullyAssigned ->
        let tag = "896=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.OutstandingTrades ->
        let tag = "896=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoTrades (pos:int) (bs:byte[]) : (int*NoTrades) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoTrades.NoTrades


let WriteNoTrades (dest:byte []) (nextFreeIdx:int) (valIn:NoTrades) : int = 
   let tag = "897="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMarginRatio (pos:int) (bs:byte[]) : (int*MarginRatio) =
    ReadSingleCaseDUDecimalField (pos:int) (bs:byte[]) MarginRatio.MarginRatio


let WriteMarginRatio (dest:byte []) (nextFreeIdx:int) (valIn:MarginRatio) : int = 
   let tag = "898="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadMarginExcess (pos:int) (bs:byte[]) : (int*MarginExcess) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) MarginExcess.MarginExcess


let WriteMarginExcess (dest:byte []) (nextFreeIdx:int) (valIn:MarginExcess) : int = 
   let tag = "899="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTotalNetValue (pos:int) (bs:byte[]) : (int*TotalNetValue) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotalNetValue.TotalNetValue


let WriteTotalNetValue (dest:byte []) (nextFreeIdx:int) (valIn:TotalNetValue) : int = 
   let tag = "900="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCashOutstanding (pos:int) (bs:byte[]) : (int*CashOutstanding) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) CashOutstanding.CashOutstanding


let WriteCashOutstanding (dest:byte []) (nextFreeIdx:int) (valIn:CashOutstanding) : int = 
   let tag = "901="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollAsgnID (pos:int) (bs:byte[]) : (int*CollAsgnID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollAsgnID.CollAsgnID


let WriteCollAsgnID (dest:byte []) (nextFreeIdx:int) (valIn:CollAsgnID) : int = 
   let tag = "902="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollAsgnTransType (pos:int) (bs:byte[]) : (int * CollAsgnTransType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollAsgnTransType.New
        |"1"B -> CollAsgnTransType.Replace
        |"2"B -> CollAsgnTransType.Cancel
        |"3"B -> CollAsgnTransType.Release
        |"4"B -> CollAsgnTransType.Reverse
        | x -> failwith (sprintf "ReadCollAsgnTransType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollAsgnTransType (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnTransType) : int =
    match xxIn with
    | CollAsgnTransType.New ->
        let tag = "903=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Replace ->
        let tag = "903=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Cancel ->
        let tag = "903=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Release ->
        let tag = "903=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Reverse ->
        let tag = "903=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollRespID (pos:int) (bs:byte[]) : (int*CollRespID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollRespID.CollRespID


let WriteCollRespID (dest:byte []) (nextFreeIdx:int) (valIn:CollRespID) : int = 
   let tag = "904="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollAsgnRespType (pos:int) (bs:byte[]) : (int * CollAsgnRespType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollAsgnRespType.Received
        |"1"B -> CollAsgnRespType.Accepted
        |"2"B -> CollAsgnRespType.Declined
        |"3"B -> CollAsgnRespType.Rejected
        | x -> failwith (sprintf "ReadCollAsgnRespType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollAsgnRespType (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnRespType) : int =
    match xxIn with
    | CollAsgnRespType.Received ->
        let tag = "905=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Accepted ->
        let tag = "905=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Declined ->
        let tag = "905=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Rejected ->
        let tag = "905=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollAsgnRejectReason (pos:int) (bs:byte[]) : (int * CollAsgnRejectReason) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollAsgnRejectReason.UnknownDeal
        |"1"B -> CollAsgnRejectReason.UnknownOrInvalidInstrument
        |"2"B -> CollAsgnRejectReason.UnauthorizedTransaction
        |"3"B -> CollAsgnRejectReason.InsufficientCollateral
        |"4"B -> CollAsgnRejectReason.InvalidTypeOfCollateral
        |"5"B -> CollAsgnRejectReason.ExcessiveSubstitution
        |"99"B -> CollAsgnRejectReason.Other
        | x -> failwith (sprintf "ReadCollAsgnRejectReason unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollAsgnRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnRejectReason) : int =
    match xxIn with
    | CollAsgnRejectReason.UnknownDeal ->
        let tag = "906=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.UnknownOrInvalidInstrument ->
        let tag = "906=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.UnauthorizedTransaction ->
        let tag = "906=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.InsufficientCollateral ->
        let tag = "906=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.InvalidTypeOfCollateral ->
        let tag = "906=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.ExcessiveSubstitution ->
        let tag = "906=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.Other ->
        let tag = "906=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollAsgnRefID (pos:int) (bs:byte[]) : (int*CollAsgnRefID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollAsgnRefID.CollAsgnRefID


let WriteCollAsgnRefID (dest:byte []) (nextFreeIdx:int) (valIn:CollAsgnRefID) : int = 
   let tag = "907="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollRptID (pos:int) (bs:byte[]) : (int*CollRptID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollRptID.CollRptID


let WriteCollRptID (dest:byte []) (nextFreeIdx:int) (valIn:CollRptID) : int = 
   let tag = "908="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollInquiryID (pos:int) (bs:byte[]) : (int*CollInquiryID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) CollInquiryID.CollInquiryID


let WriteCollInquiryID (dest:byte []) (nextFreeIdx:int) (valIn:CollInquiryID) : int = 
   let tag = "909="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollStatus (pos:int) (bs:byte[]) : (int * CollStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollStatus.Unassigned
        |"1"B -> CollStatus.PartiallyAssigned
        |"2"B -> CollStatus.AssignmentProposed
        |"3"B -> CollStatus.Assigned
        |"4"B -> CollStatus.Challenged
        | x -> failwith (sprintf "ReadCollStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollStatus (dest:byte array) (nextFreeIdx:int) (xxIn:CollStatus) : int =
    match xxIn with
    | CollStatus.Unassigned ->
        let tag = "910=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.PartiallyAssigned ->
        let tag = "910=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.AssignmentProposed ->
        let tag = "910=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.Assigned ->
        let tag = "910=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.Challenged ->
        let tag = "910=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNumReports (pos:int) (bs:byte[]) : (int*TotNumReports) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) TotNumReports.TotNumReports


let WriteTotNumReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumReports) : int = 
   let tag = "911="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastRptRequested (pos:int) (bs:byte[]) : (int*LastRptRequested) =
    ReadSingleCaseDUBoolField (pos:int) (bs:byte[]) LastRptRequested.LastRptRequested


let WriteLastRptRequested (dest:byte []) (nextFreeIdx:int) (valIn:LastRptRequested) : int = 
   let tag = "912="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAgreementDesc (pos:int) (bs:byte[]) : (int*AgreementDesc) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AgreementDesc.AgreementDesc


let WriteAgreementDesc (dest:byte []) (nextFreeIdx:int) (valIn:AgreementDesc) : int = 
   let tag = "913="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAgreementID (pos:int) (bs:byte[]) : (int*AgreementID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AgreementID.AgreementID


let WriteAgreementID (dest:byte []) (nextFreeIdx:int) (valIn:AgreementID) : int = 
   let tag = "914="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAgreementDate (pos:int) (bs:byte[]) : (int*AgreementDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AgreementDate.AgreementDate


let WriteAgreementDate (dest:byte []) (nextFreeIdx:int) (valIn:AgreementDate) : int = 
   let tag = "915="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStartDate (pos:int) (bs:byte[]) : (int*StartDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StartDate.StartDate


let WriteStartDate (dest:byte []) (nextFreeIdx:int) (valIn:StartDate) : int = 
   let tag = "916="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEndDate (pos:int) (bs:byte[]) : (int*EndDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) EndDate.EndDate


let WriteEndDate (dest:byte []) (nextFreeIdx:int) (valIn:EndDate) : int = 
   let tag = "917="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadAgreementCurrency (pos:int) (bs:byte[]) : (int*AgreementCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) AgreementCurrency.AgreementCurrency


let WriteAgreementCurrency (dest:byte []) (nextFreeIdx:int) (valIn:AgreementCurrency) : int = 
   let tag = "918="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadDeliveryType (pos:int) (bs:byte[]) : (int * DeliveryType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> DeliveryType.VersusPayment
        |"1"B -> DeliveryType.Free
        |"2"B -> DeliveryType.TriParty
        |"3"B -> DeliveryType.HoldInCustody
        | x -> failwith (sprintf "ReadDeliveryType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteDeliveryType (dest:byte array) (nextFreeIdx:int) (xxIn:DeliveryType) : int =
    match xxIn with
    | DeliveryType.VersusPayment ->
        let tag = "919=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.Free ->
        let tag = "919=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.TriParty ->
        let tag = "919=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.HoldInCustody ->
        let tag = "919=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEndAccruedInterestAmt (pos:int) (bs:byte[]) : (int*EndAccruedInterestAmt) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) EndAccruedInterestAmt.EndAccruedInterestAmt


let WriteEndAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:EndAccruedInterestAmt) : int = 
   let tag = "920="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStartCash (pos:int) (bs:byte[]) : (int*StartCash) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) StartCash.StartCash


let WriteStartCash (dest:byte []) (nextFreeIdx:int) (valIn:StartCash) : int = 
   let tag = "921="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadEndCash (pos:int) (bs:byte[]) : (int*EndCash) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) EndCash.EndCash


let WriteEndCash (dest:byte []) (nextFreeIdx:int) (valIn:EndCash) : int = 
   let tag = "922="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUserRequestID (pos:int) (bs:byte[]) : (int*UserRequestID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UserRequestID.UserRequestID


let WriteUserRequestID (dest:byte []) (nextFreeIdx:int) (valIn:UserRequestID) : int = 
   let tag = "923="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUserRequestType (pos:int) (bs:byte[]) : (int * UserRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> UserRequestType.Logonuser
        |"2"B -> UserRequestType.Logoffuser
        |"3"B -> UserRequestType.Changepasswordforuser
        |"4"B -> UserRequestType.RequestIndividualUserStatus
        | x -> failwith (sprintf "ReadUserRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteUserRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:UserRequestType) : int =
    match xxIn with
    | UserRequestType.Logonuser ->
        let tag = "924=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.Logoffuser ->
        let tag = "924=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.Changepasswordforuser ->
        let tag = "924=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.RequestIndividualUserStatus ->
        let tag = "924=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNewPassword (pos:int) (bs:byte[]) : (int*NewPassword) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) NewPassword.NewPassword


let WriteNewPassword (dest:byte []) (nextFreeIdx:int) (valIn:NewPassword) : int = 
   let tag = "925="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadUserStatus (pos:int) (bs:byte[]) : (int * UserStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> UserStatus.LoggedIn
        |"2"B -> UserStatus.NotLoggedIn
        |"3"B -> UserStatus.UserNotRecognised
        |"4"B -> UserStatus.PasswordIncorrect
        |"5"B -> UserStatus.PasswordChanged
        |"6"B -> UserStatus.Other
        | x -> failwith (sprintf "ReadUserStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteUserStatus (dest:byte array) (nextFreeIdx:int) (xxIn:UserStatus) : int =
    match xxIn with
    | UserStatus.LoggedIn ->
        let tag = "926=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.NotLoggedIn ->
        let tag = "926=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.UserNotRecognised ->
        let tag = "926=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.PasswordIncorrect ->
        let tag = "926=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.PasswordChanged ->
        let tag = "926=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.Other ->
        let tag = "926=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUserStatusText (pos:int) (bs:byte[]) : (int*UserStatusText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UserStatusText.UserStatusText


let WriteUserStatusText (dest:byte []) (nextFreeIdx:int) (valIn:UserStatusText) : int = 
   let tag = "927="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadStatusValue (pos:int) (bs:byte[]) : (int * StatusValue) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> StatusValue.Connected
        |"2"B -> StatusValue.NotConnectedDownExpectedUp
        |"3"B -> StatusValue.NotConnectedDownExpectedDown
        |"4"B -> StatusValue.InProcess
        | x -> failwith (sprintf "ReadStatusValue unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteStatusValue (dest:byte array) (nextFreeIdx:int) (xxIn:StatusValue) : int =
    match xxIn with
    | StatusValue.Connected ->
        let tag = "928=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.NotConnectedDownExpectedUp ->
        let tag = "928=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.NotConnectedDownExpectedDown ->
        let tag = "928=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.InProcess ->
        let tag = "928=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStatusText (pos:int) (bs:byte[]) : (int*StatusText) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StatusText.StatusText


let WriteStatusText (dest:byte []) (nextFreeIdx:int) (valIn:StatusText) : int = 
   let tag = "929="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRefCompID (pos:int) (bs:byte[]) : (int*RefCompID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RefCompID.RefCompID


let WriteRefCompID (dest:byte []) (nextFreeIdx:int) (valIn:RefCompID) : int = 
   let tag = "930="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadRefSubID (pos:int) (bs:byte[]) : (int*RefSubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) RefSubID.RefSubID


let WriteRefSubID (dest:byte []) (nextFreeIdx:int) (valIn:RefSubID) : int = 
   let tag = "931="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetworkResponseID (pos:int) (bs:byte[]) : (int*NetworkResponseID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) NetworkResponseID.NetworkResponseID


let WriteNetworkResponseID (dest:byte []) (nextFreeIdx:int) (valIn:NetworkResponseID) : int = 
   let tag = "932="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetworkRequestID (pos:int) (bs:byte[]) : (int*NetworkRequestID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) NetworkRequestID.NetworkRequestID


let WriteNetworkRequestID (dest:byte []) (nextFreeIdx:int) (valIn:NetworkRequestID) : int = 
   let tag = "933="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLastNetworkResponseID (pos:int) (bs:byte[]) : (int*LastNetworkResponseID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LastNetworkResponseID.LastNetworkResponseID


let WriteLastNetworkResponseID (dest:byte []) (nextFreeIdx:int) (valIn:LastNetworkResponseID) : int = 
   let tag = "934="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetworkRequestType (pos:int) (bs:byte[]) : (int * NetworkRequestType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> NetworkRequestType.Snapshot
        |"2"B -> NetworkRequestType.Subscribe
        |"4"B -> NetworkRequestType.StopSubscribing
        |"8"B -> NetworkRequestType.LevelOfDetail
        | x -> failwith (sprintf "ReadNetworkRequestType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteNetworkRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:NetworkRequestType) : int =
    match xxIn with
    | NetworkRequestType.Snapshot ->
        let tag = "935=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.Subscribe ->
        let tag = "935=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.StopSubscribing ->
        let tag = "935=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.LevelOfDetail ->
        let tag = "935=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoCompIDs (pos:int) (bs:byte[]) : (int*NoCompIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoCompIDs.NoCompIDs


let WriteNoCompIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoCompIDs) : int = 
   let tag = "936="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNetworkStatusResponseType (pos:int) (bs:byte[]) : (int * NetworkStatusResponseType) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> NetworkStatusResponseType.Full
        |"2"B -> NetworkStatusResponseType.IncrementalUpdate
        | x -> failwith (sprintf "ReadNetworkStatusResponseType unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteNetworkStatusResponseType (dest:byte array) (nextFreeIdx:int) (xxIn:NetworkStatusResponseType) : int =
    match xxIn with
    | NetworkStatusResponseType.Full ->
        let tag = "937=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkStatusResponseType.IncrementalUpdate ->
        let tag = "937=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoCollInquiryQualifier (pos:int) (bs:byte[]) : (int*NoCollInquiryQualifier) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoCollInquiryQualifier.NoCollInquiryQualifier


let WriteNoCollInquiryQualifier (dest:byte []) (nextFreeIdx:int) (valIn:NoCollInquiryQualifier) : int = 
   let tag = "938="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTrdRptStatus (pos:int) (bs:byte[]) : (int * TrdRptStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> TrdRptStatus.Accepted
        |"1"B -> TrdRptStatus.Rejected
        | x -> failwith (sprintf "ReadTrdRptStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteTrdRptStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TrdRptStatus) : int =
    match xxIn with
    | TrdRptStatus.Accepted ->
        let tag = "939=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRptStatus.Rejected ->
        let tag = "939=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAffirmStatus (pos:int) (bs:byte[]) : (int * AffirmStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"1"B -> AffirmStatus.Received
        |"2"B -> AffirmStatus.ConfirmRejected
        |"3"B -> AffirmStatus.Affirmed
        | x -> failwith (sprintf "ReadAffirmStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteAffirmStatus (dest:byte array) (nextFreeIdx:int) (xxIn:AffirmStatus) : int =
    match xxIn with
    | AffirmStatus.Received ->
        let tag = "940=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AffirmStatus.ConfirmRejected ->
        let tag = "940=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AffirmStatus.Affirmed ->
        let tag = "940=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingStrikeCurrency (pos:int) (bs:byte[]) : (int*UnderlyingStrikeCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) UnderlyingStrikeCurrency.UnderlyingStrikeCurrency


let WriteUnderlyingStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStrikeCurrency) : int = 
   let tag = "941="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegStrikeCurrency (pos:int) (bs:byte[]) : (int*LegStrikeCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegStrikeCurrency.LegStrikeCurrency


let WriteLegStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegStrikeCurrency) : int = 
   let tag = "942="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadTimeBracket (pos:int) (bs:byte[]) : (int*TimeBracket) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) TimeBracket.TimeBracket


let WriteTimeBracket (dest:byte []) (nextFreeIdx:int) (valIn:TimeBracket) : int = 
   let tag = "943="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadCollAction (pos:int) (bs:byte[]) : (int * CollAction) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollAction.Retain
        |"1"B -> CollAction.Add
        |"2"B -> CollAction.Remove
        | x -> failwith (sprintf "ReadCollAction unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollAction (dest:byte array) (nextFreeIdx:int) (xxIn:CollAction) : int =
    match xxIn with
    | CollAction.Retain ->
        let tag = "944=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAction.Add ->
        let tag = "944=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAction.Remove ->
        let tag = "944=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryStatus (pos:int) (bs:byte[]) : (int * CollInquiryStatus) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollInquiryStatus.Accepted
        |"1"B -> CollInquiryStatus.AcceptedWithWarnings
        |"2"B -> CollInquiryStatus.Completed
        |"3"B -> CollInquiryStatus.CompletedWithWarnings
        |"4"B -> CollInquiryStatus.Rejected
        | x -> failwith (sprintf "ReadCollInquiryStatus unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollInquiryStatus (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryStatus) : int =
    match xxIn with
    | CollInquiryStatus.Accepted ->
        let tag = "945=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.AcceptedWithWarnings ->
        let tag = "945=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.Completed ->
        let tag = "945=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.CompletedWithWarnings ->
        let tag = "945=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.Rejected ->
        let tag = "945=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryResult (pos:int) (bs:byte[]) : (int * CollInquiryResult) =
    let pos2, valIn = ByteArrayUtils.readValAfterTagValSep pos bs
    let fld = 
        match valIn with
        |"0"B -> CollInquiryResult.Successful
        |"1"B -> CollInquiryResult.InvalidOrUnknownInstrument
        |"2"B -> CollInquiryResult.InvalidOrUnknownCollateralType
        |"3"B -> CollInquiryResult.InvalidParties
        |"4"B -> CollInquiryResult.InvalidTransportTypeRequested
        |"5"B -> CollInquiryResult.InvalidDestinationRequested
        |"6"B -> CollInquiryResult.NoCollateralFoundForTheTradeSpecified
        |"7"B -> CollInquiryResult.NoCollateralFoundForTheOrderSpecified
        |"8"B -> CollInquiryResult.CollateralInquiryTypeNotSupported
        |"9"B -> CollInquiryResult.UnauthorizedForCollateralInquiry
        |"99"B -> CollInquiryResult.Other
        | x -> failwith (sprintf "ReadCollInquiryResult unknown fix tag: %A"  x) 
    pos2 + 1, fld  // +1 to advance the position to after the field separator


let WriteCollInquiryResult (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryResult) : int =
    match xxIn with
    | CollInquiryResult.Successful ->
        let tag = "946=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidOrUnknownInstrument ->
        let tag = "946=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidOrUnknownCollateralType ->
        let tag = "946=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidParties ->
        let tag = "946=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidTransportTypeRequested ->
        let tag = "946=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidDestinationRequested ->
        let tag = "946=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.NoCollateralFoundForTheTradeSpecified ->
        let tag = "946=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.NoCollateralFoundForTheOrderSpecified ->
        let tag = "946=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.CollateralInquiryTypeNotSupported ->
        let tag = "946=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.UnauthorizedForCollateralInquiry ->
        let tag = "946=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.Other ->
        let tag = "946=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikeCurrency (pos:int) (bs:byte[]) : (int*StrikeCurrency) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) StrikeCurrency.StrikeCurrency


let WriteStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:StrikeCurrency) : int = 
   let tag = "947="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNested3PartyIDs (pos:int) (bs:byte[]) : (int*NoNested3PartyIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNested3PartyIDs.NoNested3PartyIDs


let WriteNoNested3PartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested3PartyIDs) : int = 
   let tag = "948="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested3PartyID (pos:int) (bs:byte[]) : (int*Nested3PartyID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Nested3PartyID.Nested3PartyID


let WriteNested3PartyID (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyID) : int = 
   let tag = "949="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested3PartyIDSource (pos:int) (bs:byte[]) : (int*Nested3PartyIDSource) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested3PartyIDSource.Nested3PartyIDSource


let WriteNested3PartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyIDSource) : int = 
   let tag = "950="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested3PartyRole (pos:int) (bs:byte[]) : (int*Nested3PartyRole) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested3PartyRole.Nested3PartyRole


let WriteNested3PartyRole (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyRole) : int = 
   let tag = "951="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNoNested3PartySubIDs (pos:int) (bs:byte[]) : (int*NoNested3PartySubIDs) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) NoNested3PartySubIDs.NoNested3PartySubIDs


let WriteNoNested3PartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested3PartySubIDs) : int = 
   let tag = "952="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested3PartySubID (pos:int) (bs:byte[]) : (int*Nested3PartySubID) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) Nested3PartySubID.Nested3PartySubID


let WriteNested3PartySubID (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartySubID) : int = 
   let tag = "953="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadNested3PartySubIDType (pos:int) (bs:byte[]) : (int*Nested3PartySubIDType) =
    ReadSingleCaseDUIntField (pos:int) (bs:byte[]) Nested3PartySubIDType.Nested3PartySubIDType


let WriteNested3PartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartySubIDType) : int = 
   let tag = "954="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegContractSettlMonth (pos:int) (bs:byte[]) : (int*LegContractSettlMonth) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegContractSettlMonth.LegContractSettlMonth


let WriteLegContractSettlMonth (dest:byte []) (nextFreeIdx:int) (valIn:LegContractSettlMonth) : int = 
   let tag = "955="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter


let ReadLegInterestAccrualDate (pos:int) (bs:byte[]) : (int*LegInterestAccrualDate) =
    ReadSingleCaseDUStrField (pos:int) (bs:byte[]) LegInterestAccrualDate.LegInterestAccrualDate


let WriteLegInterestAccrualDate (dest:byte []) (nextFreeIdx:int) (valIn:LegInterestAccrualDate) : int = 
   let tag = "956="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   let nextFreeIdx3 = nextFreeIdx2 + bs.Length
   dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
   nextFreeIdx3 + 1 // +1 to include the delimeter




let WriteField dest nextFreeIdx fixField =
    match fixField with
    | Account fixField -> WriteAccount dest nextFreeIdx fixField
    | AdvId fixField -> WriteAdvId dest nextFreeIdx fixField
    | AdvRefID fixField -> WriteAdvRefID dest nextFreeIdx fixField
    | AdvSide fixField -> WriteAdvSide dest nextFreeIdx fixField
    | AdvTransType fixField -> WriteAdvTransType dest nextFreeIdx fixField
    | AvgPx fixField -> WriteAvgPx dest nextFreeIdx fixField
    | BeginSeqNo fixField -> WriteBeginSeqNo dest nextFreeIdx fixField
    | BeginString fixField -> WriteBeginString dest nextFreeIdx fixField
    | BodyLength fixField -> WriteBodyLength dest nextFreeIdx fixField
    | CheckSum fixField -> WriteCheckSum dest nextFreeIdx fixField
    | ClOrdID fixField -> WriteClOrdID dest nextFreeIdx fixField
    | Commission fixField -> WriteCommission dest nextFreeIdx fixField
    | CommType fixField -> WriteCommType dest nextFreeIdx fixField
    | CumQty fixField -> WriteCumQty dest nextFreeIdx fixField
    | Currency fixField -> WriteCurrency dest nextFreeIdx fixField
    | EndSeqNo fixField -> WriteEndSeqNo dest nextFreeIdx fixField
    | ExecID fixField -> WriteExecID dest nextFreeIdx fixField
    | ExecInst fixField -> WriteExecInst dest nextFreeIdx fixField
    | ExecRefID fixField -> WriteExecRefID dest nextFreeIdx fixField
    | HandlInst fixField -> WriteHandlInst dest nextFreeIdx fixField
    | SecurityIDSource fixField -> WriteSecurityIDSource dest nextFreeIdx fixField
    | IOIid fixField -> WriteIOIid dest nextFreeIdx fixField
    | IOIQltyInd fixField -> WriteIOIQltyInd dest nextFreeIdx fixField
    | IOIRefID fixField -> WriteIOIRefID dest nextFreeIdx fixField
    | IOIQty fixField -> WriteIOIQty dest nextFreeIdx fixField
    | IOITransType fixField -> WriteIOITransType dest nextFreeIdx fixField
    | LastCapacity fixField -> WriteLastCapacity dest nextFreeIdx fixField
    | LastMkt fixField -> WriteLastMkt dest nextFreeIdx fixField
    | LastPx fixField -> WriteLastPx dest nextFreeIdx fixField
    | LastQty fixField -> WriteLastQty dest nextFreeIdx fixField
    | LinesOfText fixField -> WriteLinesOfText dest nextFreeIdx fixField
    | MsgSeqNum fixField -> WriteMsgSeqNum dest nextFreeIdx fixField
    | MsgType fixField -> WriteMsgType dest nextFreeIdx fixField
    | NewSeqNo fixField -> WriteNewSeqNo dest nextFreeIdx fixField
    | OrderID fixField -> WriteOrderID dest nextFreeIdx fixField
    | OrderQty fixField -> WriteOrderQty dest nextFreeIdx fixField
    | OrdStatus fixField -> WriteOrdStatus dest nextFreeIdx fixField
    | OrdType fixField -> WriteOrdType dest nextFreeIdx fixField
    | OrigClOrdID fixField -> WriteOrigClOrdID dest nextFreeIdx fixField
    | OrigTime fixField -> WriteOrigTime dest nextFreeIdx fixField
    | PossDupFlag fixField -> WritePossDupFlag dest nextFreeIdx fixField
    | Price fixField -> WritePrice dest nextFreeIdx fixField
    | RefSeqNum fixField -> WriteRefSeqNum dest nextFreeIdx fixField
    | SecurityID fixField -> WriteSecurityID dest nextFreeIdx fixField
    | SenderCompID fixField -> WriteSenderCompID dest nextFreeIdx fixField
    | SenderSubID fixField -> WriteSenderSubID dest nextFreeIdx fixField
    | SendingTime fixField -> WriteSendingTime dest nextFreeIdx fixField
    | Quantity fixField -> WriteQuantity dest nextFreeIdx fixField
    | Side fixField -> WriteSide dest nextFreeIdx fixField
    | Symbol fixField -> WriteSymbol dest nextFreeIdx fixField
    | TargetCompID fixField -> WriteTargetCompID dest nextFreeIdx fixField
    | TargetSubID fixField -> WriteTargetSubID dest nextFreeIdx fixField
    | Text fixField -> WriteText dest nextFreeIdx fixField
    | TimeInForce fixField -> WriteTimeInForce dest nextFreeIdx fixField
    | TransactTime fixField -> WriteTransactTime dest nextFreeIdx fixField
    | Urgency fixField -> WriteUrgency dest nextFreeIdx fixField
    | ValidUntilTime fixField -> WriteValidUntilTime dest nextFreeIdx fixField
    | SettlType fixField -> WriteSettlType dest nextFreeIdx fixField
    | SettlDate fixField -> WriteSettlDate dest nextFreeIdx fixField
    | SymbolSfx fixField -> WriteSymbolSfx dest nextFreeIdx fixField
    | ListID fixField -> WriteListID dest nextFreeIdx fixField
    | ListSeqNo fixField -> WriteListSeqNo dest nextFreeIdx fixField
    | TotNoOrders fixField -> WriteTotNoOrders dest nextFreeIdx fixField
    | ListExecInst fixField -> WriteListExecInst dest nextFreeIdx fixField
    | AllocID fixField -> WriteAllocID dest nextFreeIdx fixField
    | AllocTransType fixField -> WriteAllocTransType dest nextFreeIdx fixField
    | RefAllocID fixField -> WriteRefAllocID dest nextFreeIdx fixField
    | NoOrders fixField -> WriteNoOrders dest nextFreeIdx fixField
    | AvgPxPrecision fixField -> WriteAvgPxPrecision dest nextFreeIdx fixField
    | TradeDate fixField -> WriteTradeDate dest nextFreeIdx fixField
    | PositionEffect fixField -> WritePositionEffect dest nextFreeIdx fixField
    | NoAllocs fixField -> WriteNoAllocs dest nextFreeIdx fixField
    | AllocAccount fixField -> WriteAllocAccount dest nextFreeIdx fixField
    | AllocQty fixField -> WriteAllocQty dest nextFreeIdx fixField
    | ProcessCode fixField -> WriteProcessCode dest nextFreeIdx fixField
    | NoRpts fixField -> WriteNoRpts dest nextFreeIdx fixField
    | RptSeq fixField -> WriteRptSeq dest nextFreeIdx fixField
    | CxlQty fixField -> WriteCxlQty dest nextFreeIdx fixField
    | NoDlvyInst fixField -> WriteNoDlvyInst dest nextFreeIdx fixField
    | AllocStatus fixField -> WriteAllocStatus dest nextFreeIdx fixField
    | AllocRejCode fixField -> WriteAllocRejCode dest nextFreeIdx fixField
    | Signature fixField -> WriteSignature dest nextFreeIdx fixField
    | SecureData fixField -> WriteSecureData dest nextFreeIdx fixField // compound field
    | SignatureLength fixField -> WriteSignatureLength dest nextFreeIdx fixField
    | EmailType fixField -> WriteEmailType dest nextFreeIdx fixField
    | RawDataLength fixField -> WriteRawDataLength dest nextFreeIdx fixField
    | RawData fixField -> WriteRawData dest nextFreeIdx fixField
    | PossResend fixField -> WritePossResend dest nextFreeIdx fixField
    | EncryptMethod fixField -> WriteEncryptMethod dest nextFreeIdx fixField
    | StopPx fixField -> WriteStopPx dest nextFreeIdx fixField
    | ExDestination fixField -> WriteExDestination dest nextFreeIdx fixField
    | CxlRejReason fixField -> WriteCxlRejReason dest nextFreeIdx fixField
    | OrdRejReason fixField -> WriteOrdRejReason dest nextFreeIdx fixField
    | IOIQualifier fixField -> WriteIOIQualifier dest nextFreeIdx fixField
    | WaveNo fixField -> WriteWaveNo dest nextFreeIdx fixField
    | Issuer fixField -> WriteIssuer dest nextFreeIdx fixField
    | SecurityDesc fixField -> WriteSecurityDesc dest nextFreeIdx fixField
    | HeartBtInt fixField -> WriteHeartBtInt dest nextFreeIdx fixField
    | MinQty fixField -> WriteMinQty dest nextFreeIdx fixField
    | MaxFloor fixField -> WriteMaxFloor dest nextFreeIdx fixField
    | TestReqID fixField -> WriteTestReqID dest nextFreeIdx fixField
    | ReportToExch fixField -> WriteReportToExch dest nextFreeIdx fixField
    | LocateReqd fixField -> WriteLocateReqd dest nextFreeIdx fixField
    | OnBehalfOfCompID fixField -> WriteOnBehalfOfCompID dest nextFreeIdx fixField
    | OnBehalfOfSubID fixField -> WriteOnBehalfOfSubID dest nextFreeIdx fixField
    | QuoteID fixField -> WriteQuoteID dest nextFreeIdx fixField
    | NetMoney fixField -> WriteNetMoney dest nextFreeIdx fixField
    | SettlCurrAmt fixField -> WriteSettlCurrAmt dest nextFreeIdx fixField
    | SettlCurrency fixField -> WriteSettlCurrency dest nextFreeIdx fixField
    | ForexReq fixField -> WriteForexReq dest nextFreeIdx fixField
    | OrigSendingTime fixField -> WriteOrigSendingTime dest nextFreeIdx fixField
    | GapFillFlag fixField -> WriteGapFillFlag dest nextFreeIdx fixField
    | NoExecs fixField -> WriteNoExecs dest nextFreeIdx fixField
    | ExpireTime fixField -> WriteExpireTime dest nextFreeIdx fixField
    | DKReason fixField -> WriteDKReason dest nextFreeIdx fixField
    | DeliverToCompID fixField -> WriteDeliverToCompID dest nextFreeIdx fixField
    | DeliverToSubID fixField -> WriteDeliverToSubID dest nextFreeIdx fixField
    | IOINaturalFlag fixField -> WriteIOINaturalFlag dest nextFreeIdx fixField
    | QuoteReqID fixField -> WriteQuoteReqID dest nextFreeIdx fixField
    | BidPx fixField -> WriteBidPx dest nextFreeIdx fixField
    | OfferPx fixField -> WriteOfferPx dest nextFreeIdx fixField
    | BidSize fixField -> WriteBidSize dest nextFreeIdx fixField
    | OfferSize fixField -> WriteOfferSize dest nextFreeIdx fixField
    | NoMiscFees fixField -> WriteNoMiscFees dest nextFreeIdx fixField
    | MiscFeeAmt fixField -> WriteMiscFeeAmt dest nextFreeIdx fixField
    | MiscFeeCurr fixField -> WriteMiscFeeCurr dest nextFreeIdx fixField
    | MiscFeeType fixField -> WriteMiscFeeType dest nextFreeIdx fixField
    | PrevClosePx fixField -> WritePrevClosePx dest nextFreeIdx fixField
    | ResetSeqNumFlag fixField -> WriteResetSeqNumFlag dest nextFreeIdx fixField
    | SenderLocationID fixField -> WriteSenderLocationID dest nextFreeIdx fixField
    | TargetLocationID fixField -> WriteTargetLocationID dest nextFreeIdx fixField
    | OnBehalfOfLocationID fixField -> WriteOnBehalfOfLocationID dest nextFreeIdx fixField
    | DeliverToLocationID fixField -> WriteDeliverToLocationID dest nextFreeIdx fixField
    | NoRelatedSym fixField -> WriteNoRelatedSym dest nextFreeIdx fixField
    | Subject fixField -> WriteSubject dest nextFreeIdx fixField
    | Headline fixField -> WriteHeadline dest nextFreeIdx fixField
    | URLLink fixField -> WriteURLLink dest nextFreeIdx fixField
    | ExecType fixField -> WriteExecType dest nextFreeIdx fixField
    | LeavesQty fixField -> WriteLeavesQty dest nextFreeIdx fixField
    | CashOrderQty fixField -> WriteCashOrderQty dest nextFreeIdx fixField
    | AllocAvgPx fixField -> WriteAllocAvgPx dest nextFreeIdx fixField
    | AllocNetMoney fixField -> WriteAllocNetMoney dest nextFreeIdx fixField
    | SettlCurrFxRate fixField -> WriteSettlCurrFxRate dest nextFreeIdx fixField
    | SettlCurrFxRateCalc fixField -> WriteSettlCurrFxRateCalc dest nextFreeIdx fixField
    | NumDaysInterest fixField -> WriteNumDaysInterest dest nextFreeIdx fixField
    | AccruedInterestRate fixField -> WriteAccruedInterestRate dest nextFreeIdx fixField
    | AccruedInterestAmt fixField -> WriteAccruedInterestAmt dest nextFreeIdx fixField
    | SettlInstMode fixField -> WriteSettlInstMode dest nextFreeIdx fixField
    | AllocText fixField -> WriteAllocText dest nextFreeIdx fixField
    | SettlInstID fixField -> WriteSettlInstID dest nextFreeIdx fixField
    | SettlInstTransType fixField -> WriteSettlInstTransType dest nextFreeIdx fixField
    | EmailThreadID fixField -> WriteEmailThreadID dest nextFreeIdx fixField
    | SettlInstSource fixField -> WriteSettlInstSource dest nextFreeIdx fixField
    | SecurityType fixField -> WriteSecurityType dest nextFreeIdx fixField
    | EffectiveTime fixField -> WriteEffectiveTime dest nextFreeIdx fixField
    | StandInstDbType fixField -> WriteStandInstDbType dest nextFreeIdx fixField
    | StandInstDbName fixField -> WriteStandInstDbName dest nextFreeIdx fixField
    | StandInstDbID fixField -> WriteStandInstDbID dest nextFreeIdx fixField
    | SettlDeliveryType fixField -> WriteSettlDeliveryType dest nextFreeIdx fixField
    | BidSpotRate fixField -> WriteBidSpotRate dest nextFreeIdx fixField
    | BidForwardPoints fixField -> WriteBidForwardPoints dest nextFreeIdx fixField
    | OfferSpotRate fixField -> WriteOfferSpotRate dest nextFreeIdx fixField
    | OfferForwardPoints fixField -> WriteOfferForwardPoints dest nextFreeIdx fixField
    | OrderQty2 fixField -> WriteOrderQty2 dest nextFreeIdx fixField
    | SettlDate2 fixField -> WriteSettlDate2 dest nextFreeIdx fixField
    | LastSpotRate fixField -> WriteLastSpotRate dest nextFreeIdx fixField
    | LastForwardPoints fixField -> WriteLastForwardPoints dest nextFreeIdx fixField
    | AllocLinkID fixField -> WriteAllocLinkID dest nextFreeIdx fixField
    | AllocLinkType fixField -> WriteAllocLinkType dest nextFreeIdx fixField
    | SecondaryOrderID fixField -> WriteSecondaryOrderID dest nextFreeIdx fixField
    | NoIOIQualifiers fixField -> WriteNoIOIQualifiers dest nextFreeIdx fixField
    | MaturityMonthYear fixField -> WriteMaturityMonthYear dest nextFreeIdx fixField
    | PutOrCall fixField -> WritePutOrCall dest nextFreeIdx fixField
    | StrikePrice fixField -> WriteStrikePrice dest nextFreeIdx fixField
    | CoveredOrUncovered fixField -> WriteCoveredOrUncovered dest nextFreeIdx fixField
    | OptAttribute fixField -> WriteOptAttribute dest nextFreeIdx fixField
    | SecurityExchange fixField -> WriteSecurityExchange dest nextFreeIdx fixField
    | NotifyBrokerOfCredit fixField -> WriteNotifyBrokerOfCredit dest nextFreeIdx fixField
    | AllocHandlInst fixField -> WriteAllocHandlInst dest nextFreeIdx fixField
    | MaxShow fixField -> WriteMaxShow dest nextFreeIdx fixField
    | PegOffsetValue fixField -> WritePegOffsetValue dest nextFreeIdx fixField
    | XmlData fixField -> WriteXmlData dest nextFreeIdx fixField // compound field
    | SettlInstRefID fixField -> WriteSettlInstRefID dest nextFreeIdx fixField
    | NoRoutingIDs fixField -> WriteNoRoutingIDs dest nextFreeIdx fixField
    | RoutingType fixField -> WriteRoutingType dest nextFreeIdx fixField
    | RoutingID fixField -> WriteRoutingID dest nextFreeIdx fixField
    | Spread fixField -> WriteSpread dest nextFreeIdx fixField
    | BenchmarkCurveCurrency fixField -> WriteBenchmarkCurveCurrency dest nextFreeIdx fixField
    | BenchmarkCurveName fixField -> WriteBenchmarkCurveName dest nextFreeIdx fixField
    | BenchmarkCurvePoint fixField -> WriteBenchmarkCurvePoint dest nextFreeIdx fixField
    | CouponRate fixField -> WriteCouponRate dest nextFreeIdx fixField
    | CouponPaymentDate fixField -> WriteCouponPaymentDate dest nextFreeIdx fixField
    | IssueDate fixField -> WriteIssueDate dest nextFreeIdx fixField
    | RepurchaseTerm fixField -> WriteRepurchaseTerm dest nextFreeIdx fixField
    | RepurchaseRate fixField -> WriteRepurchaseRate dest nextFreeIdx fixField
    | Factor fixField -> WriteFactor dest nextFreeIdx fixField
    | TradeOriginationDate fixField -> WriteTradeOriginationDate dest nextFreeIdx fixField
    | ExDate fixField -> WriteExDate dest nextFreeIdx fixField
    | ContractMultiplier fixField -> WriteContractMultiplier dest nextFreeIdx fixField
    | NoStipulations fixField -> WriteNoStipulations dest nextFreeIdx fixField
    | StipulationType fixField -> WriteStipulationType dest nextFreeIdx fixField
    | StipulationValue fixField -> WriteStipulationValue dest nextFreeIdx fixField
    | YieldType fixField -> WriteYieldType dest nextFreeIdx fixField
    | Yield fixField -> WriteYield dest nextFreeIdx fixField
    | TotalTakedown fixField -> WriteTotalTakedown dest nextFreeIdx fixField
    | Concession fixField -> WriteConcession dest nextFreeIdx fixField
    | RepoCollateralSecurityType fixField -> WriteRepoCollateralSecurityType dest nextFreeIdx fixField
    | RedemptionDate fixField -> WriteRedemptionDate dest nextFreeIdx fixField
    | UnderlyingCouponPaymentDate fixField -> WriteUnderlyingCouponPaymentDate dest nextFreeIdx fixField
    | UnderlyingIssueDate fixField -> WriteUnderlyingIssueDate dest nextFreeIdx fixField
    | UnderlyingRepoCollateralSecurityType fixField -> WriteUnderlyingRepoCollateralSecurityType dest nextFreeIdx fixField
    | UnderlyingRepurchaseTerm fixField -> WriteUnderlyingRepurchaseTerm dest nextFreeIdx fixField
    | UnderlyingRepurchaseRate fixField -> WriteUnderlyingRepurchaseRate dest nextFreeIdx fixField
    | UnderlyingFactor fixField -> WriteUnderlyingFactor dest nextFreeIdx fixField
    | UnderlyingRedemptionDate fixField -> WriteUnderlyingRedemptionDate dest nextFreeIdx fixField
    | LegCouponPaymentDate fixField -> WriteLegCouponPaymentDate dest nextFreeIdx fixField
    | LegIssueDate fixField -> WriteLegIssueDate dest nextFreeIdx fixField
    | LegRepoCollateralSecurityType fixField -> WriteLegRepoCollateralSecurityType dest nextFreeIdx fixField
    | LegRepurchaseTerm fixField -> WriteLegRepurchaseTerm dest nextFreeIdx fixField
    | LegRepurchaseRate fixField -> WriteLegRepurchaseRate dest nextFreeIdx fixField
    | LegFactor fixField -> WriteLegFactor dest nextFreeIdx fixField
    | LegRedemptionDate fixField -> WriteLegRedemptionDate dest nextFreeIdx fixField
    | CreditRating fixField -> WriteCreditRating dest nextFreeIdx fixField
    | UnderlyingCreditRating fixField -> WriteUnderlyingCreditRating dest nextFreeIdx fixField
    | LegCreditRating fixField -> WriteLegCreditRating dest nextFreeIdx fixField
    | TradedFlatSwitch fixField -> WriteTradedFlatSwitch dest nextFreeIdx fixField
    | BasisFeatureDate fixField -> WriteBasisFeatureDate dest nextFreeIdx fixField
    | BasisFeaturePrice fixField -> WriteBasisFeaturePrice dest nextFreeIdx fixField
    | MDReqID fixField -> WriteMDReqID dest nextFreeIdx fixField
    | SubscriptionRequestType fixField -> WriteSubscriptionRequestType dest nextFreeIdx fixField
    | MarketDepth fixField -> WriteMarketDepth dest nextFreeIdx fixField
    | MDUpdateType fixField -> WriteMDUpdateType dest nextFreeIdx fixField
    | AggregatedBook fixField -> WriteAggregatedBook dest nextFreeIdx fixField
    | NoMDEntryTypes fixField -> WriteNoMDEntryTypes dest nextFreeIdx fixField
    | NoMDEntries fixField -> WriteNoMDEntries dest nextFreeIdx fixField
    | MDEntryType fixField -> WriteMDEntryType dest nextFreeIdx fixField
    | MDEntryPx fixField -> WriteMDEntryPx dest nextFreeIdx fixField
    | MDEntrySize fixField -> WriteMDEntrySize dest nextFreeIdx fixField
    | MDEntryDate fixField -> WriteMDEntryDate dest nextFreeIdx fixField
    | MDEntryTime fixField -> WriteMDEntryTime dest nextFreeIdx fixField
    | TickDirection fixField -> WriteTickDirection dest nextFreeIdx fixField
    | MDMkt fixField -> WriteMDMkt dest nextFreeIdx fixField
    | QuoteCondition fixField -> WriteQuoteCondition dest nextFreeIdx fixField
    | TradeCondition fixField -> WriteTradeCondition dest nextFreeIdx fixField
    | MDEntryID fixField -> WriteMDEntryID dest nextFreeIdx fixField
    | MDUpdateAction fixField -> WriteMDUpdateAction dest nextFreeIdx fixField
    | MDEntryRefID fixField -> WriteMDEntryRefID dest nextFreeIdx fixField
    | MDReqRejReason fixField -> WriteMDReqRejReason dest nextFreeIdx fixField
    | MDEntryOriginator fixField -> WriteMDEntryOriginator dest nextFreeIdx fixField
    | LocationID fixField -> WriteLocationID dest nextFreeIdx fixField
    | DeskID fixField -> WriteDeskID dest nextFreeIdx fixField
    | DeleteReason fixField -> WriteDeleteReason dest nextFreeIdx fixField
    | OpenCloseSettlFlag fixField -> WriteOpenCloseSettlFlag dest nextFreeIdx fixField
    | SellerDays fixField -> WriteSellerDays dest nextFreeIdx fixField
    | MDEntryBuyer fixField -> WriteMDEntryBuyer dest nextFreeIdx fixField
    | MDEntrySeller fixField -> WriteMDEntrySeller dest nextFreeIdx fixField
    | MDEntryPositionNo fixField -> WriteMDEntryPositionNo dest nextFreeIdx fixField
    | FinancialStatus fixField -> WriteFinancialStatus dest nextFreeIdx fixField
    | CorporateAction fixField -> WriteCorporateAction dest nextFreeIdx fixField
    | DefBidSize fixField -> WriteDefBidSize dest nextFreeIdx fixField
    | DefOfferSize fixField -> WriteDefOfferSize dest nextFreeIdx fixField
    | NoQuoteEntries fixField -> WriteNoQuoteEntries dest nextFreeIdx fixField
    | NoQuoteSets fixField -> WriteNoQuoteSets dest nextFreeIdx fixField
    | QuoteStatus fixField -> WriteQuoteStatus dest nextFreeIdx fixField
    | QuoteCancelType fixField -> WriteQuoteCancelType dest nextFreeIdx fixField
    | QuoteEntryID fixField -> WriteQuoteEntryID dest nextFreeIdx fixField
    | QuoteRejectReason fixField -> WriteQuoteRejectReason dest nextFreeIdx fixField
    | QuoteResponseLevel fixField -> WriteQuoteResponseLevel dest nextFreeIdx fixField
    | QuoteSetID fixField -> WriteQuoteSetID dest nextFreeIdx fixField
    | QuoteRequestType fixField -> WriteQuoteRequestType dest nextFreeIdx fixField
    | TotNoQuoteEntries fixField -> WriteTotNoQuoteEntries dest nextFreeIdx fixField
    | UnderlyingSecurityIDSource fixField -> WriteUnderlyingSecurityIDSource dest nextFreeIdx fixField
    | UnderlyingIssuer fixField -> WriteUnderlyingIssuer dest nextFreeIdx fixField
    | UnderlyingSecurityDesc fixField -> WriteUnderlyingSecurityDesc dest nextFreeIdx fixField
    | UnderlyingSecurityExchange fixField -> WriteUnderlyingSecurityExchange dest nextFreeIdx fixField
    | UnderlyingSecurityID fixField -> WriteUnderlyingSecurityID dest nextFreeIdx fixField
    | UnderlyingSecurityType fixField -> WriteUnderlyingSecurityType dest nextFreeIdx fixField
    | UnderlyingSymbol fixField -> WriteUnderlyingSymbol dest nextFreeIdx fixField
    | UnderlyingSymbolSfx fixField -> WriteUnderlyingSymbolSfx dest nextFreeIdx fixField
    | UnderlyingMaturityMonthYear fixField -> WriteUnderlyingMaturityMonthYear dest nextFreeIdx fixField
    | UnderlyingPutOrCall fixField -> WriteUnderlyingPutOrCall dest nextFreeIdx fixField
    | UnderlyingStrikePrice fixField -> WriteUnderlyingStrikePrice dest nextFreeIdx fixField
    | UnderlyingOptAttribute fixField -> WriteUnderlyingOptAttribute dest nextFreeIdx fixField
    | UnderlyingCurrency fixField -> WriteUnderlyingCurrency dest nextFreeIdx fixField
    | SecurityReqID fixField -> WriteSecurityReqID dest nextFreeIdx fixField
    | SecurityRequestType fixField -> WriteSecurityRequestType dest nextFreeIdx fixField
    | SecurityResponseID fixField -> WriteSecurityResponseID dest nextFreeIdx fixField
    | SecurityResponseType fixField -> WriteSecurityResponseType dest nextFreeIdx fixField
    | SecurityStatusReqID fixField -> WriteSecurityStatusReqID dest nextFreeIdx fixField
    | UnsolicitedIndicator fixField -> WriteUnsolicitedIndicator dest nextFreeIdx fixField
    | SecurityTradingStatus fixField -> WriteSecurityTradingStatus dest nextFreeIdx fixField
    | HaltReason fixField -> WriteHaltReason dest nextFreeIdx fixField
    | InViewOfCommon fixField -> WriteInViewOfCommon dest nextFreeIdx fixField
    | DueToRelated fixField -> WriteDueToRelated dest nextFreeIdx fixField
    | BuyVolume fixField -> WriteBuyVolume dest nextFreeIdx fixField
    | SellVolume fixField -> WriteSellVolume dest nextFreeIdx fixField
    | HighPx fixField -> WriteHighPx dest nextFreeIdx fixField
    | LowPx fixField -> WriteLowPx dest nextFreeIdx fixField
    | Adjustment fixField -> WriteAdjustment dest nextFreeIdx fixField
    | TradSesReqID fixField -> WriteTradSesReqID dest nextFreeIdx fixField
    | TradingSessionID fixField -> WriteTradingSessionID dest nextFreeIdx fixField
    | ContraTrader fixField -> WriteContraTrader dest nextFreeIdx fixField
    | TradSesMethod fixField -> WriteTradSesMethod dest nextFreeIdx fixField
    | TradSesMode fixField -> WriteTradSesMode dest nextFreeIdx fixField
    | TradSesStatus fixField -> WriteTradSesStatus dest nextFreeIdx fixField
    | TradSesStartTime fixField -> WriteTradSesStartTime dest nextFreeIdx fixField
    | TradSesOpenTime fixField -> WriteTradSesOpenTime dest nextFreeIdx fixField
    | TradSesPreCloseTime fixField -> WriteTradSesPreCloseTime dest nextFreeIdx fixField
    | TradSesCloseTime fixField -> WriteTradSesCloseTime dest nextFreeIdx fixField
    | TradSesEndTime fixField -> WriteTradSesEndTime dest nextFreeIdx fixField
    | NumberOfOrders fixField -> WriteNumberOfOrders dest nextFreeIdx fixField
    | MessageEncoding fixField -> WriteMessageEncoding dest nextFreeIdx fixField
    | EncodedIssuer fixField -> WriteEncodedIssuer dest nextFreeIdx fixField // compound field
    | EncodedSecurityDesc fixField -> WriteEncodedSecurityDesc dest nextFreeIdx fixField // compound field
    | EncodedListExecInst fixField -> WriteEncodedListExecInst dest nextFreeIdx fixField // compound field
    | EncodedText fixField -> WriteEncodedText dest nextFreeIdx fixField // compound field
    | EncodedSubject fixField -> WriteEncodedSubject dest nextFreeIdx fixField // compound field
    | EncodedHeadline fixField -> WriteEncodedHeadline dest nextFreeIdx fixField // compound field
    | EncodedAllocText fixField -> WriteEncodedAllocText dest nextFreeIdx fixField // compound field
    | EncodedUnderlyingIssuer fixField -> WriteEncodedUnderlyingIssuer dest nextFreeIdx fixField // compound field
    | EncodedUnderlyingSecurityDesc fixField -> WriteEncodedUnderlyingSecurityDesc dest nextFreeIdx fixField // compound field
    | AllocPrice fixField -> WriteAllocPrice dest nextFreeIdx fixField
    | QuoteSetValidUntilTime fixField -> WriteQuoteSetValidUntilTime dest nextFreeIdx fixField
    | QuoteEntryRejectReason fixField -> WriteQuoteEntryRejectReason dest nextFreeIdx fixField
    | LastMsgSeqNumProcessed fixField -> WriteLastMsgSeqNumProcessed dest nextFreeIdx fixField
    | RefTagID fixField -> WriteRefTagID dest nextFreeIdx fixField
    | RefMsgType fixField -> WriteRefMsgType dest nextFreeIdx fixField
    | SessionRejectReason fixField -> WriteSessionRejectReason dest nextFreeIdx fixField
    | BidRequestTransType fixField -> WriteBidRequestTransType dest nextFreeIdx fixField
    | ContraBroker fixField -> WriteContraBroker dest nextFreeIdx fixField
    | ComplianceID fixField -> WriteComplianceID dest nextFreeIdx fixField
    | SolicitedFlag fixField -> WriteSolicitedFlag dest nextFreeIdx fixField
    | ExecRestatementReason fixField -> WriteExecRestatementReason dest nextFreeIdx fixField
    | BusinessRejectRefID fixField -> WriteBusinessRejectRefID dest nextFreeIdx fixField
    | BusinessRejectReason fixField -> WriteBusinessRejectReason dest nextFreeIdx fixField
    | GrossTradeAmt fixField -> WriteGrossTradeAmt dest nextFreeIdx fixField
    | NoContraBrokers fixField -> WriteNoContraBrokers dest nextFreeIdx fixField
    | MaxMessageSize fixField -> WriteMaxMessageSize dest nextFreeIdx fixField
    | NoMsgTypes fixField -> WriteNoMsgTypes dest nextFreeIdx fixField
    | MsgDirection fixField -> WriteMsgDirection dest nextFreeIdx fixField
    | NoTradingSessions fixField -> WriteNoTradingSessions dest nextFreeIdx fixField
    | TotalVolumeTraded fixField -> WriteTotalVolumeTraded dest nextFreeIdx fixField
    | DiscretionInst fixField -> WriteDiscretionInst dest nextFreeIdx fixField
    | DiscretionOffsetValue fixField -> WriteDiscretionOffsetValue dest nextFreeIdx fixField
    | BidID fixField -> WriteBidID dest nextFreeIdx fixField
    | ClientBidID fixField -> WriteClientBidID dest nextFreeIdx fixField
    | ListName fixField -> WriteListName dest nextFreeIdx fixField
    | TotNoRelatedSym fixField -> WriteTotNoRelatedSym dest nextFreeIdx fixField
    | BidType fixField -> WriteBidType dest nextFreeIdx fixField
    | NumTickets fixField -> WriteNumTickets dest nextFreeIdx fixField
    | SideValue1 fixField -> WriteSideValue1 dest nextFreeIdx fixField
    | SideValue2 fixField -> WriteSideValue2 dest nextFreeIdx fixField
    | NoBidDescriptors fixField -> WriteNoBidDescriptors dest nextFreeIdx fixField
    | BidDescriptorType fixField -> WriteBidDescriptorType dest nextFreeIdx fixField
    | BidDescriptor fixField -> WriteBidDescriptor dest nextFreeIdx fixField
    | SideValueInd fixField -> WriteSideValueInd dest nextFreeIdx fixField
    | LiquidityPctLow fixField -> WriteLiquidityPctLow dest nextFreeIdx fixField
    | LiquidityPctHigh fixField -> WriteLiquidityPctHigh dest nextFreeIdx fixField
    | LiquidityValue fixField -> WriteLiquidityValue dest nextFreeIdx fixField
    | EFPTrackingError fixField -> WriteEFPTrackingError dest nextFreeIdx fixField
    | FairValue fixField -> WriteFairValue dest nextFreeIdx fixField
    | OutsideIndexPct fixField -> WriteOutsideIndexPct dest nextFreeIdx fixField
    | ValueOfFutures fixField -> WriteValueOfFutures dest nextFreeIdx fixField
    | LiquidityIndType fixField -> WriteLiquidityIndType dest nextFreeIdx fixField
    | WtAverageLiquidity fixField -> WriteWtAverageLiquidity dest nextFreeIdx fixField
    | ExchangeForPhysical fixField -> WriteExchangeForPhysical dest nextFreeIdx fixField
    | OutMainCntryUIndex fixField -> WriteOutMainCntryUIndex dest nextFreeIdx fixField
    | CrossPercent fixField -> WriteCrossPercent dest nextFreeIdx fixField
    | ProgRptReqs fixField -> WriteProgRptReqs dest nextFreeIdx fixField
    | ProgPeriodInterval fixField -> WriteProgPeriodInterval dest nextFreeIdx fixField
    | IncTaxInd fixField -> WriteIncTaxInd dest nextFreeIdx fixField
    | NumBidders fixField -> WriteNumBidders dest nextFreeIdx fixField
    | BidTradeType fixField -> WriteBidTradeType dest nextFreeIdx fixField
    | BasisPxType fixField -> WriteBasisPxType dest nextFreeIdx fixField
    | NoBidComponents fixField -> WriteNoBidComponents dest nextFreeIdx fixField
    | Country fixField -> WriteCountry dest nextFreeIdx fixField
    | TotNoStrikes fixField -> WriteTotNoStrikes dest nextFreeIdx fixField
    | PriceType fixField -> WritePriceType dest nextFreeIdx fixField
    | DayOrderQty fixField -> WriteDayOrderQty dest nextFreeIdx fixField
    | DayCumQty fixField -> WriteDayCumQty dest nextFreeIdx fixField
    | DayAvgPx fixField -> WriteDayAvgPx dest nextFreeIdx fixField
    | GTBookingInst fixField -> WriteGTBookingInst dest nextFreeIdx fixField
    | NoStrikes fixField -> WriteNoStrikes dest nextFreeIdx fixField
    | ListStatusType fixField -> WriteListStatusType dest nextFreeIdx fixField
    | NetGrossInd fixField -> WriteNetGrossInd dest nextFreeIdx fixField
    | ListOrderStatus fixField -> WriteListOrderStatus dest nextFreeIdx fixField
    | ExpireDate fixField -> WriteExpireDate dest nextFreeIdx fixField
    | ListExecInstType fixField -> WriteListExecInstType dest nextFreeIdx fixField
    | CxlRejResponseTo fixField -> WriteCxlRejResponseTo dest nextFreeIdx fixField
    | UnderlyingCouponRate fixField -> WriteUnderlyingCouponRate dest nextFreeIdx fixField
    | UnderlyingContractMultiplier fixField -> WriteUnderlyingContractMultiplier dest nextFreeIdx fixField
    | ContraTradeQty fixField -> WriteContraTradeQty dest nextFreeIdx fixField
    | ContraTradeTime fixField -> WriteContraTradeTime dest nextFreeIdx fixField
    | LiquidityNumSecurities fixField -> WriteLiquidityNumSecurities dest nextFreeIdx fixField
    | MultiLegReportingType fixField -> WriteMultiLegReportingType dest nextFreeIdx fixField
    | StrikeTime fixField -> WriteStrikeTime dest nextFreeIdx fixField
    | ListStatusText fixField -> WriteListStatusText dest nextFreeIdx fixField
    | EncodedListStatusText fixField -> WriteEncodedListStatusText dest nextFreeIdx fixField // compound field
    | PartyIDSource fixField -> WritePartyIDSource dest nextFreeIdx fixField
    | PartyID fixField -> WritePartyID dest nextFreeIdx fixField
    | NetChgPrevDay fixField -> WriteNetChgPrevDay dest nextFreeIdx fixField
    | PartyRole fixField -> WritePartyRole dest nextFreeIdx fixField
    | NoPartyIDs fixField -> WriteNoPartyIDs dest nextFreeIdx fixField
    | NoSecurityAltID fixField -> WriteNoSecurityAltID dest nextFreeIdx fixField
    | SecurityAltID fixField -> WriteSecurityAltID dest nextFreeIdx fixField
    | SecurityAltIDSource fixField -> WriteSecurityAltIDSource dest nextFreeIdx fixField
    | NoUnderlyingSecurityAltID fixField -> WriteNoUnderlyingSecurityAltID dest nextFreeIdx fixField
    | UnderlyingSecurityAltID fixField -> WriteUnderlyingSecurityAltID dest nextFreeIdx fixField
    | UnderlyingSecurityAltIDSource fixField -> WriteUnderlyingSecurityAltIDSource dest nextFreeIdx fixField
    | Product fixField -> WriteProduct dest nextFreeIdx fixField
    | CFICode fixField -> WriteCFICode dest nextFreeIdx fixField
    | UnderlyingProduct fixField -> WriteUnderlyingProduct dest nextFreeIdx fixField
    | UnderlyingCFICode fixField -> WriteUnderlyingCFICode dest nextFreeIdx fixField
    | TestMessageIndicator fixField -> WriteTestMessageIndicator dest nextFreeIdx fixField
    | QuantityType fixField -> WriteQuantityType dest nextFreeIdx fixField
    | BookingRefID fixField -> WriteBookingRefID dest nextFreeIdx fixField
    | IndividualAllocID fixField -> WriteIndividualAllocID dest nextFreeIdx fixField
    | RoundingDirection fixField -> WriteRoundingDirection dest nextFreeIdx fixField
    | RoundingModulus fixField -> WriteRoundingModulus dest nextFreeIdx fixField
    | CountryOfIssue fixField -> WriteCountryOfIssue dest nextFreeIdx fixField
    | StateOrProvinceOfIssue fixField -> WriteStateOrProvinceOfIssue dest nextFreeIdx fixField
    | LocaleOfIssue fixField -> WriteLocaleOfIssue dest nextFreeIdx fixField
    | NoRegistDtls fixField -> WriteNoRegistDtls dest nextFreeIdx fixField
    | MailingDtls fixField -> WriteMailingDtls dest nextFreeIdx fixField
    | InvestorCountryOfResidence fixField -> WriteInvestorCountryOfResidence dest nextFreeIdx fixField
    | PaymentRef fixField -> WritePaymentRef dest nextFreeIdx fixField
    | DistribPaymentMethod fixField -> WriteDistribPaymentMethod dest nextFreeIdx fixField
    | CashDistribCurr fixField -> WriteCashDistribCurr dest nextFreeIdx fixField
    | CommCurrency fixField -> WriteCommCurrency dest nextFreeIdx fixField
    | CancellationRights fixField -> WriteCancellationRights dest nextFreeIdx fixField
    | MoneyLaunderingStatus fixField -> WriteMoneyLaunderingStatus dest nextFreeIdx fixField
    | MailingInst fixField -> WriteMailingInst dest nextFreeIdx fixField
    | TransBkdTime fixField -> WriteTransBkdTime dest nextFreeIdx fixField
    | ExecPriceType fixField -> WriteExecPriceType dest nextFreeIdx fixField
    | ExecPriceAdjustment fixField -> WriteExecPriceAdjustment dest nextFreeIdx fixField
    | DateOfBirth fixField -> WriteDateOfBirth dest nextFreeIdx fixField
    | TradeReportTransType fixField -> WriteTradeReportTransType dest nextFreeIdx fixField
    | CardHolderName fixField -> WriteCardHolderName dest nextFreeIdx fixField
    | CardNumber fixField -> WriteCardNumber dest nextFreeIdx fixField
    | CardExpDate fixField -> WriteCardExpDate dest nextFreeIdx fixField
    | CardIssNum fixField -> WriteCardIssNum dest nextFreeIdx fixField
    | PaymentMethod fixField -> WritePaymentMethod dest nextFreeIdx fixField
    | RegistAcctType fixField -> WriteRegistAcctType dest nextFreeIdx fixField
    | Designation fixField -> WriteDesignation dest nextFreeIdx fixField
    | TaxAdvantageType fixField -> WriteTaxAdvantageType dest nextFreeIdx fixField
    | RegistRejReasonText fixField -> WriteRegistRejReasonText dest nextFreeIdx fixField
    | FundRenewWaiv fixField -> WriteFundRenewWaiv dest nextFreeIdx fixField
    | CashDistribAgentName fixField -> WriteCashDistribAgentName dest nextFreeIdx fixField
    | CashDistribAgentCode fixField -> WriteCashDistribAgentCode dest nextFreeIdx fixField
    | CashDistribAgentAcctNumber fixField -> WriteCashDistribAgentAcctNumber dest nextFreeIdx fixField
    | CashDistribPayRef fixField -> WriteCashDistribPayRef dest nextFreeIdx fixField
    | CashDistribAgentAcctName fixField -> WriteCashDistribAgentAcctName dest nextFreeIdx fixField
    | CardStartDate fixField -> WriteCardStartDate dest nextFreeIdx fixField
    | PaymentDate fixField -> WritePaymentDate dest nextFreeIdx fixField
    | PaymentRemitterID fixField -> WritePaymentRemitterID dest nextFreeIdx fixField
    | RegistStatus fixField -> WriteRegistStatus dest nextFreeIdx fixField
    | RegistRejReasonCode fixField -> WriteRegistRejReasonCode dest nextFreeIdx fixField
    | RegistRefID fixField -> WriteRegistRefID dest nextFreeIdx fixField
    | RegistDtls fixField -> WriteRegistDtls dest nextFreeIdx fixField
    | NoDistribInsts fixField -> WriteNoDistribInsts dest nextFreeIdx fixField
    | RegistEmail fixField -> WriteRegistEmail dest nextFreeIdx fixField
    | DistribPercentage fixField -> WriteDistribPercentage dest nextFreeIdx fixField
    | RegistID fixField -> WriteRegistID dest nextFreeIdx fixField
    | RegistTransType fixField -> WriteRegistTransType dest nextFreeIdx fixField
    | ExecValuationPoint fixField -> WriteExecValuationPoint dest nextFreeIdx fixField
    | OrderPercent fixField -> WriteOrderPercent dest nextFreeIdx fixField
    | OwnershipType fixField -> WriteOwnershipType dest nextFreeIdx fixField
    | NoContAmts fixField -> WriteNoContAmts dest nextFreeIdx fixField
    | ContAmtType fixField -> WriteContAmtType dest nextFreeIdx fixField
    | ContAmtValue fixField -> WriteContAmtValue dest nextFreeIdx fixField
    | ContAmtCurr fixField -> WriteContAmtCurr dest nextFreeIdx fixField
    | OwnerType fixField -> WriteOwnerType dest nextFreeIdx fixField
    | PartySubID fixField -> WritePartySubID dest nextFreeIdx fixField
    | NestedPartyID fixField -> WriteNestedPartyID dest nextFreeIdx fixField
    | NestedPartyIDSource fixField -> WriteNestedPartyIDSource dest nextFreeIdx fixField
    | SecondaryClOrdID fixField -> WriteSecondaryClOrdID dest nextFreeIdx fixField
    | SecondaryExecID fixField -> WriteSecondaryExecID dest nextFreeIdx fixField
    | OrderCapacity fixField -> WriteOrderCapacity dest nextFreeIdx fixField
    | OrderRestrictions fixField -> WriteOrderRestrictions dest nextFreeIdx fixField
    | MassCancelRequestType fixField -> WriteMassCancelRequestType dest nextFreeIdx fixField
    | MassCancelResponse fixField -> WriteMassCancelResponse dest nextFreeIdx fixField
    | MassCancelRejectReason fixField -> WriteMassCancelRejectReason dest nextFreeIdx fixField
    | TotalAffectedOrders fixField -> WriteTotalAffectedOrders dest nextFreeIdx fixField
    | NoAffectedOrders fixField -> WriteNoAffectedOrders dest nextFreeIdx fixField
    | AffectedOrderID fixField -> WriteAffectedOrderID dest nextFreeIdx fixField
    | AffectedSecondaryOrderID fixField -> WriteAffectedSecondaryOrderID dest nextFreeIdx fixField
    | QuoteType fixField -> WriteQuoteType dest nextFreeIdx fixField
    | NestedPartyRole fixField -> WriteNestedPartyRole dest nextFreeIdx fixField
    | NoNestedPartyIDs fixField -> WriteNoNestedPartyIDs dest nextFreeIdx fixField
    | TotalAccruedInterestAmt fixField -> WriteTotalAccruedInterestAmt dest nextFreeIdx fixField
    | MaturityDate fixField -> WriteMaturityDate dest nextFreeIdx fixField
    | UnderlyingMaturityDate fixField -> WriteUnderlyingMaturityDate dest nextFreeIdx fixField
    | InstrRegistry fixField -> WriteInstrRegistry dest nextFreeIdx fixField
    | CashMargin fixField -> WriteCashMargin dest nextFreeIdx fixField
    | NestedPartySubID fixField -> WriteNestedPartySubID dest nextFreeIdx fixField
    | Scope fixField -> WriteScope dest nextFreeIdx fixField
    | MDImplicitDelete fixField -> WriteMDImplicitDelete dest nextFreeIdx fixField
    | CrossID fixField -> WriteCrossID dest nextFreeIdx fixField
    | CrossType fixField -> WriteCrossType dest nextFreeIdx fixField
    | CrossPrioritization fixField -> WriteCrossPrioritization dest nextFreeIdx fixField
    | OrigCrossID fixField -> WriteOrigCrossID dest nextFreeIdx fixField
    | NoSides fixField -> WriteNoSides dest nextFreeIdx fixField
    | Username fixField -> WriteUsername dest nextFreeIdx fixField
    | Password fixField -> WritePassword dest nextFreeIdx fixField
    | NoLegs fixField -> WriteNoLegs dest nextFreeIdx fixField
    | LegCurrency fixField -> WriteLegCurrency dest nextFreeIdx fixField
    | TotNoSecurityTypes fixField -> WriteTotNoSecurityTypes dest nextFreeIdx fixField
    | NoSecurityTypes fixField -> WriteNoSecurityTypes dest nextFreeIdx fixField
    | SecurityListRequestType fixField -> WriteSecurityListRequestType dest nextFreeIdx fixField
    | SecurityRequestResult fixField -> WriteSecurityRequestResult dest nextFreeIdx fixField
    | RoundLot fixField -> WriteRoundLot dest nextFreeIdx fixField
    | MinTradeVol fixField -> WriteMinTradeVol dest nextFreeIdx fixField
    | MultiLegRptTypeReq fixField -> WriteMultiLegRptTypeReq dest nextFreeIdx fixField
    | LegPositionEffect fixField -> WriteLegPositionEffect dest nextFreeIdx fixField
    | LegCoveredOrUncovered fixField -> WriteLegCoveredOrUncovered dest nextFreeIdx fixField
    | LegPrice fixField -> WriteLegPrice dest nextFreeIdx fixField
    | TradSesStatusRejReason fixField -> WriteTradSesStatusRejReason dest nextFreeIdx fixField
    | TradeRequestID fixField -> WriteTradeRequestID dest nextFreeIdx fixField
    | TradeRequestType fixField -> WriteTradeRequestType dest nextFreeIdx fixField
    | PreviouslyReported fixField -> WritePreviouslyReported dest nextFreeIdx fixField
    | TradeReportID fixField -> WriteTradeReportID dest nextFreeIdx fixField
    | TradeReportRefID fixField -> WriteTradeReportRefID dest nextFreeIdx fixField
    | MatchStatus fixField -> WriteMatchStatus dest nextFreeIdx fixField
    | MatchType fixField -> WriteMatchType dest nextFreeIdx fixField
    | OddLot fixField -> WriteOddLot dest nextFreeIdx fixField
    | NoClearingInstructions fixField -> WriteNoClearingInstructions dest nextFreeIdx fixField
    | ClearingInstruction fixField -> WriteClearingInstruction dest nextFreeIdx fixField
    | TradeInputSource fixField -> WriteTradeInputSource dest nextFreeIdx fixField
    | TradeInputDevice fixField -> WriteTradeInputDevice dest nextFreeIdx fixField
    | NoDates fixField -> WriteNoDates dest nextFreeIdx fixField
    | AccountType fixField -> WriteAccountType dest nextFreeIdx fixField
    | CustOrderCapacity fixField -> WriteCustOrderCapacity dest nextFreeIdx fixField
    | ClOrdLinkID fixField -> WriteClOrdLinkID dest nextFreeIdx fixField
    | MassStatusReqID fixField -> WriteMassStatusReqID dest nextFreeIdx fixField
    | MassStatusReqType fixField -> WriteMassStatusReqType dest nextFreeIdx fixField
    | OrigOrdModTime fixField -> WriteOrigOrdModTime dest nextFreeIdx fixField
    | LegSettlType fixField -> WriteLegSettlType dest nextFreeIdx fixField
    | LegSettlDate fixField -> WriteLegSettlDate dest nextFreeIdx fixField
    | DayBookingInst fixField -> WriteDayBookingInst dest nextFreeIdx fixField
    | BookingUnit fixField -> WriteBookingUnit dest nextFreeIdx fixField
    | PreallocMethod fixField -> WritePreallocMethod dest nextFreeIdx fixField
    | UnderlyingCountryOfIssue fixField -> WriteUnderlyingCountryOfIssue dest nextFreeIdx fixField
    | UnderlyingStateOrProvinceOfIssue fixField -> WriteUnderlyingStateOrProvinceOfIssue dest nextFreeIdx fixField
    | UnderlyingLocaleOfIssue fixField -> WriteUnderlyingLocaleOfIssue dest nextFreeIdx fixField
    | UnderlyingInstrRegistry fixField -> WriteUnderlyingInstrRegistry dest nextFreeIdx fixField
    | LegCountryOfIssue fixField -> WriteLegCountryOfIssue dest nextFreeIdx fixField
    | LegStateOrProvinceOfIssue fixField -> WriteLegStateOrProvinceOfIssue dest nextFreeIdx fixField
    | LegLocaleOfIssue fixField -> WriteLegLocaleOfIssue dest nextFreeIdx fixField
    | LegInstrRegistry fixField -> WriteLegInstrRegistry dest nextFreeIdx fixField
    | LegSymbol fixField -> WriteLegSymbol dest nextFreeIdx fixField
    | LegSymbolSfx fixField -> WriteLegSymbolSfx dest nextFreeIdx fixField
    | LegSecurityID fixField -> WriteLegSecurityID dest nextFreeIdx fixField
    | LegSecurityIDSource fixField -> WriteLegSecurityIDSource dest nextFreeIdx fixField
    | NoLegSecurityAltID fixField -> WriteNoLegSecurityAltID dest nextFreeIdx fixField
    | LegSecurityAltID fixField -> WriteLegSecurityAltID dest nextFreeIdx fixField
    | LegSecurityAltIDSource fixField -> WriteLegSecurityAltIDSource dest nextFreeIdx fixField
    | LegProduct fixField -> WriteLegProduct dest nextFreeIdx fixField
    | LegCFICode fixField -> WriteLegCFICode dest nextFreeIdx fixField
    | LegSecurityType fixField -> WriteLegSecurityType dest nextFreeIdx fixField
    | LegMaturityMonthYear fixField -> WriteLegMaturityMonthYear dest nextFreeIdx fixField
    | LegMaturityDate fixField -> WriteLegMaturityDate dest nextFreeIdx fixField
    | LegStrikePrice fixField -> WriteLegStrikePrice dest nextFreeIdx fixField
    | LegOptAttribute fixField -> WriteLegOptAttribute dest nextFreeIdx fixField
    | LegContractMultiplier fixField -> WriteLegContractMultiplier dest nextFreeIdx fixField
    | LegCouponRate fixField -> WriteLegCouponRate dest nextFreeIdx fixField
    | LegSecurityExchange fixField -> WriteLegSecurityExchange dest nextFreeIdx fixField
    | LegIssuer fixField -> WriteLegIssuer dest nextFreeIdx fixField
    | EncodedLegIssuer fixField -> WriteEncodedLegIssuer dest nextFreeIdx fixField // compound field
    | LegSecurityDesc fixField -> WriteLegSecurityDesc dest nextFreeIdx fixField
    | EncodedLegSecurityDesc fixField -> WriteEncodedLegSecurityDesc dest nextFreeIdx fixField // compound field
    | LegRatioQty fixField -> WriteLegRatioQty dest nextFreeIdx fixField
    | LegSide fixField -> WriteLegSide dest nextFreeIdx fixField
    | TradingSessionSubID fixField -> WriteTradingSessionSubID dest nextFreeIdx fixField
    | AllocType fixField -> WriteAllocType dest nextFreeIdx fixField
    | NoHops fixField -> WriteNoHops dest nextFreeIdx fixField
    | HopCompID fixField -> WriteHopCompID dest nextFreeIdx fixField
    | HopSendingTime fixField -> WriteHopSendingTime dest nextFreeIdx fixField
    | HopRefID fixField -> WriteHopRefID dest nextFreeIdx fixField
    | MidPx fixField -> WriteMidPx dest nextFreeIdx fixField
    | BidYield fixField -> WriteBidYield dest nextFreeIdx fixField
    | MidYield fixField -> WriteMidYield dest nextFreeIdx fixField
    | OfferYield fixField -> WriteOfferYield dest nextFreeIdx fixField
    | ClearingFeeIndicator fixField -> WriteClearingFeeIndicator dest nextFreeIdx fixField
    | WorkingIndicator fixField -> WriteWorkingIndicator dest nextFreeIdx fixField
    | LegLastPx fixField -> WriteLegLastPx dest nextFreeIdx fixField
    | PriorityIndicator fixField -> WritePriorityIndicator dest nextFreeIdx fixField
    | PriceImprovement fixField -> WritePriceImprovement dest nextFreeIdx fixField
    | Price2 fixField -> WritePrice2 dest nextFreeIdx fixField
    | LastForwardPoints2 fixField -> WriteLastForwardPoints2 dest nextFreeIdx fixField
    | BidForwardPoints2 fixField -> WriteBidForwardPoints2 dest nextFreeIdx fixField
    | OfferForwardPoints2 fixField -> WriteOfferForwardPoints2 dest nextFreeIdx fixField
    | RFQReqID fixField -> WriteRFQReqID dest nextFreeIdx fixField
    | MktBidPx fixField -> WriteMktBidPx dest nextFreeIdx fixField
    | MktOfferPx fixField -> WriteMktOfferPx dest nextFreeIdx fixField
    | MinBidSize fixField -> WriteMinBidSize dest nextFreeIdx fixField
    | MinOfferSize fixField -> WriteMinOfferSize dest nextFreeIdx fixField
    | QuoteStatusReqID fixField -> WriteQuoteStatusReqID dest nextFreeIdx fixField
    | LegalConfirm fixField -> WriteLegalConfirm dest nextFreeIdx fixField
    | UnderlyingLastPx fixField -> WriteUnderlyingLastPx dest nextFreeIdx fixField
    | UnderlyingLastQty fixField -> WriteUnderlyingLastQty dest nextFreeIdx fixField
    | LegRefID fixField -> WriteLegRefID dest nextFreeIdx fixField
    | ContraLegRefID fixField -> WriteContraLegRefID dest nextFreeIdx fixField
    | SettlCurrBidFxRate fixField -> WriteSettlCurrBidFxRate dest nextFreeIdx fixField
    | SettlCurrOfferFxRate fixField -> WriteSettlCurrOfferFxRate dest nextFreeIdx fixField
    | QuoteRequestRejectReason fixField -> WriteQuoteRequestRejectReason dest nextFreeIdx fixField
    | SideComplianceID fixField -> WriteSideComplianceID dest nextFreeIdx fixField
    | AcctIDSource fixField -> WriteAcctIDSource dest nextFreeIdx fixField
    | AllocAcctIDSource fixField -> WriteAllocAcctIDSource dest nextFreeIdx fixField
    | BenchmarkPrice fixField -> WriteBenchmarkPrice dest nextFreeIdx fixField
    | BenchmarkPriceType fixField -> WriteBenchmarkPriceType dest nextFreeIdx fixField
    | ConfirmID fixField -> WriteConfirmID dest nextFreeIdx fixField
    | ConfirmStatus fixField -> WriteConfirmStatus dest nextFreeIdx fixField
    | ConfirmTransType fixField -> WriteConfirmTransType dest nextFreeIdx fixField
    | ContractSettlMonth fixField -> WriteContractSettlMonth dest nextFreeIdx fixField
    | DeliveryForm fixField -> WriteDeliveryForm dest nextFreeIdx fixField
    | LastParPx fixField -> WriteLastParPx dest nextFreeIdx fixField
    | NoLegAllocs fixField -> WriteNoLegAllocs dest nextFreeIdx fixField
    | LegAllocAccount fixField -> WriteLegAllocAccount dest nextFreeIdx fixField
    | LegIndividualAllocID fixField -> WriteLegIndividualAllocID dest nextFreeIdx fixField
    | LegAllocQty fixField -> WriteLegAllocQty dest nextFreeIdx fixField
    | LegAllocAcctIDSource fixField -> WriteLegAllocAcctIDSource dest nextFreeIdx fixField
    | LegSettlCurrency fixField -> WriteLegSettlCurrency dest nextFreeIdx fixField
    | LegBenchmarkCurveCurrency fixField -> WriteLegBenchmarkCurveCurrency dest nextFreeIdx fixField
    | LegBenchmarkCurveName fixField -> WriteLegBenchmarkCurveName dest nextFreeIdx fixField
    | LegBenchmarkCurvePoint fixField -> WriteLegBenchmarkCurvePoint dest nextFreeIdx fixField
    | LegBenchmarkPrice fixField -> WriteLegBenchmarkPrice dest nextFreeIdx fixField
    | LegBenchmarkPriceType fixField -> WriteLegBenchmarkPriceType dest nextFreeIdx fixField
    | LegBidPx fixField -> WriteLegBidPx dest nextFreeIdx fixField
    | LegIOIQty fixField -> WriteLegIOIQty dest nextFreeIdx fixField
    | NoLegStipulations fixField -> WriteNoLegStipulations dest nextFreeIdx fixField
    | LegOfferPx fixField -> WriteLegOfferPx dest nextFreeIdx fixField
    | LegOrderQty fixField -> WriteLegOrderQty dest nextFreeIdx fixField
    | LegPriceType fixField -> WriteLegPriceType dest nextFreeIdx fixField
    | LegQty fixField -> WriteLegQty dest nextFreeIdx fixField
    | LegStipulationType fixField -> WriteLegStipulationType dest nextFreeIdx fixField
    | LegStipulationValue fixField -> WriteLegStipulationValue dest nextFreeIdx fixField
    | LegSwapType fixField -> WriteLegSwapType dest nextFreeIdx fixField
    | Pool fixField -> WritePool dest nextFreeIdx fixField
    | QuotePriceType fixField -> WriteQuotePriceType dest nextFreeIdx fixField
    | QuoteRespID fixField -> WriteQuoteRespID dest nextFreeIdx fixField
    | QuoteRespType fixField -> WriteQuoteRespType dest nextFreeIdx fixField
    | QuoteQualifier fixField -> WriteQuoteQualifier dest nextFreeIdx fixField
    | YieldRedemptionDate fixField -> WriteYieldRedemptionDate dest nextFreeIdx fixField
    | YieldRedemptionPrice fixField -> WriteYieldRedemptionPrice dest nextFreeIdx fixField
    | YieldRedemptionPriceType fixField -> WriteYieldRedemptionPriceType dest nextFreeIdx fixField
    | BenchmarkSecurityID fixField -> WriteBenchmarkSecurityID dest nextFreeIdx fixField
    | ReversalIndicator fixField -> WriteReversalIndicator dest nextFreeIdx fixField
    | YieldCalcDate fixField -> WriteYieldCalcDate dest nextFreeIdx fixField
    | NoPositions fixField -> WriteNoPositions dest nextFreeIdx fixField
    | PosType fixField -> WritePosType dest nextFreeIdx fixField
    | LongQty fixField -> WriteLongQty dest nextFreeIdx fixField
    | ShortQty fixField -> WriteShortQty dest nextFreeIdx fixField
    | PosQtyStatus fixField -> WritePosQtyStatus dest nextFreeIdx fixField
    | PosAmtType fixField -> WritePosAmtType dest nextFreeIdx fixField
    | PosAmt fixField -> WritePosAmt dest nextFreeIdx fixField
    | PosTransType fixField -> WritePosTransType dest nextFreeIdx fixField
    | PosReqID fixField -> WritePosReqID dest nextFreeIdx fixField
    | NoUnderlyings fixField -> WriteNoUnderlyings dest nextFreeIdx fixField
    | PosMaintAction fixField -> WritePosMaintAction dest nextFreeIdx fixField
    | OrigPosReqRefID fixField -> WriteOrigPosReqRefID dest nextFreeIdx fixField
    | PosMaintRptRefID fixField -> WritePosMaintRptRefID dest nextFreeIdx fixField
    | ClearingBusinessDate fixField -> WriteClearingBusinessDate dest nextFreeIdx fixField
    | SettlSessID fixField -> WriteSettlSessID dest nextFreeIdx fixField
    | SettlSessSubID fixField -> WriteSettlSessSubID dest nextFreeIdx fixField
    | AdjustmentType fixField -> WriteAdjustmentType dest nextFreeIdx fixField
    | ContraryInstructionIndicator fixField -> WriteContraryInstructionIndicator dest nextFreeIdx fixField
    | PriorSpreadIndicator fixField -> WritePriorSpreadIndicator dest nextFreeIdx fixField
    | PosMaintRptID fixField -> WritePosMaintRptID dest nextFreeIdx fixField
    | PosMaintStatus fixField -> WritePosMaintStatus dest nextFreeIdx fixField
    | PosMaintResult fixField -> WritePosMaintResult dest nextFreeIdx fixField
    | PosReqType fixField -> WritePosReqType dest nextFreeIdx fixField
    | ResponseTransportType fixField -> WriteResponseTransportType dest nextFreeIdx fixField
    | ResponseDestination fixField -> WriteResponseDestination dest nextFreeIdx fixField
    | TotalNumPosReports fixField -> WriteTotalNumPosReports dest nextFreeIdx fixField
    | PosReqResult fixField -> WritePosReqResult dest nextFreeIdx fixField
    | PosReqStatus fixField -> WritePosReqStatus dest nextFreeIdx fixField
    | SettlPrice fixField -> WriteSettlPrice dest nextFreeIdx fixField
    | SettlPriceType fixField -> WriteSettlPriceType dest nextFreeIdx fixField
    | UnderlyingSettlPrice fixField -> WriteUnderlyingSettlPrice dest nextFreeIdx fixField
    | UnderlyingSettlPriceType fixField -> WriteUnderlyingSettlPriceType dest nextFreeIdx fixField
    | PriorSettlPrice fixField -> WritePriorSettlPrice dest nextFreeIdx fixField
    | NoQuoteQualifiers fixField -> WriteNoQuoteQualifiers dest nextFreeIdx fixField
    | AllocSettlCurrency fixField -> WriteAllocSettlCurrency dest nextFreeIdx fixField
    | AllocSettlCurrAmt fixField -> WriteAllocSettlCurrAmt dest nextFreeIdx fixField
    | InterestAtMaturity fixField -> WriteInterestAtMaturity dest nextFreeIdx fixField
    | LegDatedDate fixField -> WriteLegDatedDate dest nextFreeIdx fixField
    | LegPool fixField -> WriteLegPool dest nextFreeIdx fixField
    | AllocInterestAtMaturity fixField -> WriteAllocInterestAtMaturity dest nextFreeIdx fixField
    | AllocAccruedInterestAmt fixField -> WriteAllocAccruedInterestAmt dest nextFreeIdx fixField
    | DeliveryDate fixField -> WriteDeliveryDate dest nextFreeIdx fixField
    | AssignmentMethod fixField -> WriteAssignmentMethod dest nextFreeIdx fixField
    | AssignmentUnit fixField -> WriteAssignmentUnit dest nextFreeIdx fixField
    | OpenInterest fixField -> WriteOpenInterest dest nextFreeIdx fixField
    | ExerciseMethod fixField -> WriteExerciseMethod dest nextFreeIdx fixField
    | TotNumTradeReports fixField -> WriteTotNumTradeReports dest nextFreeIdx fixField
    | TradeRequestResult fixField -> WriteTradeRequestResult dest nextFreeIdx fixField
    | TradeRequestStatus fixField -> WriteTradeRequestStatus dest nextFreeIdx fixField
    | TradeReportRejectReason fixField -> WriteTradeReportRejectReason dest nextFreeIdx fixField
    | SideMultiLegReportingType fixField -> WriteSideMultiLegReportingType dest nextFreeIdx fixField
    | NoPosAmt fixField -> WriteNoPosAmt dest nextFreeIdx fixField
    | AutoAcceptIndicator fixField -> WriteAutoAcceptIndicator dest nextFreeIdx fixField
    | AllocReportID fixField -> WriteAllocReportID dest nextFreeIdx fixField
    | NoNested2PartyIDs fixField -> WriteNoNested2PartyIDs dest nextFreeIdx fixField
    | Nested2PartyID fixField -> WriteNested2PartyID dest nextFreeIdx fixField
    | Nested2PartyIDSource fixField -> WriteNested2PartyIDSource dest nextFreeIdx fixField
    | Nested2PartyRole fixField -> WriteNested2PartyRole dest nextFreeIdx fixField
    | Nested2PartySubID fixField -> WriteNested2PartySubID dest nextFreeIdx fixField
    | BenchmarkSecurityIDSource fixField -> WriteBenchmarkSecurityIDSource dest nextFreeIdx fixField
    | SecuritySubType fixField -> WriteSecuritySubType dest nextFreeIdx fixField
    | UnderlyingSecuritySubType fixField -> WriteUnderlyingSecuritySubType dest nextFreeIdx fixField
    | LegSecuritySubType fixField -> WriteLegSecuritySubType dest nextFreeIdx fixField
    | AllowableOneSidednessPct fixField -> WriteAllowableOneSidednessPct dest nextFreeIdx fixField
    | AllowableOneSidednessValue fixField -> WriteAllowableOneSidednessValue dest nextFreeIdx fixField
    | AllowableOneSidednessCurr fixField -> WriteAllowableOneSidednessCurr dest nextFreeIdx fixField
    | NoTrdRegTimestamps fixField -> WriteNoTrdRegTimestamps dest nextFreeIdx fixField
    | TrdRegTimestamp fixField -> WriteTrdRegTimestamp dest nextFreeIdx fixField
    | TrdRegTimestampType fixField -> WriteTrdRegTimestampType dest nextFreeIdx fixField
    | TrdRegTimestampOrigin fixField -> WriteTrdRegTimestampOrigin dest nextFreeIdx fixField
    | ConfirmRefID fixField -> WriteConfirmRefID dest nextFreeIdx fixField
    | ConfirmType fixField -> WriteConfirmType dest nextFreeIdx fixField
    | ConfirmRejReason fixField -> WriteConfirmRejReason dest nextFreeIdx fixField
    | BookingType fixField -> WriteBookingType dest nextFreeIdx fixField
    | IndividualAllocRejCode fixField -> WriteIndividualAllocRejCode dest nextFreeIdx fixField
    | SettlInstMsgID fixField -> WriteSettlInstMsgID dest nextFreeIdx fixField
    | NoSettlInst fixField -> WriteNoSettlInst dest nextFreeIdx fixField
    | LastUpdateTime fixField -> WriteLastUpdateTime dest nextFreeIdx fixField
    | AllocSettlInstType fixField -> WriteAllocSettlInstType dest nextFreeIdx fixField
    | NoSettlPartyIDs fixField -> WriteNoSettlPartyIDs dest nextFreeIdx fixField
    | SettlPartyID fixField -> WriteSettlPartyID dest nextFreeIdx fixField
    | SettlPartyIDSource fixField -> WriteSettlPartyIDSource dest nextFreeIdx fixField
    | SettlPartyRole fixField -> WriteSettlPartyRole dest nextFreeIdx fixField
    | SettlPartySubID fixField -> WriteSettlPartySubID dest nextFreeIdx fixField
    | SettlPartySubIDType fixField -> WriteSettlPartySubIDType dest nextFreeIdx fixField
    | DlvyInstType fixField -> WriteDlvyInstType dest nextFreeIdx fixField
    | TerminationType fixField -> WriteTerminationType dest nextFreeIdx fixField
    | NextExpectedMsgSeqNum fixField -> WriteNextExpectedMsgSeqNum dest nextFreeIdx fixField
    | OrdStatusReqID fixField -> WriteOrdStatusReqID dest nextFreeIdx fixField
    | SettlInstReqID fixField -> WriteSettlInstReqID dest nextFreeIdx fixField
    | SettlInstReqRejCode fixField -> WriteSettlInstReqRejCode dest nextFreeIdx fixField
    | SecondaryAllocID fixField -> WriteSecondaryAllocID dest nextFreeIdx fixField
    | AllocReportType fixField -> WriteAllocReportType dest nextFreeIdx fixField
    | AllocReportRefID fixField -> WriteAllocReportRefID dest nextFreeIdx fixField
    | AllocCancReplaceReason fixField -> WriteAllocCancReplaceReason dest nextFreeIdx fixField
    | CopyMsgIndicator fixField -> WriteCopyMsgIndicator dest nextFreeIdx fixField
    | AllocAccountType fixField -> WriteAllocAccountType dest nextFreeIdx fixField
    | OrderAvgPx fixField -> WriteOrderAvgPx dest nextFreeIdx fixField
    | OrderBookingQty fixField -> WriteOrderBookingQty dest nextFreeIdx fixField
    | NoSettlPartySubIDs fixField -> WriteNoSettlPartySubIDs dest nextFreeIdx fixField
    | NoPartySubIDs fixField -> WriteNoPartySubIDs dest nextFreeIdx fixField
    | PartySubIDType fixField -> WritePartySubIDType dest nextFreeIdx fixField
    | NoNestedPartySubIDs fixField -> WriteNoNestedPartySubIDs dest nextFreeIdx fixField
    | NestedPartySubIDType fixField -> WriteNestedPartySubIDType dest nextFreeIdx fixField
    | NoNested2PartySubIDs fixField -> WriteNoNested2PartySubIDs dest nextFreeIdx fixField
    | Nested2PartySubIDType fixField -> WriteNested2PartySubIDType dest nextFreeIdx fixField
    | AllocIntermedReqType fixField -> WriteAllocIntermedReqType dest nextFreeIdx fixField
    | UnderlyingPx fixField -> WriteUnderlyingPx dest nextFreeIdx fixField
    | PriceDelta fixField -> WritePriceDelta dest nextFreeIdx fixField
    | ApplQueueMax fixField -> WriteApplQueueMax dest nextFreeIdx fixField
    | ApplQueueDepth fixField -> WriteApplQueueDepth dest nextFreeIdx fixField
    | ApplQueueResolution fixField -> WriteApplQueueResolution dest nextFreeIdx fixField
    | ApplQueueAction fixField -> WriteApplQueueAction dest nextFreeIdx fixField
    | NoAltMDSource fixField -> WriteNoAltMDSource dest nextFreeIdx fixField
    | AltMDSourceID fixField -> WriteAltMDSourceID dest nextFreeIdx fixField
    | SecondaryTradeReportID fixField -> WriteSecondaryTradeReportID dest nextFreeIdx fixField
    | AvgPxIndicator fixField -> WriteAvgPxIndicator dest nextFreeIdx fixField
    | TradeLinkID fixField -> WriteTradeLinkID dest nextFreeIdx fixField
    | OrderInputDevice fixField -> WriteOrderInputDevice dest nextFreeIdx fixField
    | UnderlyingTradingSessionID fixField -> WriteUnderlyingTradingSessionID dest nextFreeIdx fixField
    | UnderlyingTradingSessionSubID fixField -> WriteUnderlyingTradingSessionSubID dest nextFreeIdx fixField
    | TradeLegRefID fixField -> WriteTradeLegRefID dest nextFreeIdx fixField
    | ExchangeRule fixField -> WriteExchangeRule dest nextFreeIdx fixField
    | TradeAllocIndicator fixField -> WriteTradeAllocIndicator dest nextFreeIdx fixField
    | ExpirationCycle fixField -> WriteExpirationCycle dest nextFreeIdx fixField
    | TrdType fixField -> WriteTrdType dest nextFreeIdx fixField
    | TrdSubType fixField -> WriteTrdSubType dest nextFreeIdx fixField
    | TransferReason fixField -> WriteTransferReason dest nextFreeIdx fixField
    | AsgnReqID fixField -> WriteAsgnReqID dest nextFreeIdx fixField
    | TotNumAssignmentReports fixField -> WriteTotNumAssignmentReports dest nextFreeIdx fixField
    | AsgnRptID fixField -> WriteAsgnRptID dest nextFreeIdx fixField
    | ThresholdAmount fixField -> WriteThresholdAmount dest nextFreeIdx fixField
    | PegMoveType fixField -> WritePegMoveType dest nextFreeIdx fixField
    | PegOffsetType fixField -> WritePegOffsetType dest nextFreeIdx fixField
    | PegLimitType fixField -> WritePegLimitType dest nextFreeIdx fixField
    | PegRoundDirection fixField -> WritePegRoundDirection dest nextFreeIdx fixField
    | PeggedPrice fixField -> WritePeggedPrice dest nextFreeIdx fixField
    | PegScope fixField -> WritePegScope dest nextFreeIdx fixField
    | DiscretionMoveType fixField -> WriteDiscretionMoveType dest nextFreeIdx fixField
    | DiscretionOffsetType fixField -> WriteDiscretionOffsetType dest nextFreeIdx fixField
    | DiscretionLimitType fixField -> WriteDiscretionLimitType dest nextFreeIdx fixField
    | DiscretionRoundDirection fixField -> WriteDiscretionRoundDirection dest nextFreeIdx fixField
    | DiscretionPrice fixField -> WriteDiscretionPrice dest nextFreeIdx fixField
    | DiscretionScope fixField -> WriteDiscretionScope dest nextFreeIdx fixField
    | TargetStrategy fixField -> WriteTargetStrategy dest nextFreeIdx fixField
    | TargetStrategyParameters fixField -> WriteTargetStrategyParameters dest nextFreeIdx fixField
    | ParticipationRate fixField -> WriteParticipationRate dest nextFreeIdx fixField
    | TargetStrategyPerformance fixField -> WriteTargetStrategyPerformance dest nextFreeIdx fixField
    | LastLiquidityInd fixField -> WriteLastLiquidityInd dest nextFreeIdx fixField
    | PublishTrdIndicator fixField -> WritePublishTrdIndicator dest nextFreeIdx fixField
    | ShortSaleReason fixField -> WriteShortSaleReason dest nextFreeIdx fixField
    | QtyType fixField -> WriteQtyType dest nextFreeIdx fixField
    | SecondaryTrdType fixField -> WriteSecondaryTrdType dest nextFreeIdx fixField
    | TradeReportType fixField -> WriteTradeReportType dest nextFreeIdx fixField
    | AllocNoOrdersType fixField -> WriteAllocNoOrdersType dest nextFreeIdx fixField
    | SharedCommission fixField -> WriteSharedCommission dest nextFreeIdx fixField
    | ConfirmReqID fixField -> WriteConfirmReqID dest nextFreeIdx fixField
    | AvgParPx fixField -> WriteAvgParPx dest nextFreeIdx fixField
    | ReportedPx fixField -> WriteReportedPx dest nextFreeIdx fixField
    | NoCapacities fixField -> WriteNoCapacities dest nextFreeIdx fixField
    | OrderCapacityQty fixField -> WriteOrderCapacityQty dest nextFreeIdx fixField
    | NoEvents fixField -> WriteNoEvents dest nextFreeIdx fixField
    | EventType fixField -> WriteEventType dest nextFreeIdx fixField
    | EventDate fixField -> WriteEventDate dest nextFreeIdx fixField
    | EventPx fixField -> WriteEventPx dest nextFreeIdx fixField
    | EventText fixField -> WriteEventText dest nextFreeIdx fixField
    | PctAtRisk fixField -> WritePctAtRisk dest nextFreeIdx fixField
    | NoInstrAttrib fixField -> WriteNoInstrAttrib dest nextFreeIdx fixField
    | InstrAttribType fixField -> WriteInstrAttribType dest nextFreeIdx fixField
    | InstrAttribValue fixField -> WriteInstrAttribValue dest nextFreeIdx fixField
    | DatedDate fixField -> WriteDatedDate dest nextFreeIdx fixField
    | InterestAccrualDate fixField -> WriteInterestAccrualDate dest nextFreeIdx fixField
    | CPProgram fixField -> WriteCPProgram dest nextFreeIdx fixField
    | CPRegType fixField -> WriteCPRegType dest nextFreeIdx fixField
    | UnderlyingCPProgram fixField -> WriteUnderlyingCPProgram dest nextFreeIdx fixField
    | UnderlyingCPRegType fixField -> WriteUnderlyingCPRegType dest nextFreeIdx fixField
    | UnderlyingQty fixField -> WriteUnderlyingQty dest nextFreeIdx fixField
    | TrdMatchID fixField -> WriteTrdMatchID dest nextFreeIdx fixField
    | SecondaryTradeReportRefID fixField -> WriteSecondaryTradeReportRefID dest nextFreeIdx fixField
    | UnderlyingDirtyPrice fixField -> WriteUnderlyingDirtyPrice dest nextFreeIdx fixField
    | UnderlyingEndPrice fixField -> WriteUnderlyingEndPrice dest nextFreeIdx fixField
    | UnderlyingStartValue fixField -> WriteUnderlyingStartValue dest nextFreeIdx fixField
    | UnderlyingCurrentValue fixField -> WriteUnderlyingCurrentValue dest nextFreeIdx fixField
    | UnderlyingEndValue fixField -> WriteUnderlyingEndValue dest nextFreeIdx fixField
    | NoUnderlyingStips fixField -> WriteNoUnderlyingStips dest nextFreeIdx fixField
    | UnderlyingStipType fixField -> WriteUnderlyingStipType dest nextFreeIdx fixField
    | UnderlyingStipValue fixField -> WriteUnderlyingStipValue dest nextFreeIdx fixField
    | MaturityNetMoney fixField -> WriteMaturityNetMoney dest nextFreeIdx fixField
    | MiscFeeBasis fixField -> WriteMiscFeeBasis dest nextFreeIdx fixField
    | TotNoAllocs fixField -> WriteTotNoAllocs dest nextFreeIdx fixField
    | LastFragment fixField -> WriteLastFragment dest nextFreeIdx fixField
    | CollReqID fixField -> WriteCollReqID dest nextFreeIdx fixField
    | CollAsgnReason fixField -> WriteCollAsgnReason dest nextFreeIdx fixField
    | CollInquiryQualifier fixField -> WriteCollInquiryQualifier dest nextFreeIdx fixField
    | NoTrades fixField -> WriteNoTrades dest nextFreeIdx fixField
    | MarginRatio fixField -> WriteMarginRatio dest nextFreeIdx fixField
    | MarginExcess fixField -> WriteMarginExcess dest nextFreeIdx fixField
    | TotalNetValue fixField -> WriteTotalNetValue dest nextFreeIdx fixField
    | CashOutstanding fixField -> WriteCashOutstanding dest nextFreeIdx fixField
    | CollAsgnID fixField -> WriteCollAsgnID dest nextFreeIdx fixField
    | CollAsgnTransType fixField -> WriteCollAsgnTransType dest nextFreeIdx fixField
    | CollRespID fixField -> WriteCollRespID dest nextFreeIdx fixField
    | CollAsgnRespType fixField -> WriteCollAsgnRespType dest nextFreeIdx fixField
    | CollAsgnRejectReason fixField -> WriteCollAsgnRejectReason dest nextFreeIdx fixField
    | CollAsgnRefID fixField -> WriteCollAsgnRefID dest nextFreeIdx fixField
    | CollRptID fixField -> WriteCollRptID dest nextFreeIdx fixField
    | CollInquiryID fixField -> WriteCollInquiryID dest nextFreeIdx fixField
    | CollStatus fixField -> WriteCollStatus dest nextFreeIdx fixField
    | TotNumReports fixField -> WriteTotNumReports dest nextFreeIdx fixField
    | LastRptRequested fixField -> WriteLastRptRequested dest nextFreeIdx fixField
    | AgreementDesc fixField -> WriteAgreementDesc dest nextFreeIdx fixField
    | AgreementID fixField -> WriteAgreementID dest nextFreeIdx fixField
    | AgreementDate fixField -> WriteAgreementDate dest nextFreeIdx fixField
    | StartDate fixField -> WriteStartDate dest nextFreeIdx fixField
    | EndDate fixField -> WriteEndDate dest nextFreeIdx fixField
    | AgreementCurrency fixField -> WriteAgreementCurrency dest nextFreeIdx fixField
    | DeliveryType fixField -> WriteDeliveryType dest nextFreeIdx fixField
    | EndAccruedInterestAmt fixField -> WriteEndAccruedInterestAmt dest nextFreeIdx fixField
    | StartCash fixField -> WriteStartCash dest nextFreeIdx fixField
    | EndCash fixField -> WriteEndCash dest nextFreeIdx fixField
    | UserRequestID fixField -> WriteUserRequestID dest nextFreeIdx fixField
    | UserRequestType fixField -> WriteUserRequestType dest nextFreeIdx fixField
    | NewPassword fixField -> WriteNewPassword dest nextFreeIdx fixField
    | UserStatus fixField -> WriteUserStatus dest nextFreeIdx fixField
    | UserStatusText fixField -> WriteUserStatusText dest nextFreeIdx fixField
    | StatusValue fixField -> WriteStatusValue dest nextFreeIdx fixField
    | StatusText fixField -> WriteStatusText dest nextFreeIdx fixField
    | RefCompID fixField -> WriteRefCompID dest nextFreeIdx fixField
    | RefSubID fixField -> WriteRefSubID dest nextFreeIdx fixField
    | NetworkResponseID fixField -> WriteNetworkResponseID dest nextFreeIdx fixField
    | NetworkRequestID fixField -> WriteNetworkRequestID dest nextFreeIdx fixField
    | LastNetworkResponseID fixField -> WriteLastNetworkResponseID dest nextFreeIdx fixField
    | NetworkRequestType fixField -> WriteNetworkRequestType dest nextFreeIdx fixField
    | NoCompIDs fixField -> WriteNoCompIDs dest nextFreeIdx fixField
    | NetworkStatusResponseType fixField -> WriteNetworkStatusResponseType dest nextFreeIdx fixField
    | NoCollInquiryQualifier fixField -> WriteNoCollInquiryQualifier dest nextFreeIdx fixField
    | TrdRptStatus fixField -> WriteTrdRptStatus dest nextFreeIdx fixField
    | AffirmStatus fixField -> WriteAffirmStatus dest nextFreeIdx fixField
    | UnderlyingStrikeCurrency fixField -> WriteUnderlyingStrikeCurrency dest nextFreeIdx fixField
    | LegStrikeCurrency fixField -> WriteLegStrikeCurrency dest nextFreeIdx fixField
    | TimeBracket fixField -> WriteTimeBracket dest nextFreeIdx fixField
    | CollAction fixField -> WriteCollAction dest nextFreeIdx fixField
    | CollInquiryStatus fixField -> WriteCollInquiryStatus dest nextFreeIdx fixField
    | CollInquiryResult fixField -> WriteCollInquiryResult dest nextFreeIdx fixField
    | StrikeCurrency fixField -> WriteStrikeCurrency dest nextFreeIdx fixField
    | NoNested3PartyIDs fixField -> WriteNoNested3PartyIDs dest nextFreeIdx fixField
    | Nested3PartyID fixField -> WriteNested3PartyID dest nextFreeIdx fixField
    | Nested3PartyIDSource fixField -> WriteNested3PartyIDSource dest nextFreeIdx fixField
    | Nested3PartyRole fixField -> WriteNested3PartyRole dest nextFreeIdx fixField
    | NoNested3PartySubIDs fixField -> WriteNoNested3PartySubIDs dest nextFreeIdx fixField
    | Nested3PartySubID fixField -> WriteNested3PartySubID dest nextFreeIdx fixField
    | Nested3PartySubIDType fixField -> WriteNested3PartySubIDType dest nextFreeIdx fixField
    | LegContractSettlMonth fixField -> WriteLegContractSettlMonth dest nextFreeIdx fixField
    | LegInterestAccrualDate fixField -> WriteLegInterestAccrualDate dest nextFreeIdx fixField

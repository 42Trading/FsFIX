module Fix44.FieldReadWriteFuncs


open System
open System.IO
open Fix44.Fields
open ReadWriteFuncs


let ReadAccount valIn =
    let tmp =  valIn
    Account.Account tmp


let WriteAccount (dest:byte []) (nextFreeIdx:int) (valIn:Account) : int = 
   let tag = "1="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAdvId valIn =
    let tmp =  valIn
    AdvId.AdvId tmp


let WriteAdvId (dest:byte []) (nextFreeIdx:int) (valIn:AdvId) : int = 
   let tag = "2="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAdvRefID valIn =
    let tmp =  valIn
    AdvRefID.AdvRefID tmp


let WriteAdvRefID (dest:byte []) (nextFreeIdx:int) (valIn:AdvRefID) : int = 
   let tag = "3="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAdvSide (fldValIn:string) : AdvSide = 
    match fldValIn with
    |"B" -> AdvSide.Buy
    |"S" -> AdvSide.Sell
    |"X" -> AdvSide.Cross
    |"T" -> AdvSide.Trade
    | x -> failwith (sprintf "ReadAdvSide unknown fix tag: %A"  x) 


let WriteAdvSide (dest:byte array) (nextFreeIdx:int) (xxIn:AdvSide) : int =
    match xxIn with
    | AdvSide.Buy ->
        let tag = "4=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Sell ->
        let tag = "4=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Cross ->
        let tag = "4=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvSide.Trade ->
        let tag = "4=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAdvTransType (fldValIn:string) : AdvTransType = 
    match fldValIn with
    |"N" -> AdvTransType.New
    |"C" -> AdvTransType.Cancel
    |"R" -> AdvTransType.Replace
    | x -> failwith (sprintf "ReadAdvTransType unknown fix tag: %A"  x) 


let WriteAdvTransType (dest:byte array) (nextFreeIdx:int) (xxIn:AdvTransType) : int =
    match xxIn with
    | AdvTransType.New ->
        let tag = "5=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvTransType.Cancel ->
        let tag = "5=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdvTransType.Replace ->
        let tag = "5=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAvgPx valIn =
    let tmp = System.Decimal.Parse valIn
    AvgPx.AvgPx tmp


let WriteAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:AvgPx) : int = 
   let tag = "6="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBeginSeqNo valIn =
    let tmp = System.Int32.Parse valIn
    BeginSeqNo.BeginSeqNo tmp


let WriteBeginSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:BeginSeqNo) : int = 
   let tag = "7="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBeginString valIn =
    let tmp =  valIn
    BeginString.BeginString tmp


let WriteBeginString (dest:byte []) (nextFreeIdx:int) (valIn:BeginString) : int = 
   let tag = "8="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBodyLength valIn =
    let tmp = System.Int32.Parse valIn
    BodyLength.BodyLength tmp


let WriteBodyLength (dest:byte []) (nextFreeIdx:int) (valIn:BodyLength) : int = 
   let tag = "9="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCheckSum valIn =
    let tmp =  valIn
    CheckSum.CheckSum tmp


let WriteCheckSum (dest:byte []) (nextFreeIdx:int) (valIn:CheckSum) : int = 
   let tag = "10="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadClOrdID valIn =
    let tmp =  valIn
    ClOrdID.ClOrdID tmp


let WriteClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:ClOrdID) : int = 
   let tag = "11="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCommission valIn =
    let tmp = System.Int32.Parse valIn
    Commission.Commission tmp


let WriteCommission (dest:byte []) (nextFreeIdx:int) (valIn:Commission) : int = 
   let tag = "12="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCommType (fldValIn:string) : CommType = 
    match fldValIn with
    |"1" -> CommType.PerUnit
    |"2" -> CommType.Percentage
    |"3" -> CommType.Absolute
    |"4" -> CommType.PercentageWaivedCashDiscount
    |"5" -> CommType.PercentageWaivedEnhancedUnits
    |"6" -> CommType.PointsPerBondOrOrContract
    | x -> failwith (sprintf "ReadCommType unknown fix tag: %A"  x) 


let WriteCommType (dest:byte array) (nextFreeIdx:int) (xxIn:CommType) : int =
    match xxIn with
    | CommType.PerUnit ->
        let tag = "13=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.Percentage ->
        let tag = "13=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.Absolute ->
        let tag = "13=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PercentageWaivedCashDiscount ->
        let tag = "13=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PercentageWaivedEnhancedUnits ->
        let tag = "13=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CommType.PointsPerBondOrOrContract ->
        let tag = "13=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCumQty valIn =
    let tmp = System.Decimal.Parse valIn
    CumQty.CumQty tmp


let WriteCumQty (dest:byte []) (nextFreeIdx:int) (valIn:CumQty) : int = 
   let tag = "14="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCurrency valIn =
    let tmp =  valIn
    Currency.Currency tmp


let WriteCurrency (dest:byte []) (nextFreeIdx:int) (valIn:Currency) : int = 
   let tag = "15="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEndSeqNo valIn =
    let tmp = System.Int32.Parse valIn
    EndSeqNo.EndSeqNo tmp


let WriteEndSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:EndSeqNo) : int = 
   let tag = "16="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExecID valIn =
    let tmp =  valIn
    ExecID.ExecID tmp


let WriteExecID (dest:byte []) (nextFreeIdx:int) (valIn:ExecID) : int = 
   let tag = "17="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExecInst (fldValIn:string) : ExecInst = 
    match fldValIn with
    |"1" -> ExecInst.NotHeld
    |"2" -> ExecInst.Work
    |"3" -> ExecInst.GoAlong
    |"4" -> ExecInst.OverTheDay
    |"5" -> ExecInst.Held
    |"6" -> ExecInst.ParticipateDontInitiate
    |"7" -> ExecInst.StrictScale
    |"8" -> ExecInst.TryToScale
    |"9" -> ExecInst.StayOnBidside
    |"0" -> ExecInst.StayOnOfferside
    |"A" -> ExecInst.NoCross
    |"B" -> ExecInst.OkToCross
    |"C" -> ExecInst.CallFirst
    |"D" -> ExecInst.PercentOfVolume
    |"E" -> ExecInst.DoNotIncrease
    |"F" -> ExecInst.DoNotReduce
    |"G" -> ExecInst.AllOrNone
    |"H" -> ExecInst.ReinstateOnSystemFailure
    |"I" -> ExecInst.InstitutionsOnly
    |"J" -> ExecInst.ReinstateOnTradingHalt
    |"K" -> ExecInst.CancelOnTradingHalt
    |"L" -> ExecInst.LastPeg
    |"M" -> ExecInst.MidPrice
    |"N" -> ExecInst.NonNegotiable
    |"O" -> ExecInst.OpeningPeg
    |"P" -> ExecInst.MarketPeg
    |"Q" -> ExecInst.CancelOnSystemFailure
    |"R" -> ExecInst.PrimaryPeg
    |"S" -> ExecInst.Suspend
    |"T" -> ExecInst.FixedPegToLocalBestBidOrOfferAtTimeOfOrder
    |"U" -> ExecInst.CustomerDisplayInstruction
    |"V" -> ExecInst.Netting
    |"W" -> ExecInst.PegToVwap
    |"X" -> ExecInst.TradeAlong
    |"Y" -> ExecInst.TryToStop
    |"Z" -> ExecInst.CancelIfNotBest
    |"a" -> ExecInst.TrailingStopPeg
    |"b" -> ExecInst.StrictLimit
    |"c" -> ExecInst.IgnorePriceValidityChecks
    |"d" -> ExecInst.PegToLimitPrice
    |"e" -> ExecInst.WorkToTargetStrategy
    | x -> failwith (sprintf "ReadExecInst unknown fix tag: %A"  x) 


let WriteExecInst (dest:byte array) (nextFreeIdx:int) (xxIn:ExecInst) : int =
    match xxIn with
    | ExecInst.NotHeld ->
        let tag = "18=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Work ->
        let tag = "18=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.GoAlong ->
        let tag = "18=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OverTheDay ->
        let tag = "18=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Held ->
        let tag = "18=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ParticipateDontInitiate ->
        let tag = "18=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StrictScale ->
        let tag = "18=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TryToScale ->
        let tag = "18=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StayOnBidside ->
        let tag = "18=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StayOnOfferside ->
        let tag = "18=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.NoCross ->
        let tag = "18=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OkToCross ->
        let tag = "18=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CallFirst ->
        let tag = "18=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PercentOfVolume ->
        let tag = "18=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.DoNotIncrease ->
        let tag = "18=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.DoNotReduce ->
        let tag = "18=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.AllOrNone ->
        let tag = "18=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ReinstateOnSystemFailure ->
        let tag = "18=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.InstitutionsOnly ->
        let tag = "18=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.ReinstateOnTradingHalt ->
        let tag = "18=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelOnTradingHalt ->
        let tag = "18=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.LastPeg ->
        let tag = "18=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.MidPrice ->
        let tag = "18=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.NonNegotiable ->
        let tag = "18=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.OpeningPeg ->
        let tag = "18=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.MarketPeg ->
        let tag = "18=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelOnSystemFailure ->
        let tag = "18=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PrimaryPeg ->
        let tag = "18=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Suspend ->
        let tag = "18=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.FixedPegToLocalBestBidOrOfferAtTimeOfOrder ->
        let tag = "18=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CustomerDisplayInstruction ->
        let tag = "18=U"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.Netting ->
        let tag = "18=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PegToVwap ->
        let tag = "18=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TradeAlong ->
        let tag = "18=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TryToStop ->
        let tag = "18=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.CancelIfNotBest ->
        let tag = "18=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.TrailingStopPeg ->
        let tag = "18=a"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.StrictLimit ->
        let tag = "18=b"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.IgnorePriceValidityChecks ->
        let tag = "18=c"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.PegToLimitPrice ->
        let tag = "18=d"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecInst.WorkToTargetStrategy ->
        let tag = "18=e"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecRefID valIn =
    let tmp =  valIn
    ExecRefID.ExecRefID tmp


let WriteExecRefID (dest:byte []) (nextFreeIdx:int) (valIn:ExecRefID) : int = 
   let tag = "19="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHandlInst (fldValIn:string) : HandlInst = 
    match fldValIn with
    |"1" -> HandlInst.AutomatedExecutionOrderPrivate
    |"2" -> HandlInst.AutomatedExecutionOrderPublic
    |"3" -> HandlInst.ManualOrder
    | x -> failwith (sprintf "ReadHandlInst unknown fix tag: %A"  x) 


let WriteHandlInst (dest:byte array) (nextFreeIdx:int) (xxIn:HandlInst) : int =
    match xxIn with
    | HandlInst.AutomatedExecutionOrderPrivate ->
        let tag = "21=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HandlInst.AutomatedExecutionOrderPublic ->
        let tag = "21=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HandlInst.ManualOrder ->
        let tag = "21=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityIDSource (fldValIn:string) : SecurityIDSource = 
    match fldValIn with
    |"1" -> SecurityIDSource.Cusip
    |"2" -> SecurityIDSource.Sedol
    |"3" -> SecurityIDSource.Quik
    |"4" -> SecurityIDSource.IsinNumber
    |"5" -> SecurityIDSource.RicCode
    |"6" -> SecurityIDSource.IsoCurrencyCode
    |"7" -> SecurityIDSource.IsoCountryCode
    |"8" -> SecurityIDSource.ExchangeSymbol
    |"9" -> SecurityIDSource.ConsolidatedTapeAssociation
    |"A" -> SecurityIDSource.BloombergSymbol
    |"B" -> SecurityIDSource.Wertpapier
    |"C" -> SecurityIDSource.Dutch
    |"D" -> SecurityIDSource.Valoren
    |"E" -> SecurityIDSource.Sicovam
    |"F" -> SecurityIDSource.Belgian
    |"G" -> SecurityIDSource.Common
    |"H" -> SecurityIDSource.ClearingHouseClearingOrganization
    |"I" -> SecurityIDSource.IsdaFpmlProductSpecification
    |"J" -> SecurityIDSource.OptionsPriceReportingAuthority
    | x -> failwith (sprintf "ReadSecurityIDSource unknown fix tag: %A"  x) 


let WriteSecurityIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityIDSource) : int =
    match xxIn with
    | SecurityIDSource.Cusip ->
        let tag = "22=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Sedol ->
        let tag = "22=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Quik ->
        let tag = "22=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsinNumber ->
        let tag = "22=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.RicCode ->
        let tag = "22=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsoCurrencyCode ->
        let tag = "22=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsoCountryCode ->
        let tag = "22=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ExchangeSymbol ->
        let tag = "22=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ConsolidatedTapeAssociation ->
        let tag = "22=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.BloombergSymbol ->
        let tag = "22=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Wertpapier ->
        let tag = "22=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Dutch ->
        let tag = "22=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Valoren ->
        let tag = "22=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Sicovam ->
        let tag = "22=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Belgian ->
        let tag = "22=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.Common ->
        let tag = "22=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.ClearingHouseClearingOrganization ->
        let tag = "22=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.IsdaFpmlProductSpecification ->
        let tag = "22=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityIDSource.OptionsPriceReportingAuthority ->
        let tag = "22=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIid valIn =
    let tmp =  valIn
    IOIid.IOIid tmp


let WriteIOIid (dest:byte []) (nextFreeIdx:int) (valIn:IOIid) : int = 
   let tag = "23="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIOIQltyInd (fldValIn:string) : IOIQltyInd = 
    match fldValIn with
    |"L" -> IOIQltyInd.Low
    |"M" -> IOIQltyInd.Medium
    |"H" -> IOIQltyInd.High
    | x -> failwith (sprintf "ReadIOIQltyInd unknown fix tag: %A"  x) 


let WriteIOIQltyInd (dest:byte array) (nextFreeIdx:int) (xxIn:IOIQltyInd) : int =
    match xxIn with
    | IOIQltyInd.Low ->
        let tag = "25=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQltyInd.Medium ->
        let tag = "25=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQltyInd.High ->
        let tag = "25=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIRefID valIn =
    let tmp =  valIn
    IOIRefID.IOIRefID tmp


let WriteIOIRefID (dest:byte []) (nextFreeIdx:int) (valIn:IOIRefID) : int = 
   let tag = "26="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIOIQty valIn =
    let tmp =  valIn
    IOIQty.IOIQty tmp


let WriteIOIQty (dest:byte []) (nextFreeIdx:int) (valIn:IOIQty) : int = 
   let tag = "27="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIOITransType (fldValIn:string) : IOITransType = 
    match fldValIn with
    |"N" -> IOITransType.New
    |"C" -> IOITransType.Cancel
    |"R" -> IOITransType.Replace
    | x -> failwith (sprintf "ReadIOITransType unknown fix tag: %A"  x) 


let WriteIOITransType (dest:byte array) (nextFreeIdx:int) (xxIn:IOITransType) : int =
    match xxIn with
    | IOITransType.New ->
        let tag = "28=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOITransType.Cancel ->
        let tag = "28=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOITransType.Replace ->
        let tag = "28=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastCapacity (fldValIn:string) : LastCapacity = 
    match fldValIn with
    |"1" -> LastCapacity.Agent
    |"2" -> LastCapacity.CrossAsAgent
    |"3" -> LastCapacity.CrossAsPrincipal
    |"4" -> LastCapacity.Principal
    | x -> failwith (sprintf "ReadLastCapacity unknown fix tag: %A"  x) 


let WriteLastCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:LastCapacity) : int =
    match xxIn with
    | LastCapacity.Agent ->
        let tag = "29=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.CrossAsAgent ->
        let tag = "29=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.CrossAsPrincipal ->
        let tag = "29=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastCapacity.Principal ->
        let tag = "29=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastMkt valIn =
    let tmp =  valIn
    LastMkt.LastMkt tmp


let WriteLastMkt (dest:byte []) (nextFreeIdx:int) (valIn:LastMkt) : int = 
   let tag = "30="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastPx valIn =
    let tmp = System.Decimal.Parse valIn
    LastPx.LastPx tmp


let WriteLastPx (dest:byte []) (nextFreeIdx:int) (valIn:LastPx) : int = 
   let tag = "31="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastQty valIn =
    let tmp = System.Decimal.Parse valIn
    LastQty.LastQty tmp


let WriteLastQty (dest:byte []) (nextFreeIdx:int) (valIn:LastQty) : int = 
   let tag = "32="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLinesOfText valIn =
    let tmp = System.Int32.Parse valIn
    LinesOfText.LinesOfText tmp


let WriteLinesOfText (dest:byte []) (nextFreeIdx:int) (valIn:LinesOfText) : int = 
   let tag = "33="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMsgSeqNum valIn =
    let tmp = System.Int32.Parse valIn
    MsgSeqNum.MsgSeqNum tmp


let WriteMsgSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:MsgSeqNum) : int = 
   let tag = "34="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMsgType (fldValIn:string) : MsgType = 
    match fldValIn with
    |"0" -> MsgType.Heartbeat
    |"1" -> MsgType.TestRequest
    |"2" -> MsgType.ResendRequest
    |"3" -> MsgType.Reject
    |"4" -> MsgType.SequenceReset
    |"5" -> MsgType.Logout
    |"6" -> MsgType.IndicationOfInterest
    |"7" -> MsgType.Advertisement
    |"8" -> MsgType.ExecutionReport
    |"9" -> MsgType.OrderCancelReject
    |"A" -> MsgType.Logon
    |"B" -> MsgType.News
    |"C" -> MsgType.Email
    |"D" -> MsgType.OrderSingle
    |"E" -> MsgType.OrderList
    |"F" -> MsgType.OrderCancelRequest
    |"G" -> MsgType.OrderCancelReplaceRequest
    |"H" -> MsgType.OrderStatusRequest
    |"J" -> MsgType.AllocationInstruction
    |"K" -> MsgType.ListCancelRequest
    |"L" -> MsgType.ListExecute
    |"M" -> MsgType.ListStatusRequest
    |"N" -> MsgType.ListStatus
    |"P" -> MsgType.AllocationInstructionAck
    |"Q" -> MsgType.DontKnowTrade
    |"R" -> MsgType.QuoteRequest
    |"S" -> MsgType.Quote
    |"T" -> MsgType.SettlementInstructions
    |"V" -> MsgType.MarketDataRequest
    |"W" -> MsgType.MarketDataSnapshotFullRefresh
    |"X" -> MsgType.MarketDataIncrementalRefresh
    |"Y" -> MsgType.MarketDataRequestReject
    |"Z" -> MsgType.QuoteCancel
    |"a" -> MsgType.QuoteStatusRequest
    |"b" -> MsgType.MassQuoteAcknowledgement
    |"c" -> MsgType.SecurityDefinitionRequest
    |"d" -> MsgType.SecurityDefinition
    |"e" -> MsgType.SecurityStatusRequest
    |"f" -> MsgType.SecurityStatus
    |"g" -> MsgType.TradingSessionStatusRequest
    |"h" -> MsgType.TradingSessionStatus
    |"i" -> MsgType.MassQuote
    |"j" -> MsgType.BusinessMessageReject
    |"k" -> MsgType.BidRequest
    |"l" -> MsgType.BidResponse
    |"m" -> MsgType.ListStrikePrice
    |"n" -> MsgType.XmlMessage
    |"o" -> MsgType.RegistrationInstructions
    |"p" -> MsgType.RegistrationInstructionsResponse
    |"q" -> MsgType.OrderMassCancelRequest
    |"r" -> MsgType.OrderMassCancelReport
    |"s" -> MsgType.NewOrderCross
    |"t" -> MsgType.CrossOrderCancelReplaceRequest
    |"u" -> MsgType.CrossOrderCancelRequest
    |"v" -> MsgType.SecurityTypeRequest
    |"w" -> MsgType.SecurityTypes
    |"x" -> MsgType.SecurityListRequest
    |"y" -> MsgType.SecurityList
    |"z" -> MsgType.DerivativeSecurityListRequest
    |"AA" -> MsgType.DerivativeSecurityList
    |"AB" -> MsgType.NewOrderMultileg
    |"AC" -> MsgType.MultilegOrderCancelReplace
    |"AD" -> MsgType.TradeCaptureReportRequest
    |"AE" -> MsgType.TradeCaptureReport
    |"AF" -> MsgType.OrderMassStatusRequest
    |"AG" -> MsgType.QuoteRequestReject
    |"AH" -> MsgType.RfqRequest
    |"AI" -> MsgType.QuoteStatusReport
    |"AJ" -> MsgType.QuoteResponse
    |"AK" -> MsgType.Confirmation
    |"AL" -> MsgType.PositionMaintenanceRequest
    |"AM" -> MsgType.PositionMaintenanceReport
    |"AN" -> MsgType.RequestForPositions
    |"AO" -> MsgType.RequestForPositionsAck
    |"AP" -> MsgType.PositionReport
    |"AQ" -> MsgType.TradeCaptureReportRequestAck
    |"AR" -> MsgType.TradeCaptureReportAck
    |"AS" -> MsgType.AllocationReport
    |"AT" -> MsgType.AllocationReportAck
    |"AU" -> MsgType.ConfirmationAck
    |"AV" -> MsgType.SettlementInstructionRequest
    |"AW" -> MsgType.AssignmentReport
    |"AX" -> MsgType.CollateralRequest
    |"AY" -> MsgType.CollateralAssignment
    |"AZ" -> MsgType.CollateralResponse
    |"BA" -> MsgType.CollateralReport
    |"BB" -> MsgType.CollateralInquiry
    |"BC" -> MsgType.NetworkStatusRequest
    |"BD" -> MsgType.NetworkStatusResponse
    |"BE" -> MsgType.UserRequest
    |"BF" -> MsgType.UserResponse
    |"BG" -> MsgType.CollateralInquiryAck
    |"BH" -> MsgType.ConfirmationRequest
    | x -> failwith (sprintf "ReadMsgType unknown fix tag: %A"  x) 


let WriteMsgType (dest:byte array) (nextFreeIdx:int) (xxIn:MsgType) : int =
    match xxIn with
    | MsgType.Heartbeat ->
        let tag = "35=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TestRequest ->
        let tag = "35=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ResendRequest ->
        let tag = "35=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Reject ->
        let tag = "35=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SequenceReset ->
        let tag = "35=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Logout ->
        let tag = "35=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.IndicationOfInterest ->
        let tag = "35=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Advertisement ->
        let tag = "35=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ExecutionReport ->
        let tag = "35=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelReject ->
        let tag = "35=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Logon ->
        let tag = "35=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.News ->
        let tag = "35=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Email ->
        let tag = "35=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderSingle ->
        let tag = "35=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderList ->
        let tag = "35=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelRequest ->
        let tag = "35=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderCancelReplaceRequest ->
        let tag = "35=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderStatusRequest ->
        let tag = "35=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationInstruction ->
        let tag = "35=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListCancelRequest ->
        let tag = "35=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListExecute ->
        let tag = "35=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStatusRequest ->
        let tag = "35=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStatus ->
        let tag = "35=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationInstructionAck ->
        let tag = "35=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DontKnowTrade ->
        let tag = "35=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteRequest ->
        let tag = "35=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Quote ->
        let tag = "35=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SettlementInstructions ->
        let tag = "35=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataRequest ->
        let tag = "35=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataSnapshotFullRefresh ->
        let tag = "35=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataIncrementalRefresh ->
        let tag = "35=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MarketDataRequestReject ->
        let tag = "35=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteCancel ->
        let tag = "35=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteStatusRequest ->
        let tag = "35=a"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MassQuoteAcknowledgement ->
        let tag = "35=b"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityDefinitionRequest ->
        let tag = "35=c"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityDefinition ->
        let tag = "35=d"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityStatusRequest ->
        let tag = "35=e"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityStatus ->
        let tag = "35=f"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradingSessionStatusRequest ->
        let tag = "35=g"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradingSessionStatus ->
        let tag = "35=h"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MassQuote ->
        let tag = "35=i"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BusinessMessageReject ->
        let tag = "35=j"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BidRequest ->
        let tag = "35=k"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.BidResponse ->
        let tag = "35=l"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ListStrikePrice ->
        let tag = "35=m"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.XmlMessage ->
        let tag = "35=n"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RegistrationInstructions ->
        let tag = "35=o"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RegistrationInstructionsResponse ->
        let tag = "35=p"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassCancelRequest ->
        let tag = "35=q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassCancelReport ->
        let tag = "35=r"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NewOrderCross ->
        let tag = "35=s"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CrossOrderCancelReplaceRequest ->
        let tag = "35=t"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CrossOrderCancelRequest ->
        let tag = "35=u"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityTypeRequest ->
        let tag = "35=v"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityTypes ->
        let tag = "35=w"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityListRequest ->
        let tag = "35=x"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SecurityList ->
        let tag = "35=y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DerivativeSecurityListRequest ->
        let tag = "35=z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.DerivativeSecurityList ->
        let tag = "35=AA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NewOrderMultileg ->
        let tag = "35=AB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.MultilegOrderCancelReplace ->
        let tag = "35=AC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportRequest ->
        let tag = "35=AD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReport ->
        let tag = "35=AE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.OrderMassStatusRequest ->
        let tag = "35=AF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteRequestReject ->
        let tag = "35=AG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RfqRequest ->
        let tag = "35=AH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteStatusReport ->
        let tag = "35=AI"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.QuoteResponse ->
        let tag = "35=AJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.Confirmation ->
        let tag = "35=AK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionMaintenanceRequest ->
        let tag = "35=AL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionMaintenanceReport ->
        let tag = "35=AM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RequestForPositions ->
        let tag = "35=AN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.RequestForPositionsAck ->
        let tag = "35=AO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.PositionReport ->
        let tag = "35=AP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportRequestAck ->
        let tag = "35=AQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.TradeCaptureReportAck ->
        let tag = "35=AR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationReport ->
        let tag = "35=AS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AllocationReportAck ->
        let tag = "35=AT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ConfirmationAck ->
        let tag = "35=AU"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.SettlementInstructionRequest ->
        let tag = "35=AV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.AssignmentReport ->
        let tag = "35=AW"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralRequest ->
        let tag = "35=AX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralAssignment ->
        let tag = "35=AY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralResponse ->
        let tag = "35=AZ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralReport ->
        let tag = "35=BA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralInquiry ->
        let tag = "35=BB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NetworkStatusRequest ->
        let tag = "35=BC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.NetworkStatusResponse ->
        let tag = "35=BD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.UserRequest ->
        let tag = "35=BE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.UserResponse ->
        let tag = "35=BF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.CollateralInquiryAck ->
        let tag = "35=BG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgType.ConfirmationRequest ->
        let tag = "35=BH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNewSeqNo valIn =
    let tmp = System.Int32.Parse valIn
    NewSeqNo.NewSeqNo tmp


let WriteNewSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:NewSeqNo) : int = 
   let tag = "36="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderID valIn =
    let tmp =  valIn
    OrderID.OrderID tmp


let WriteOrderID (dest:byte []) (nextFreeIdx:int) (valIn:OrderID) : int = 
   let tag = "37="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderQty valIn =
    let tmp = System.Decimal.Parse valIn
    OrderQty.OrderQty tmp


let WriteOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderQty) : int = 
   let tag = "38="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrdStatus (fldValIn:string) : OrdStatus = 
    match fldValIn with
    |"0" -> OrdStatus.New
    |"1" -> OrdStatus.PartiallyFilled
    |"2" -> OrdStatus.Filled
    |"3" -> OrdStatus.DoneForDay
    |"4" -> OrdStatus.Canceled
    |"5" -> OrdStatus.Replaced
    |"6" -> OrdStatus.PendingCancel
    |"7" -> OrdStatus.Stopped
    |"8" -> OrdStatus.Rejected
    |"9" -> OrdStatus.Suspended
    |"A" -> OrdStatus.PendingNew
    |"B" -> OrdStatus.Calculated
    |"C" -> OrdStatus.Expired
    |"D" -> OrdStatus.AcceptedForBidding
    |"E" -> OrdStatus.PendingReplace
    | x -> failwith (sprintf "ReadOrdStatus unknown fix tag: %A"  x) 


let WriteOrdStatus (dest:byte array) (nextFreeIdx:int) (xxIn:OrdStatus) : int =
    match xxIn with
    | OrdStatus.New ->
        let tag = "39=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PartiallyFilled ->
        let tag = "39=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Filled ->
        let tag = "39=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.DoneForDay ->
        let tag = "39=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Canceled ->
        let tag = "39=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Replaced ->
        let tag = "39=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingCancel ->
        let tag = "39=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Stopped ->
        let tag = "39=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Rejected ->
        let tag = "39=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Suspended ->
        let tag = "39=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingNew ->
        let tag = "39=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Calculated ->
        let tag = "39=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.Expired ->
        let tag = "39=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.AcceptedForBidding ->
        let tag = "39=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdStatus.PendingReplace ->
        let tag = "39=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrdType (fldValIn:string) : OrdType = 
    match fldValIn with
    |"1" -> OrdType.Market
    |"2" -> OrdType.Limit
    |"3" -> OrdType.Stop
    |"4" -> OrdType.StopLimit
    |"5" -> OrdType.MarketOnClose
    |"6" -> OrdType.WithOrWithout
    |"7" -> OrdType.LimitOrBetter
    |"8" -> OrdType.LimitWithOrWithout
    |"9" -> OrdType.OnBasis
    |"A" -> OrdType.OnClose
    |"B" -> OrdType.LimitOnClose
    |"C" -> OrdType.ForexMarket
    |"D" -> OrdType.PreviouslyQuoted
    |"E" -> OrdType.PreviouslyIndicated
    |"F" -> OrdType.ForexLimit
    |"G" -> OrdType.ForexSwap
    |"H" -> OrdType.ForexPreviouslyQuoted
    |"I" -> OrdType.Funari
    |"J" -> OrdType.MarketIfTouched
    |"K" -> OrdType.MarketWithLeftoverAsLimit
    |"L" -> OrdType.PreviousFundValuationPoint
    |"M" -> OrdType.NextFundValuationPoint
    |"P" -> OrdType.Pegged
    | x -> failwith (sprintf "ReadOrdType unknown fix tag: %A"  x) 


let WriteOrdType (dest:byte array) (nextFreeIdx:int) (xxIn:OrdType) : int =
    match xxIn with
    | OrdType.Market ->
        let tag = "40=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Limit ->
        let tag = "40=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Stop ->
        let tag = "40=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.StopLimit ->
        let tag = "40=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketOnClose ->
        let tag = "40=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.WithOrWithout ->
        let tag = "40=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitOrBetter ->
        let tag = "40=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitWithOrWithout ->
        let tag = "40=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.OnBasis ->
        let tag = "40=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.OnClose ->
        let tag = "40=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.LimitOnClose ->
        let tag = "40=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexMarket ->
        let tag = "40=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviouslyQuoted ->
        let tag = "40=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviouslyIndicated ->
        let tag = "40=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexLimit ->
        let tag = "40=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexSwap ->
        let tag = "40=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.ForexPreviouslyQuoted ->
        let tag = "40=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Funari ->
        let tag = "40=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketIfTouched ->
        let tag = "40=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.MarketWithLeftoverAsLimit ->
        let tag = "40=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.PreviousFundValuationPoint ->
        let tag = "40=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.NextFundValuationPoint ->
        let tag = "40=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdType.Pegged ->
        let tag = "40=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigClOrdID valIn =
    let tmp =  valIn
    OrigClOrdID.OrigClOrdID tmp


let WriteOrigClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:OrigClOrdID) : int = 
   let tag = "41="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrigTime valIn =
    let tmp =  valIn
    OrigTime.OrigTime tmp


let WriteOrigTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigTime) : int = 
   let tag = "42="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPossDupFlag valIn =
    let tmp = System.Boolean.Parse valIn
    PossDupFlag.PossDupFlag tmp


let WritePossDupFlag (dest:byte []) (nextFreeIdx:int) (valIn:PossDupFlag) : int = 
   let tag = "43="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPrice valIn =
    let tmp = System.Decimal.Parse valIn
    Price.Price tmp


let WritePrice (dest:byte []) (nextFreeIdx:int) (valIn:Price) : int = 
   let tag = "44="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRefSeqNum valIn =
    let tmp = System.Int32.Parse valIn
    RefSeqNum.RefSeqNum tmp


let WriteRefSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:RefSeqNum) : int = 
   let tag = "45="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityID valIn =
    let tmp =  valIn
    SecurityID.SecurityID tmp


let WriteSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityID) : int = 
   let tag = "48="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSenderCompID valIn =
    let tmp =  valIn
    SenderCompID.SenderCompID tmp


let WriteSenderCompID (dest:byte []) (nextFreeIdx:int) (valIn:SenderCompID) : int = 
   let tag = "49="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSenderSubID valIn =
    let tmp =  valIn
    SenderSubID.SenderSubID tmp


let WriteSenderSubID (dest:byte []) (nextFreeIdx:int) (valIn:SenderSubID) : int = 
   let tag = "50="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSendingTime valIn =
    let tmp =  valIn
    SendingTime.SendingTime tmp


let WriteSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:SendingTime) : int = 
   let tag = "52="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuantity valIn =
    let tmp = System.Decimal.Parse valIn
    Quantity.Quantity tmp


let WriteQuantity (dest:byte []) (nextFreeIdx:int) (valIn:Quantity) : int = 
   let tag = "53="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSide (fldValIn:string) : Side = 
    match fldValIn with
    |"1" -> Side.Buy
    |"2" -> Side.Sell
    |"3" -> Side.BuyMinus
    |"4" -> Side.SellPlus
    |"5" -> Side.SellShort
    |"6" -> Side.SellShortExempt
    |"7" -> Side.Undisclosed
    |"8" -> Side.Cross
    |"9" -> Side.CrossShort
    |"A" -> Side.CrossShortExempt
    |"B" -> Side.AsDefined
    |"C" -> Side.Opposite
    |"D" -> Side.Subscribe
    |"E" -> Side.Redeem
    |"F" -> Side.Lend
    |"G" -> Side.Borrow
    | x -> failwith (sprintf "ReadSide unknown fix tag: %A"  x) 


let WriteSide (dest:byte array) (nextFreeIdx:int) (xxIn:Side) : int =
    match xxIn with
    | Side.Buy ->
        let tag = "54=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Sell ->
        let tag = "54=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.BuyMinus ->
        let tag = "54=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellPlus ->
        let tag = "54=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellShort ->
        let tag = "54=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.SellShortExempt ->
        let tag = "54=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Undisclosed ->
        let tag = "54=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Cross ->
        let tag = "54=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.CrossShort ->
        let tag = "54=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.CrossShortExempt ->
        let tag = "54=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.AsDefined ->
        let tag = "54=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Opposite ->
        let tag = "54=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Subscribe ->
        let tag = "54=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Redeem ->
        let tag = "54=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Lend ->
        let tag = "54=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Side.Borrow ->
        let tag = "54=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSymbol valIn =
    let tmp =  valIn
    Symbol.Symbol tmp


let WriteSymbol (dest:byte []) (nextFreeIdx:int) (valIn:Symbol) : int = 
   let tag = "55="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTargetCompID valIn =
    let tmp =  valIn
    TargetCompID.TargetCompID tmp


let WriteTargetCompID (dest:byte []) (nextFreeIdx:int) (valIn:TargetCompID) : int = 
   let tag = "56="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTargetSubID valIn =
    let tmp =  valIn
    TargetSubID.TargetSubID tmp


let WriteTargetSubID (dest:byte []) (nextFreeIdx:int) (valIn:TargetSubID) : int = 
   let tag = "57="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadText valIn =
    let tmp =  valIn
    Text.Text tmp


let WriteText (dest:byte []) (nextFreeIdx:int) (valIn:Text) : int = 
   let tag = "58="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTimeInForce (fldValIn:string) : TimeInForce = 
    match fldValIn with
    |"0" -> TimeInForce.Day
    |"1" -> TimeInForce.GoodTillCancel
    |"2" -> TimeInForce.AtTheOpening
    |"3" -> TimeInForce.ImmediateOrCancel
    |"4" -> TimeInForce.FillOrKill
    |"5" -> TimeInForce.GoodTillCrossing
    |"6" -> TimeInForce.GoodTillDate
    |"7" -> TimeInForce.AtTheClose
    | x -> failwith (sprintf "ReadTimeInForce unknown fix tag: %A"  x) 


let WriteTimeInForce (dest:byte array) (nextFreeIdx:int) (xxIn:TimeInForce) : int =
    match xxIn with
    | TimeInForce.Day ->
        let tag = "59=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillCancel ->
        let tag = "59=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.AtTheOpening ->
        let tag = "59=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.ImmediateOrCancel ->
        let tag = "59=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.FillOrKill ->
        let tag = "59=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillCrossing ->
        let tag = "59=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.GoodTillDate ->
        let tag = "59=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TimeInForce.AtTheClose ->
        let tag = "59=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTransactTime valIn =
    let tmp =  valIn
    TransactTime.TransactTime tmp


let WriteTransactTime (dest:byte []) (nextFreeIdx:int) (valIn:TransactTime) : int = 
   let tag = "60="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUrgency (fldValIn:string) : Urgency = 
    match fldValIn with
    |"0" -> Urgency.Normal
    |"1" -> Urgency.Flash
    |"2" -> Urgency.Background
    | x -> failwith (sprintf "ReadUrgency unknown fix tag: %A"  x) 


let WriteUrgency (dest:byte array) (nextFreeIdx:int) (xxIn:Urgency) : int =
    match xxIn with
    | Urgency.Normal ->
        let tag = "61=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Urgency.Flash ->
        let tag = "61=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Urgency.Background ->
        let tag = "61=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadValidUntilTime valIn =
    let tmp =  valIn
    ValidUntilTime.ValidUntilTime tmp


let WriteValidUntilTime (dest:byte []) (nextFreeIdx:int) (valIn:ValidUntilTime) : int = 
   let tag = "62="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlType (fldValIn:string) : SettlType = 
    match fldValIn with
    |"0" -> SettlType.Regular
    |"1" -> SettlType.Cash
    |"2" -> SettlType.NextDay
    |"3" -> SettlType.TPlus2
    |"4" -> SettlType.TPlus3
    |"5" -> SettlType.TPlus4
    |"6" -> SettlType.Future
    |"7" -> SettlType.WhenAndIfIssued
    |"8" -> SettlType.SellersOption
    |"9" -> SettlType.TPlus5
    | x -> failwith (sprintf "ReadSettlType unknown fix tag: %A"  x) 


let WriteSettlType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlType) : int =
    match xxIn with
    | SettlType.Regular ->
        let tag = "63=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.Cash ->
        let tag = "63=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.NextDay ->
        let tag = "63=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus2 ->
        let tag = "63=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus3 ->
        let tag = "63=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus4 ->
        let tag = "63=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.Future ->
        let tag = "63=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.WhenAndIfIssued ->
        let tag = "63=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.SellersOption ->
        let tag = "63=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlType.TPlus5 ->
        let tag = "63=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSettlDate valIn =
    let tmp =  valIn
    SettlDate.SettlDate tmp


let WriteSettlDate (dest:byte []) (nextFreeIdx:int) (valIn:SettlDate) : int = 
   let tag = "64="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSymbolSfx (fldValIn:string) : SymbolSfx = 
    match fldValIn with
    |"WI" -> SymbolSfx.WhenIssued
    |"CD" -> SymbolSfx.AEucpWithLumpSumInterest
    | x -> failwith (sprintf "ReadSymbolSfx unknown fix tag: %A"  x) 


let WriteSymbolSfx (dest:byte array) (nextFreeIdx:int) (xxIn:SymbolSfx) : int =
    match xxIn with
    | SymbolSfx.WhenIssued ->
        let tag = "65=WI"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SymbolSfx.AEucpWithLumpSumInterest ->
        let tag = "65=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadListID valIn =
    let tmp =  valIn
    ListID.ListID tmp


let WriteListID (dest:byte []) (nextFreeIdx:int) (valIn:ListID) : int = 
   let tag = "66="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListSeqNo valIn =
    let tmp = System.Int32.Parse valIn
    ListSeqNo.ListSeqNo tmp


let WriteListSeqNo (dest:byte []) (nextFreeIdx:int) (valIn:ListSeqNo) : int = 
   let tag = "67="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotNoOrders valIn =
    let tmp = System.Int32.Parse valIn
    TotNoOrders.TotNoOrders tmp


let WriteTotNoOrders (dest:byte []) (nextFreeIdx:int) (valIn:TotNoOrders) : int = 
   let tag = "68="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListExecInst valIn =
    let tmp =  valIn
    ListExecInst.ListExecInst tmp


let WriteListExecInst (dest:byte []) (nextFreeIdx:int) (valIn:ListExecInst) : int = 
   let tag = "69="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocID valIn =
    let tmp =  valIn
    AllocID.AllocID tmp


let WriteAllocID (dest:byte []) (nextFreeIdx:int) (valIn:AllocID) : int = 
   let tag = "70="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocTransType (fldValIn:string) : AllocTransType = 
    match fldValIn with
    |"0" -> AllocTransType.New
    |"1" -> AllocTransType.Replace
    |"2" -> AllocTransType.Cancel
    | x -> failwith (sprintf "ReadAllocTransType unknown fix tag: %A"  x) 


let WriteAllocTransType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocTransType) : int =
    match xxIn with
    | AllocTransType.New ->
        let tag = "71=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocTransType.Replace ->
        let tag = "71=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocTransType.Cancel ->
        let tag = "71=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRefAllocID valIn =
    let tmp =  valIn
    RefAllocID.RefAllocID tmp


let WriteRefAllocID (dest:byte []) (nextFreeIdx:int) (valIn:RefAllocID) : int = 
   let tag = "72="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoOrders valIn =
    let tmp = System.Int32.Parse valIn
    NoOrders.NoOrders tmp


let WriteNoOrders (dest:byte []) (nextFreeIdx:int) (valIn:NoOrders) : int = 
   let tag = "73="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAvgPxPrecision valIn =
    let tmp = System.Int32.Parse valIn
    AvgPxPrecision.AvgPxPrecision tmp


let WriteAvgPxPrecision (dest:byte []) (nextFreeIdx:int) (valIn:AvgPxPrecision) : int = 
   let tag = "74="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeDate valIn =
    let tmp =  valIn
    TradeDate.TradeDate tmp


let WriteTradeDate (dest:byte []) (nextFreeIdx:int) (valIn:TradeDate) : int = 
   let tag = "75="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPositionEffect (fldValIn:string) : PositionEffect = 
    match fldValIn with
    |"O" -> PositionEffect.Open
    |"C" -> PositionEffect.Close
    |"R" -> PositionEffect.Rolled
    |"F" -> PositionEffect.Fifo
    | x -> failwith (sprintf "ReadPositionEffect unknown fix tag: %A"  x) 


let WritePositionEffect (dest:byte array) (nextFreeIdx:int) (xxIn:PositionEffect) : int =
    match xxIn with
    | PositionEffect.Open ->
        let tag = "77=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Close ->
        let tag = "77=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Rolled ->
        let tag = "77=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PositionEffect.Fifo ->
        let tag = "77=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoAllocs valIn =
    let tmp = System.Int32.Parse valIn
    NoAllocs.NoAllocs tmp


let WriteNoAllocs (dest:byte []) (nextFreeIdx:int) (valIn:NoAllocs) : int = 
   let tag = "78="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocAccount valIn =
    let tmp =  valIn
    AllocAccount.AllocAccount tmp


let WriteAllocAccount (dest:byte []) (nextFreeIdx:int) (valIn:AllocAccount) : int = 
   let tag = "79="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocQty valIn =
    let tmp = System.Decimal.Parse valIn
    AllocQty.AllocQty tmp


let WriteAllocQty (dest:byte []) (nextFreeIdx:int) (valIn:AllocQty) : int = 
   let tag = "80="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadProcessCode (fldValIn:string) : ProcessCode = 
    match fldValIn with
    |"0" -> ProcessCode.Regular
    |"1" -> ProcessCode.SoftDollar
    |"2" -> ProcessCode.StepIn
    |"3" -> ProcessCode.StepOut
    |"4" -> ProcessCode.SoftDollarStepIn
    |"5" -> ProcessCode.SoftDollarStepOut
    |"6" -> ProcessCode.PlanSponsor
    | x -> failwith (sprintf "ReadProcessCode unknown fix tag: %A"  x) 


let WriteProcessCode (dest:byte array) (nextFreeIdx:int) (xxIn:ProcessCode) : int =
    match xxIn with
    | ProcessCode.Regular ->
        let tag = "81=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollar ->
        let tag = "81=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.StepIn ->
        let tag = "81=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.StepOut ->
        let tag = "81=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollarStepIn ->
        let tag = "81=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.SoftDollarStepOut ->
        let tag = "81=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProcessCode.PlanSponsor ->
        let tag = "81=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoRpts valIn =
    let tmp = System.Int32.Parse valIn
    NoRpts.NoRpts tmp


let WriteNoRpts (dest:byte []) (nextFreeIdx:int) (valIn:NoRpts) : int = 
   let tag = "82="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRptSeq valIn =
    let tmp = System.Int32.Parse valIn
    RptSeq.RptSeq tmp


let WriteRptSeq (dest:byte []) (nextFreeIdx:int) (valIn:RptSeq) : int = 
   let tag = "83="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCxlQty valIn =
    let tmp = System.Decimal.Parse valIn
    CxlQty.CxlQty tmp


let WriteCxlQty (dest:byte []) (nextFreeIdx:int) (valIn:CxlQty) : int = 
   let tag = "84="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoDlvyInst valIn =
    let tmp = System.Int32.Parse valIn
    NoDlvyInst.NoDlvyInst tmp


let WriteNoDlvyInst (dest:byte []) (nextFreeIdx:int) (valIn:NoDlvyInst) : int = 
   let tag = "85="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocStatus (fldValIn:string) : AllocStatus = 
    match fldValIn with
    |"0" -> AllocStatus.Accepted
    |"1" -> AllocStatus.BlockLevelReject
    |"2" -> AllocStatus.AccountLevelReject
    |"3" -> AllocStatus.Received
    |"4" -> AllocStatus.Incomplete
    |"5" -> AllocStatus.RejectedByIntermediary
    | x -> failwith (sprintf "ReadAllocStatus unknown fix tag: %A"  x) 


let WriteAllocStatus (dest:byte array) (nextFreeIdx:int) (xxIn:AllocStatus) : int =
    match xxIn with
    | AllocStatus.Accepted ->
        let tag = "87=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.BlockLevelReject ->
        let tag = "87=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.AccountLevelReject ->
        let tag = "87=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.Received ->
        let tag = "87=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.Incomplete ->
        let tag = "87=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocStatus.RejectedByIntermediary ->
        let tag = "87=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocRejCode (fldValIn:string) : AllocRejCode = 
    match fldValIn with
    |"0" -> AllocRejCode.UnknownAccount
    |"1" -> AllocRejCode.IncorrectQuantity
    |"2" -> AllocRejCode.IncorrectAveragePrice
    |"3" -> AllocRejCode.UnknownExecutingBrokerMnemonic
    |"4" -> AllocRejCode.CommissionDifference
    |"5" -> AllocRejCode.UnknownOrderid
    |"6" -> AllocRejCode.UnknownListid
    |"7" -> AllocRejCode.Other
    |"8" -> AllocRejCode.IncorrectAllocatedQuantity
    |"9" -> AllocRejCode.CalculationDifference
    |"10" -> AllocRejCode.UnknownOrStaleExecId
    |"11" -> AllocRejCode.MismatchedDataValue
    |"12" -> AllocRejCode.UnknownClordid
    |"13" -> AllocRejCode.WarehouseRequestRejected
    | x -> failwith (sprintf "ReadAllocRejCode unknown fix tag: %A"  x) 


let WriteAllocRejCode (dest:byte array) (nextFreeIdx:int) (xxIn:AllocRejCode) : int =
    match xxIn with
    | AllocRejCode.UnknownAccount ->
        let tag = "88=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectQuantity ->
        let tag = "88=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectAveragePrice ->
        let tag = "88=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownExecutingBrokerMnemonic ->
        let tag = "88=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.CommissionDifference ->
        let tag = "88=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownOrderid ->
        let tag = "88=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownListid ->
        let tag = "88=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.Other ->
        let tag = "88=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.IncorrectAllocatedQuantity ->
        let tag = "88=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.CalculationDifference ->
        let tag = "88=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownOrStaleExecId ->
        let tag = "88=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.MismatchedDataValue ->
        let tag = "88=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.UnknownClordid ->
        let tag = "88=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocRejCode.WarehouseRequestRejected ->
        let tag = "88=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSignature valIn =
    let tmp =  valIn
    Signature.Signature tmp


let WriteSignature (dest:byte []) (nextFreeIdx:int) (valIn:Signature) : int = 
   let tag = "89="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteSecureData (dest:byte []) (nextFreeIdx:int) (fld:SecureData) : int =
    // write the string length part of the compound msg
    let lenTag = "90="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadSecureData valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "91" then failwith "invalid tag reading SecureData"
    if strLen <> raw.Length then failwith "mismatched string len reading SecureData"
    SecureData.SecureData raw


let ReadSignatureLength valIn =
    let tmp = System.Int32.Parse valIn
    SignatureLength.SignatureLength tmp


let WriteSignatureLength (dest:byte []) (nextFreeIdx:int) (valIn:SignatureLength) : int = 
   let tag = "93="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEmailType (fldValIn:string) : EmailType = 
    match fldValIn with
    |"0" -> EmailType.New
    |"1" -> EmailType.Reply
    |"2" -> EmailType.AdminReply
    | x -> failwith (sprintf "ReadEmailType unknown fix tag: %A"  x) 


let WriteEmailType (dest:byte array) (nextFreeIdx:int) (xxIn:EmailType) : int =
    match xxIn with
    | EmailType.New ->
        let tag = "94=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EmailType.Reply ->
        let tag = "94=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EmailType.AdminReply ->
        let tag = "94=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRawDataLength valIn =
    let tmp = System.Int32.Parse valIn
    RawDataLength.RawDataLength tmp


let WriteRawDataLength (dest:byte []) (nextFreeIdx:int) (valIn:RawDataLength) : int = 
   let tag = "95="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRawData valIn =
    let tmp =  valIn
    RawData.RawData tmp


let WriteRawData (dest:byte []) (nextFreeIdx:int) (valIn:RawData) : int = 
   let tag = "96="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPossResend valIn =
    let tmp = System.Boolean.Parse valIn
    PossResend.PossResend tmp


let WritePossResend (dest:byte []) (nextFreeIdx:int) (valIn:PossResend) : int = 
   let tag = "97="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEncryptMethod (fldValIn:string) : EncryptMethod = 
    match fldValIn with
    |"0" -> EncryptMethod.NoneOther
    |"1" -> EncryptMethod.Pkcs
    |"2" -> EncryptMethod.Des
    |"3" -> EncryptMethod.PkcsDes
    |"4" -> EncryptMethod.PgpDes
    |"5" -> EncryptMethod.PgpDesMd5
    |"6" -> EncryptMethod.PemDesMd5
    | x -> failwith (sprintf "ReadEncryptMethod unknown fix tag: %A"  x) 


let WriteEncryptMethod (dest:byte array) (nextFreeIdx:int) (xxIn:EncryptMethod) : int =
    match xxIn with
    | EncryptMethod.NoneOther ->
        let tag = "98=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.Pkcs ->
        let tag = "98=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.Des ->
        let tag = "98=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PkcsDes ->
        let tag = "98=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PgpDes ->
        let tag = "98=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PgpDesMd5 ->
        let tag = "98=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EncryptMethod.PemDesMd5 ->
        let tag = "98=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStopPx valIn =
    let tmp = System.Decimal.Parse valIn
    StopPx.StopPx tmp


let WriteStopPx (dest:byte []) (nextFreeIdx:int) (valIn:StopPx) : int = 
   let tag = "99="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExDestination valIn =
    let tmp =  valIn
    ExDestination.ExDestination tmp


let WriteExDestination (dest:byte []) (nextFreeIdx:int) (valIn:ExDestination) : int = 
   let tag = "100="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCxlRejReason (fldValIn:string) : CxlRejReason = 
    match fldValIn with
    |"0" -> CxlRejReason.TooLateToCancel
    |"1" -> CxlRejReason.UnknownOrder
    |"2" -> CxlRejReason.BrokerExchangeOption
    |"3" -> CxlRejReason.OrderAlreadyInPendingCancelOrPendingReplaceStatus
    |"4" -> CxlRejReason.UnableToProcessOrderMassCancelRequest
    |"5" -> CxlRejReason.OrigordmodtimeDidNotMatchLastTransacttimeOfOrder
    |"6" -> CxlRejReason.DuplicateClordidReceived
    |"99" -> CxlRejReason.Other
    | x -> failwith (sprintf "ReadCxlRejReason unknown fix tag: %A"  x) 


let WriteCxlRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:CxlRejReason) : int =
    match xxIn with
    | CxlRejReason.TooLateToCancel ->
        let tag = "102=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.UnknownOrder ->
        let tag = "102=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.BrokerExchangeOption ->
        let tag = "102=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.OrderAlreadyInPendingCancelOrPendingReplaceStatus ->
        let tag = "102=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.UnableToProcessOrderMassCancelRequest ->
        let tag = "102=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.OrigordmodtimeDidNotMatchLastTransacttimeOfOrder ->
        let tag = "102=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.DuplicateClordidReceived ->
        let tag = "102=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejReason.Other ->
        let tag = "102=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrdRejReason (fldValIn:string) : OrdRejReason = 
    match fldValIn with
    |"0" -> OrdRejReason.BrokerExchangeOption
    |"1" -> OrdRejReason.UnknownSymbol
    |"2" -> OrdRejReason.ExchangeClosed
    |"3" -> OrdRejReason.OrderExceedsLimit
    |"4" -> OrdRejReason.TooLateToEnter
    |"5" -> OrdRejReason.UnknownOrder
    |"6" -> OrdRejReason.DuplicateOrder
    |"7" -> OrdRejReason.DuplicateOfAVerballyCommunicatedOrder
    |"8" -> OrdRejReason.StaleOrder
    |"9" -> OrdRejReason.TradeAlongRequired
    |"10" -> OrdRejReason.InvalidInvestorId
    |"11" -> OrdRejReason.UnsupportedOrderCharacteristic
    |"12" -> OrdRejReason.SurveillenceOption
    |"13" -> OrdRejReason.IncorrectQuantity
    |"14" -> OrdRejReason.IncorrectAllocatedQuantity
    |"15" -> OrdRejReason.UnknownAccount
    |"99" -> OrdRejReason.Other
    | x -> failwith (sprintf "ReadOrdRejReason unknown fix tag: %A"  x) 


let WriteOrdRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:OrdRejReason) : int =
    match xxIn with
    | OrdRejReason.BrokerExchangeOption ->
        let tag = "103=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownSymbol ->
        let tag = "103=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.ExchangeClosed ->
        let tag = "103=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.OrderExceedsLimit ->
        let tag = "103=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.TooLateToEnter ->
        let tag = "103=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownOrder ->
        let tag = "103=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.DuplicateOrder ->
        let tag = "103=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.DuplicateOfAVerballyCommunicatedOrder ->
        let tag = "103=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.StaleOrder ->
        let tag = "103=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.TradeAlongRequired ->
        let tag = "103=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.InvalidInvestorId ->
        let tag = "103=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnsupportedOrderCharacteristic ->
        let tag = "103=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.SurveillenceOption ->
        let tag = "103=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.IncorrectQuantity ->
        let tag = "103=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.IncorrectAllocatedQuantity ->
        let tag = "103=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.UnknownAccount ->
        let tag = "103=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrdRejReason.Other ->
        let tag = "103=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIOIQualifier (fldValIn:string) : IOIQualifier = 
    match fldValIn with
    |"A" -> IOIQualifier.AllOrNone
    |"B" -> IOIQualifier.MarketOnClose
    |"C" -> IOIQualifier.AtTheClose
    |"D" -> IOIQualifier.Vwap
    |"I" -> IOIQualifier.InTouchWith
    |"L" -> IOIQualifier.Limit
    |"M" -> IOIQualifier.MoreBehind
    |"O" -> IOIQualifier.AtTheOpen
    |"P" -> IOIQualifier.TakingAPosition
    |"Q" -> IOIQualifier.AtTheMarket
    |"R" -> IOIQualifier.ReadyToTrade
    |"S" -> IOIQualifier.PortfolioShown
    |"T" -> IOIQualifier.ThroughTheDay
    |"V" -> IOIQualifier.Versus
    |"W" -> IOIQualifier.IndicationWorkingAway
    |"X" -> IOIQualifier.CrossingOpportunity
    |"Y" -> IOIQualifier.AtTheMidpoint
    |"Z" -> IOIQualifier.PreOpen
    | x -> failwith (sprintf "ReadIOIQualifier unknown fix tag: %A"  x) 


let WriteIOIQualifier (dest:byte array) (nextFreeIdx:int) (xxIn:IOIQualifier) : int =
    match xxIn with
    | IOIQualifier.AllOrNone ->
        let tag = "104=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.MarketOnClose ->
        let tag = "104=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheClose ->
        let tag = "104=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Vwap ->
        let tag = "104=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.InTouchWith ->
        let tag = "104=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Limit ->
        let tag = "104=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.MoreBehind ->
        let tag = "104=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheOpen ->
        let tag = "104=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.TakingAPosition ->
        let tag = "104=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheMarket ->
        let tag = "104=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.ReadyToTrade ->
        let tag = "104=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.PortfolioShown ->
        let tag = "104=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.ThroughTheDay ->
        let tag = "104=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.Versus ->
        let tag = "104=V"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.IndicationWorkingAway ->
        let tag = "104=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.CrossingOpportunity ->
        let tag = "104=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.AtTheMidpoint ->
        let tag = "104=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IOIQualifier.PreOpen ->
        let tag = "104=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWaveNo valIn =
    let tmp =  valIn
    WaveNo.WaveNo tmp


let WriteWaveNo (dest:byte []) (nextFreeIdx:int) (valIn:WaveNo) : int = 
   let tag = "105="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIssuer valIn =
    let tmp =  valIn
    Issuer.Issuer tmp


let WriteIssuer (dest:byte []) (nextFreeIdx:int) (valIn:Issuer) : int = 
   let tag = "106="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityDesc valIn =
    let tmp =  valIn
    SecurityDesc.SecurityDesc tmp


let WriteSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:SecurityDesc) : int = 
   let tag = "107="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHeartBtInt valIn =
    let tmp = System.Int32.Parse valIn
    HeartBtInt.HeartBtInt tmp


let WriteHeartBtInt (dest:byte []) (nextFreeIdx:int) (valIn:HeartBtInt) : int = 
   let tag = "108="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMinQty valIn =
    let tmp = System.Decimal.Parse valIn
    MinQty.MinQty tmp


let WriteMinQty (dest:byte []) (nextFreeIdx:int) (valIn:MinQty) : int = 
   let tag = "110="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMaxFloor valIn =
    let tmp = System.Decimal.Parse valIn
    MaxFloor.MaxFloor tmp


let WriteMaxFloor (dest:byte []) (nextFreeIdx:int) (valIn:MaxFloor) : int = 
   let tag = "111="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTestReqID valIn =
    let tmp =  valIn
    TestReqID.TestReqID tmp


let WriteTestReqID (dest:byte []) (nextFreeIdx:int) (valIn:TestReqID) : int = 
   let tag = "112="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadReportToExch valIn =
    let tmp = System.Boolean.Parse valIn
    ReportToExch.ReportToExch tmp


let WriteReportToExch (dest:byte []) (nextFreeIdx:int) (valIn:ReportToExch) : int = 
   let tag = "113="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLocateReqd valIn =
    let tmp = System.Boolean.Parse valIn
    LocateReqd.LocateReqd tmp


let WriteLocateReqd (dest:byte []) (nextFreeIdx:int) (valIn:LocateReqd) : int = 
   let tag = "114="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOnBehalfOfCompID valIn =
    let tmp =  valIn
    OnBehalfOfCompID.OnBehalfOfCompID tmp


let WriteOnBehalfOfCompID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfCompID) : int = 
   let tag = "115="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOnBehalfOfSubID valIn =
    let tmp =  valIn
    OnBehalfOfSubID.OnBehalfOfSubID tmp


let WriteOnBehalfOfSubID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfSubID) : int = 
   let tag = "116="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteID valIn =
    let tmp =  valIn
    QuoteID.QuoteID tmp


let WriteQuoteID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteID) : int = 
   let tag = "117="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetMoney valIn =
    let tmp = System.Int32.Parse valIn
    NetMoney.NetMoney tmp


let WriteNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:NetMoney) : int = 
   let tag = "118="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrAmt valIn =
    let tmp = System.Int32.Parse valIn
    SettlCurrAmt.SettlCurrAmt tmp


let WriteSettlCurrAmt (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrAmt) : int = 
   let tag = "119="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrency valIn =
    let tmp =  valIn
    SettlCurrency.SettlCurrency tmp


let WriteSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrency) : int = 
   let tag = "120="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadForexReq valIn =
    let tmp = System.Boolean.Parse valIn
    ForexReq.ForexReq tmp


let WriteForexReq (dest:byte []) (nextFreeIdx:int) (valIn:ForexReq) : int = 
   let tag = "121="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrigSendingTime valIn =
    let tmp =  valIn
    OrigSendingTime.OrigSendingTime tmp


let WriteOrigSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigSendingTime) : int = 
   let tag = "122="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadGapFillFlag valIn =
    let tmp = System.Boolean.Parse valIn
    GapFillFlag.GapFillFlag tmp


let WriteGapFillFlag (dest:byte []) (nextFreeIdx:int) (valIn:GapFillFlag) : int = 
   let tag = "123="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoExecs valIn =
    let tmp = System.Int32.Parse valIn
    NoExecs.NoExecs tmp


let WriteNoExecs (dest:byte []) (nextFreeIdx:int) (valIn:NoExecs) : int = 
   let tag = "124="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExpireTime valIn =
    let tmp =  valIn
    ExpireTime.ExpireTime tmp


let WriteExpireTime (dest:byte []) (nextFreeIdx:int) (valIn:ExpireTime) : int = 
   let tag = "126="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDKReason (fldValIn:string) : DKReason = 
    match fldValIn with
    |"A" -> DKReason.UnknownSymbol
    |"B" -> DKReason.WrongSide
    |"C" -> DKReason.QuantityExceedsOrder
    |"D" -> DKReason.NoMatchingOrder
    |"E" -> DKReason.PriceExceedsLimit
    |"F" -> DKReason.CalculationDifference
    |"Z" -> DKReason.Other
    | x -> failwith (sprintf "ReadDKReason unknown fix tag: %A"  x) 


let WriteDKReason (dest:byte array) (nextFreeIdx:int) (xxIn:DKReason) : int =
    match xxIn with
    | DKReason.UnknownSymbol ->
        let tag = "127=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.WrongSide ->
        let tag = "127=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.QuantityExceedsOrder ->
        let tag = "127=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.NoMatchingOrder ->
        let tag = "127=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.PriceExceedsLimit ->
        let tag = "127=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.CalculationDifference ->
        let tag = "127=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DKReason.Other ->
        let tag = "127=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDeliverToCompID valIn =
    let tmp =  valIn
    DeliverToCompID.DeliverToCompID tmp


let WriteDeliverToCompID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToCompID) : int = 
   let tag = "128="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeliverToSubID valIn =
    let tmp =  valIn
    DeliverToSubID.DeliverToSubID tmp


let WriteDeliverToSubID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToSubID) : int = 
   let tag = "129="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIOINaturalFlag valIn =
    let tmp = System.Boolean.Parse valIn
    IOINaturalFlag.IOINaturalFlag tmp


let WriteIOINaturalFlag (dest:byte []) (nextFreeIdx:int) (valIn:IOINaturalFlag) : int = 
   let tag = "130="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteReqID valIn =
    let tmp =  valIn
    QuoteReqID.QuoteReqID tmp


let WriteQuoteReqID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteReqID) : int = 
   let tag = "131="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidPx valIn =
    let tmp = System.Decimal.Parse valIn
    BidPx.BidPx tmp


let WriteBidPx (dest:byte []) (nextFreeIdx:int) (valIn:BidPx) : int = 
   let tag = "132="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferPx valIn =
    let tmp = System.Decimal.Parse valIn
    OfferPx.OfferPx tmp


let WriteOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:OfferPx) : int = 
   let tag = "133="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidSize valIn =
    let tmp = System.Decimal.Parse valIn
    BidSize.BidSize tmp


let WriteBidSize (dest:byte []) (nextFreeIdx:int) (valIn:BidSize) : int = 
   let tag = "134="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferSize valIn =
    let tmp = System.Decimal.Parse valIn
    OfferSize.OfferSize tmp


let WriteOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:OfferSize) : int = 
   let tag = "135="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoMiscFees valIn =
    let tmp = System.Int32.Parse valIn
    NoMiscFees.NoMiscFees tmp


let WriteNoMiscFees (dest:byte []) (nextFreeIdx:int) (valIn:NoMiscFees) : int = 
   let tag = "136="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMiscFeeAmt valIn =
    let tmp = System.Int32.Parse valIn
    MiscFeeAmt.MiscFeeAmt tmp


let WriteMiscFeeAmt (dest:byte []) (nextFreeIdx:int) (valIn:MiscFeeAmt) : int = 
   let tag = "137="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMiscFeeCurr valIn =
    let tmp =  valIn
    MiscFeeCurr.MiscFeeCurr tmp


let WriteMiscFeeCurr (dest:byte []) (nextFreeIdx:int) (valIn:MiscFeeCurr) : int = 
   let tag = "138="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMiscFeeType (fldValIn:string) : MiscFeeType = 
    match fldValIn with
    |"1" -> MiscFeeType.Regulatory
    |"2" -> MiscFeeType.Tax
    |"3" -> MiscFeeType.LocalCommission
    |"4" -> MiscFeeType.ExchangeFees
    |"5" -> MiscFeeType.Stamp
    |"6" -> MiscFeeType.Levy
    |"7" -> MiscFeeType.Other
    |"8" -> MiscFeeType.Markup
    |"9" -> MiscFeeType.ConsumptionTax
    |"10" -> MiscFeeType.PerTransaction
    |"11" -> MiscFeeType.Conversion
    |"12" -> MiscFeeType.Agent
    | x -> failwith (sprintf "ReadMiscFeeType unknown fix tag: %A"  x) 


let WriteMiscFeeType (dest:byte array) (nextFreeIdx:int) (xxIn:MiscFeeType) : int =
    match xxIn with
    | MiscFeeType.Regulatory ->
        let tag = "139=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Tax ->
        let tag = "139=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.LocalCommission ->
        let tag = "139=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.ExchangeFees ->
        let tag = "139=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Stamp ->
        let tag = "139=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Levy ->
        let tag = "139=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Other ->
        let tag = "139=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Markup ->
        let tag = "139=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.ConsumptionTax ->
        let tag = "139=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.PerTransaction ->
        let tag = "139=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Conversion ->
        let tag = "139=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeType.Agent ->
        let tag = "139=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPrevClosePx valIn =
    let tmp = System.Decimal.Parse valIn
    PrevClosePx.PrevClosePx tmp


let WritePrevClosePx (dest:byte []) (nextFreeIdx:int) (valIn:PrevClosePx) : int = 
   let tag = "140="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadResetSeqNumFlag valIn =
    let tmp = System.Boolean.Parse valIn
    ResetSeqNumFlag.ResetSeqNumFlag tmp


let WriteResetSeqNumFlag (dest:byte []) (nextFreeIdx:int) (valIn:ResetSeqNumFlag) : int = 
   let tag = "141="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSenderLocationID valIn =
    let tmp =  valIn
    SenderLocationID.SenderLocationID tmp


let WriteSenderLocationID (dest:byte []) (nextFreeIdx:int) (valIn:SenderLocationID) : int = 
   let tag = "142="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTargetLocationID valIn =
    let tmp =  valIn
    TargetLocationID.TargetLocationID tmp


let WriteTargetLocationID (dest:byte []) (nextFreeIdx:int) (valIn:TargetLocationID) : int = 
   let tag = "143="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOnBehalfOfLocationID valIn =
    let tmp =  valIn
    OnBehalfOfLocationID.OnBehalfOfLocationID tmp


let WriteOnBehalfOfLocationID (dest:byte []) (nextFreeIdx:int) (valIn:OnBehalfOfLocationID) : int = 
   let tag = "144="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeliverToLocationID valIn =
    let tmp =  valIn
    DeliverToLocationID.DeliverToLocationID tmp


let WriteDeliverToLocationID (dest:byte []) (nextFreeIdx:int) (valIn:DeliverToLocationID) : int = 
   let tag = "145="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoRelatedSym valIn =
    let tmp = System.Int32.Parse valIn
    NoRelatedSym.NoRelatedSym tmp


let WriteNoRelatedSym (dest:byte []) (nextFreeIdx:int) (valIn:NoRelatedSym) : int = 
   let tag = "146="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSubject valIn =
    let tmp =  valIn
    Subject.Subject tmp


let WriteSubject (dest:byte []) (nextFreeIdx:int) (valIn:Subject) : int = 
   let tag = "147="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHeadline valIn =
    let tmp =  valIn
    Headline.Headline tmp


let WriteHeadline (dest:byte []) (nextFreeIdx:int) (valIn:Headline) : int = 
   let tag = "148="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadURLLink valIn =
    let tmp =  valIn
    URLLink.URLLink tmp


let WriteURLLink (dest:byte []) (nextFreeIdx:int) (valIn:URLLink) : int = 
   let tag = "149="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExecType (fldValIn:string) : ExecType = 
    match fldValIn with
    |"0" -> ExecType.New
    |"1" -> ExecType.PartialFill
    |"2" -> ExecType.Fill
    |"3" -> ExecType.DoneForDay
    |"4" -> ExecType.Canceled
    |"5" -> ExecType.Replace
    |"6" -> ExecType.PendingCancel
    |"7" -> ExecType.Stopped
    |"8" -> ExecType.Rejected
    |"9" -> ExecType.Suspended
    |"A" -> ExecType.PendingNew
    |"B" -> ExecType.Calculated
    |"C" -> ExecType.Expired
    |"D" -> ExecType.Restated
    |"E" -> ExecType.PendingReplace
    |"F" -> ExecType.Trade
    |"G" -> ExecType.TradeCorrect
    |"H" -> ExecType.TradeCancel
    |"I" -> ExecType.OrderStatus
    | x -> failwith (sprintf "ReadExecType unknown fix tag: %A"  x) 


let WriteExecType (dest:byte array) (nextFreeIdx:int) (xxIn:ExecType) : int =
    match xxIn with
    | ExecType.New ->
        let tag = "150=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PartialFill ->
        let tag = "150=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Fill ->
        let tag = "150=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.DoneForDay ->
        let tag = "150=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Canceled ->
        let tag = "150=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Replace ->
        let tag = "150=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingCancel ->
        let tag = "150=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Stopped ->
        let tag = "150=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Rejected ->
        let tag = "150=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Suspended ->
        let tag = "150=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingNew ->
        let tag = "150=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Calculated ->
        let tag = "150=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Expired ->
        let tag = "150=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Restated ->
        let tag = "150=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.PendingReplace ->
        let tag = "150=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.Trade ->
        let tag = "150=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.TradeCorrect ->
        let tag = "150=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.TradeCancel ->
        let tag = "150=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecType.OrderStatus ->
        let tag = "150=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLeavesQty valIn =
    let tmp = System.Decimal.Parse valIn
    LeavesQty.LeavesQty tmp


let WriteLeavesQty (dest:byte []) (nextFreeIdx:int) (valIn:LeavesQty) : int = 
   let tag = "151="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashOrderQty valIn =
    let tmp = System.Decimal.Parse valIn
    CashOrderQty.CashOrderQty tmp


let WriteCashOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:CashOrderQty) : int = 
   let tag = "152="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocAvgPx valIn =
    let tmp = System.Decimal.Parse valIn
    AllocAvgPx.AllocAvgPx tmp


let WriteAllocAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:AllocAvgPx) : int = 
   let tag = "153="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocNetMoney valIn =
    let tmp = System.Int32.Parse valIn
    AllocNetMoney.AllocNetMoney tmp


let WriteAllocNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:AllocNetMoney) : int = 
   let tag = "154="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrFxRate valIn =
    let tmp = System.Decimal.Parse valIn
    SettlCurrFxRate.SettlCurrFxRate tmp


let WriteSettlCurrFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrFxRate) : int = 
   let tag = "155="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrFxRateCalc (fldValIn:string) : SettlCurrFxRateCalc = 
    match fldValIn with
    |"M" -> SettlCurrFxRateCalc.Multiply
    |"D" -> SettlCurrFxRateCalc.Divide
    | x -> failwith (sprintf "ReadSettlCurrFxRateCalc unknown fix tag: %A"  x) 


let WriteSettlCurrFxRateCalc (dest:byte array) (nextFreeIdx:int) (xxIn:SettlCurrFxRateCalc) : int =
    match xxIn with
    | SettlCurrFxRateCalc.Multiply ->
        let tag = "156=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlCurrFxRateCalc.Divide ->
        let tag = "156=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumDaysInterest valIn =
    let tmp = System.Int32.Parse valIn
    NumDaysInterest.NumDaysInterest tmp


let WriteNumDaysInterest (dest:byte []) (nextFreeIdx:int) (valIn:NumDaysInterest) : int = 
   let tag = "157="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAccruedInterestRate valIn =
    let tmp = System.Decimal.Parse valIn
    AccruedInterestRate.AccruedInterestRate tmp


let WriteAccruedInterestRate (dest:byte []) (nextFreeIdx:int) (valIn:AccruedInterestRate) : int = 
   let tag = "158="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAccruedInterestAmt valIn =
    let tmp = System.Int32.Parse valIn
    AccruedInterestAmt.AccruedInterestAmt tmp


let WriteAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:AccruedInterestAmt) : int = 
   let tag = "159="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstMode (fldValIn:string) : SettlInstMode = 
    match fldValIn with
    |"0" -> SettlInstMode.Default
    |"1" -> SettlInstMode.StandingInstructionsProvided
    |"4" -> SettlInstMode.SpecificOrderForASingleAccount
    |"5" -> SettlInstMode.RequestReject
    | x -> failwith (sprintf "ReadSettlInstMode unknown fix tag: %A"  x) 


let WriteSettlInstMode (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstMode) : int =
    match xxIn with
    | SettlInstMode.Default ->
        let tag = "160=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.StandingInstructionsProvided ->
        let tag = "160=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.SpecificOrderForASingleAccount ->
        let tag = "160=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstMode.RequestReject ->
        let tag = "160=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocText valIn =
    let tmp =  valIn
    AllocText.AllocText tmp


let WriteAllocText (dest:byte []) (nextFreeIdx:int) (valIn:AllocText) : int = 
   let tag = "161="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstID valIn =
    let tmp =  valIn
    SettlInstID.SettlInstID tmp


let WriteSettlInstID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstID) : int = 
   let tag = "162="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstTransType (fldValIn:string) : SettlInstTransType = 
    match fldValIn with
    |"N" -> SettlInstTransType.New
    |"C" -> SettlInstTransType.Cancel
    |"R" -> SettlInstTransType.Replace
    |"T" -> SettlInstTransType.Restate
    | x -> failwith (sprintf "ReadSettlInstTransType unknown fix tag: %A"  x) 


let WriteSettlInstTransType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstTransType) : int =
    match xxIn with
    | SettlInstTransType.New ->
        let tag = "163=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Cancel ->
        let tag = "163=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Replace ->
        let tag = "163=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstTransType.Restate ->
        let tag = "163=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEmailThreadID valIn =
    let tmp =  valIn
    EmailThreadID.EmailThreadID tmp


let WriteEmailThreadID (dest:byte []) (nextFreeIdx:int) (valIn:EmailThreadID) : int = 
   let tag = "164="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstSource (fldValIn:string) : SettlInstSource = 
    match fldValIn with
    |"1" -> SettlInstSource.BrokersInstructions
    |"2" -> SettlInstSource.InstitutionsInstructions
    |"3" -> SettlInstSource.Investor
    | x -> failwith (sprintf "ReadSettlInstSource unknown fix tag: %A"  x) 


let WriteSettlInstSource (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstSource) : int =
    match xxIn with
    | SettlInstSource.BrokersInstructions ->
        let tag = "165=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstSource.InstitutionsInstructions ->
        let tag = "165=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstSource.Investor ->
        let tag = "165=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityType (fldValIn:string) : SecurityType = 
    match fldValIn with
    |"EUSUPRA" -> SecurityType.EuroSupranationalCoupons
    |"FAC" -> SecurityType.FederalAgencyCoupon
    |"FADN" -> SecurityType.FederalAgencyDiscountNote
    |"PEF" -> SecurityType.PrivateExportFunding
    |"SUPRA" -> SecurityType.UsdSupranationalCoupons
    |"FUT" -> SecurityType.Future
    |"OPT" -> SecurityType.Option
    |"CORP" -> SecurityType.CorporateBond
    |"CPP" -> SecurityType.CorporatePrivatePlacement
    |"CB" -> SecurityType.ConvertibleBond
    |"DUAL" -> SecurityType.DualCurrency
    |"EUCORP" -> SecurityType.EuroCorporateBond
    |"XLINKD" -> SecurityType.IndexedLinked
    |"STRUCT" -> SecurityType.StructuredNotes
    |"YANK" -> SecurityType.YankeeCorporateBond
    |"FOR" -> SecurityType.ForeignExchangeContract
    |"CS" -> SecurityType.CommonStock
    |"PS" -> SecurityType.PreferredStock
    |"BRADY" -> SecurityType.BradyBond
    |"EUSOV" -> SecurityType.EuroSovereigns
    |"TBOND" -> SecurityType.UsTreasuryBond
    |"TINT" -> SecurityType.InterestStripFromAnyBondOrNote
    |"TIPS" -> SecurityType.TreasuryInflationProtectedSecurities
    |"TCAL" -> SecurityType.PrincipalStripOfACallableBondOrNote
    |"TPRN" -> SecurityType.PrincipalStripFromANonCallableBondOrNote
    |"TNOTE" -> SecurityType.UsTreasuryNote
    |"TBILL" -> SecurityType.UsTreasuryBill
    |"REPO" -> SecurityType.Repurchase
    |"FORWARD" -> SecurityType.Forward
    |"BUYSELL" -> SecurityType.BuySellback
    |"SECLOAN" -> SecurityType.SecuritiesLoan
    |"SECPLEDGE" -> SecurityType.SecuritiesPledge
    |"TERM" -> SecurityType.TermLoan
    |"RVLV" -> SecurityType.RevolverLoan
    |"RVLVTRM" -> SecurityType.RevolverTermLoan
    |"BRIDGE" -> SecurityType.BridgeLoan
    |"LOFC" -> SecurityType.LetterOfCredit
    |"SWING" -> SecurityType.SwingLineFacility
    |"DINP" -> SecurityType.DebtorInPossession
    |"DEFLTED" -> SecurityType.Defaulted
    |"WITHDRN" -> SecurityType.Withdrawn
    |"REPLACD" -> SecurityType.Replaced
    |"MATURED" -> SecurityType.Matured
    |"AMENDED" -> SecurityType.AmendedAndRestated
    |"RETIRED" -> SecurityType.Retired
    |"BA" -> SecurityType.BankersAcceptance
    |"BN" -> SecurityType.BankNotes
    |"BOX" -> SecurityType.BillOfExchanges
    |"CD" -> SecurityType.CertificateOfDeposit
    |"CL" -> SecurityType.CallLoans
    |"CP" -> SecurityType.CommercialPaper
    |"DN" -> SecurityType.DepositNotes
    |"EUCD" -> SecurityType.EuroCertificateOfDeposit
    |"EUCP" -> SecurityType.EuroCommercialPaper
    |"LQN" -> SecurityType.LiquidityNote
    |"MTN" -> SecurityType.MediumTermNotes
    |"ONITE" -> SecurityType.Overnight
    |"PN" -> SecurityType.PromissoryNote
    |"PZFJ" -> SecurityType.PlazosFijos
    |"STN" -> SecurityType.ShortTermLoanNote
    |"TD" -> SecurityType.TimeDeposit
    |"XCN" -> SecurityType.ExtendedCommNote
    |"YCD" -> SecurityType.YankeeCertificateOfDeposit
    |"ABS" -> SecurityType.AssetBackedSecurities
    |"CMBS" -> SecurityType.CorpMortgageBackedSecurities
    |"CMO" -> SecurityType.CollateralizedMortgageObligation
    |"IET" -> SecurityType.IoetteMortgage
    |"MBS" -> SecurityType.MortgageBackedSecurities
    |"MIO" -> SecurityType.MortgageInterestOnly
    |"MPO" -> SecurityType.MortgagePrincipalOnly
    |"MPP" -> SecurityType.MortgagePrivatePlacement
    |"MPT" -> SecurityType.MiscellaneousPassThrough
    |"PFAND" -> SecurityType.Pfandbriefe
    |"TBA" -> SecurityType.ToBeAnnounced
    |"AN" -> SecurityType.OtherAnticipationNotes
    |"COFO" -> SecurityType.CertificateOfObligation
    |"COFP" -> SecurityType.CertificateOfParticipation
    |"GO" -> SecurityType.GeneralObligationBonds
    |"MT" -> SecurityType.MandatoryTender
    |"RAN" -> SecurityType.RevenueAnticipationNote
    |"REV" -> SecurityType.RevenueBonds
    |"SPCLA" -> SecurityType.SpecialAssessment
    |"SPCLO" -> SecurityType.SpecialObligation
    |"SPCLT" -> SecurityType.SpecialTax
    |"TAN" -> SecurityType.TaxAnticipationNote
    |"TAXA" -> SecurityType.TaxAllocation
    |"TECP" -> SecurityType.TaxExemptCommercialPaper
    |"TRAN" -> SecurityType.TaxAndRevenueAnticipationNote
    |"VRDN" -> SecurityType.VariableRateDemandNote
    |"WAR" -> SecurityType.Warrant
    |"MF" -> SecurityType.MutualFund
    |"MLEG" -> SecurityType.MultiLegInstrument
    |"NONE" -> SecurityType.NoSecurityType
    |"?" -> SecurityType.Wildcard
    | x -> failwith (sprintf "ReadSecurityType unknown fix tag: %A"  x) 


let WriteSecurityType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityType) : int =
    match xxIn with
    | SecurityType.EuroSupranationalCoupons ->
        let tag = "167=EUSUPRA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.FederalAgencyCoupon ->
        let tag = "167=FAC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.FederalAgencyDiscountNote ->
        let tag = "167=FADN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrivateExportFunding ->
        let tag = "167=PEF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsdSupranationalCoupons ->
        let tag = "167=SUPRA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Future ->
        let tag = "167=FUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Option ->
        let tag = "167=OPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorporateBond ->
        let tag = "167=CORP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorporatePrivatePlacement ->
        let tag = "167=CPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ConvertibleBond ->
        let tag = "167=CB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DualCurrency ->
        let tag = "167=DUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCorporateBond ->
        let tag = "167=EUCORP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.IndexedLinked ->
        let tag = "167=XLINKD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.StructuredNotes ->
        let tag = "167=STRUCT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.YankeeCorporateBond ->
        let tag = "167=YANK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ForeignExchangeContract ->
        let tag = "167=FOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CommonStock ->
        let tag = "167=CS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PreferredStock ->
        let tag = "167=PS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BradyBond ->
        let tag = "167=BRADY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroSovereigns ->
        let tag = "167=EUSOV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryBond ->
        let tag = "167=TBOND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.InterestStripFromAnyBondOrNote ->
        let tag = "167=TINT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TreasuryInflationProtectedSecurities ->
        let tag = "167=TIPS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrincipalStripOfACallableBondOrNote ->
        let tag = "167=TCAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PrincipalStripFromANonCallableBondOrNote ->
        let tag = "167=TPRN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryNote ->
        let tag = "167=TNOTE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.UsTreasuryBill ->
        let tag = "167=TBILL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Repurchase ->
        let tag = "167=REPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Forward ->
        let tag = "167=FORWARD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BuySellback ->
        let tag = "167=BUYSELL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SecuritiesLoan ->
        let tag = "167=SECLOAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SecuritiesPledge ->
        let tag = "167=SECPLEDGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TermLoan ->
        let tag = "167=TERM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevolverLoan ->
        let tag = "167=RVLV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevolverTermLoan ->
        let tag = "167=RVLVTRM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BridgeLoan ->
        let tag = "167=BRIDGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.LetterOfCredit ->
        let tag = "167=LOFC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SwingLineFacility ->
        let tag = "167=SWING"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DebtorInPossession ->
        let tag = "167=DINP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Defaulted ->
        let tag = "167=DEFLTED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Withdrawn ->
        let tag = "167=WITHDRN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Replaced ->
        let tag = "167=REPLACD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Matured ->
        let tag = "167=MATURED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.AmendedAndRestated ->
        let tag = "167=AMENDED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Retired ->
        let tag = "167=RETIRED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BankersAcceptance ->
        let tag = "167=BA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BankNotes ->
        let tag = "167=BN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.BillOfExchanges ->
        let tag = "167=BOX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfDeposit ->
        let tag = "167=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CallLoans ->
        let tag = "167=CL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CommercialPaper ->
        let tag = "167=CP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.DepositNotes ->
        let tag = "167=DN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCertificateOfDeposit ->
        let tag = "167=EUCD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.EuroCommercialPaper ->
        let tag = "167=EUCP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.LiquidityNote ->
        let tag = "167=LQN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MediumTermNotes ->
        let tag = "167=MTN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Overnight ->
        let tag = "167=ONITE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PromissoryNote ->
        let tag = "167=PN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.PlazosFijos ->
        let tag = "167=PZFJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ShortTermLoanNote ->
        let tag = "167=STN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TimeDeposit ->
        let tag = "167=TD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ExtendedCommNote ->
        let tag = "167=XCN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.YankeeCertificateOfDeposit ->
        let tag = "167=YCD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.AssetBackedSecurities ->
        let tag = "167=ABS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CorpMortgageBackedSecurities ->
        let tag = "167=CMBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CollateralizedMortgageObligation ->
        let tag = "167=CMO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.IoetteMortgage ->
        let tag = "167=IET"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgageBackedSecurities ->
        let tag = "167=MBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgageInterestOnly ->
        let tag = "167=MIO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgagePrincipalOnly ->
        let tag = "167=MPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MortgagePrivatePlacement ->
        let tag = "167=MPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MiscellaneousPassThrough ->
        let tag = "167=MPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Pfandbriefe ->
        let tag = "167=PFAND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.ToBeAnnounced ->
        let tag = "167=TBA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.OtherAnticipationNotes ->
        let tag = "167=AN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfObligation ->
        let tag = "167=COFO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.CertificateOfParticipation ->
        let tag = "167=COFP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.GeneralObligationBonds ->
        let tag = "167=GO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MandatoryTender ->
        let tag = "167=MT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevenueAnticipationNote ->
        let tag = "167=RAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.RevenueBonds ->
        let tag = "167=REV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialAssessment ->
        let tag = "167=SPCLA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialObligation ->
        let tag = "167=SPCLO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.SpecialTax ->
        let tag = "167=SPCLT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAnticipationNote ->
        let tag = "167=TAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAllocation ->
        let tag = "167=TAXA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxExemptCommercialPaper ->
        let tag = "167=TECP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.TaxAndRevenueAnticipationNote ->
        let tag = "167=TRAN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.VariableRateDemandNote ->
        let tag = "167=VRDN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Warrant ->
        let tag = "167=WAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MutualFund ->
        let tag = "167=MF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.MultiLegInstrument ->
        let tag = "167=MLEG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.NoSecurityType ->
        let tag = "167=NONE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityType.Wildcard ->
        let tag = "167=?"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEffectiveTime valIn =
    let tmp =  valIn
    EffectiveTime.EffectiveTime tmp


let WriteEffectiveTime (dest:byte []) (nextFreeIdx:int) (valIn:EffectiveTime) : int = 
   let tag = "168="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStandInstDbType (fldValIn:string) : StandInstDbType = 
    match fldValIn with
    |"0" -> StandInstDbType.Other
    |"1" -> StandInstDbType.DtcSid
    |"2" -> StandInstDbType.ThomsonAlert
    |"3" -> StandInstDbType.AGlobalCustodian
    |"4" -> StandInstDbType.Accountnet
    | x -> failwith (sprintf "ReadStandInstDbType unknown fix tag: %A"  x) 


let WriteStandInstDbType (dest:byte array) (nextFreeIdx:int) (xxIn:StandInstDbType) : int =
    match xxIn with
    | StandInstDbType.Other ->
        let tag = "169=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.DtcSid ->
        let tag = "169=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.ThomsonAlert ->
        let tag = "169=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.AGlobalCustodian ->
        let tag = "169=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StandInstDbType.Accountnet ->
        let tag = "169=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStandInstDbName valIn =
    let tmp =  valIn
    StandInstDbName.StandInstDbName tmp


let WriteStandInstDbName (dest:byte []) (nextFreeIdx:int) (valIn:StandInstDbName) : int = 
   let tag = "170="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStandInstDbID valIn =
    let tmp =  valIn
    StandInstDbID.StandInstDbID tmp


let WriteStandInstDbID (dest:byte []) (nextFreeIdx:int) (valIn:StandInstDbID) : int = 
   let tag = "171="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlDeliveryType (fldValIn:string) : SettlDeliveryType = 
    match fldValIn with
    |"0" -> SettlDeliveryType.VersusPayment
    |"1" -> SettlDeliveryType.Free
    |"2" -> SettlDeliveryType.TriParty
    |"3" -> SettlDeliveryType.HoldInCustody
    | x -> failwith (sprintf "ReadSettlDeliveryType unknown fix tag: %A"  x) 


let WriteSettlDeliveryType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlDeliveryType) : int =
    match xxIn with
    | SettlDeliveryType.VersusPayment ->
        let tag = "172=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.Free ->
        let tag = "172=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.TriParty ->
        let tag = "172=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlDeliveryType.HoldInCustody ->
        let tag = "172=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidSpotRate valIn =
    let tmp = System.Decimal.Parse valIn
    BidSpotRate.BidSpotRate tmp


let WriteBidSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:BidSpotRate) : int = 
   let tag = "188="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidForwardPoints valIn =
    let tmp = System.Decimal.Parse valIn
    BidForwardPoints.BidForwardPoints tmp


let WriteBidForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:BidForwardPoints) : int = 
   let tag = "189="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferSpotRate valIn =
    let tmp = System.Decimal.Parse valIn
    OfferSpotRate.OfferSpotRate tmp


let WriteOfferSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:OfferSpotRate) : int = 
   let tag = "190="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferForwardPoints valIn =
    let tmp = System.Decimal.Parse valIn
    OfferForwardPoints.OfferForwardPoints tmp


let WriteOfferForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:OfferForwardPoints) : int = 
   let tag = "191="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderQty2 valIn =
    let tmp = System.Decimal.Parse valIn
    OrderQty2.OrderQty2 tmp


let WriteOrderQty2 (dest:byte []) (nextFreeIdx:int) (valIn:OrderQty2) : int = 
   let tag = "192="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlDate2 valIn =
    let tmp =  valIn
    SettlDate2.SettlDate2 tmp


let WriteSettlDate2 (dest:byte []) (nextFreeIdx:int) (valIn:SettlDate2) : int = 
   let tag = "193="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastSpotRate valIn =
    let tmp = System.Decimal.Parse valIn
    LastSpotRate.LastSpotRate tmp


let WriteLastSpotRate (dest:byte []) (nextFreeIdx:int) (valIn:LastSpotRate) : int = 
   let tag = "194="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastForwardPoints valIn =
    let tmp = System.Decimal.Parse valIn
    LastForwardPoints.LastForwardPoints tmp


let WriteLastForwardPoints (dest:byte []) (nextFreeIdx:int) (valIn:LastForwardPoints) : int = 
   let tag = "195="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocLinkID valIn =
    let tmp =  valIn
    AllocLinkID.AllocLinkID tmp


let WriteAllocLinkID (dest:byte []) (nextFreeIdx:int) (valIn:AllocLinkID) : int = 
   let tag = "196="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocLinkType (fldValIn:string) : AllocLinkType = 
    match fldValIn with
    |"0" -> AllocLinkType.FXNetting
    |"1" -> AllocLinkType.FXSwap
    | x -> failwith (sprintf "ReadAllocLinkType unknown fix tag: %A"  x) 


let WriteAllocLinkType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocLinkType) : int =
    match xxIn with
    | AllocLinkType.FXNetting ->
        let tag = "197=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocLinkType.FXSwap ->
        let tag = "197=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryOrderID valIn =
    let tmp =  valIn
    SecondaryOrderID.SecondaryOrderID tmp


let WriteSecondaryOrderID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryOrderID) : int = 
   let tag = "198="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoIOIQualifiers valIn =
    let tmp = System.Int32.Parse valIn
    NoIOIQualifiers.NoIOIQualifiers tmp


let WriteNoIOIQualifiers (dest:byte []) (nextFreeIdx:int) (valIn:NoIOIQualifiers) : int = 
   let tag = "199="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMaturityMonthYear valIn =
    let tmp =  valIn
    MaturityMonthYear.MaturityMonthYear tmp


let WriteMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:MaturityMonthYear) : int = 
   let tag = "200="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPutOrCall (fldValIn:string) : PutOrCall = 
    match fldValIn with
    |"0" -> PutOrCall.Put
    |"1" -> PutOrCall.Call
    | x -> failwith (sprintf "ReadPutOrCall unknown fix tag: %A"  x) 


let WritePutOrCall (dest:byte array) (nextFreeIdx:int) (xxIn:PutOrCall) : int =
    match xxIn with
    | PutOrCall.Put ->
        let tag = "201=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PutOrCall.Call ->
        let tag = "201=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikePrice valIn =
    let tmp = System.Decimal.Parse valIn
    StrikePrice.StrikePrice tmp


let WriteStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:StrikePrice) : int = 
   let tag = "202="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCoveredOrUncovered (fldValIn:string) : CoveredOrUncovered = 
    match fldValIn with
    |"0" -> CoveredOrUncovered.Covered
    |"1" -> CoveredOrUncovered.Uncovered
    | x -> failwith (sprintf "ReadCoveredOrUncovered unknown fix tag: %A"  x) 


let WriteCoveredOrUncovered (dest:byte array) (nextFreeIdx:int) (xxIn:CoveredOrUncovered) : int =
    match xxIn with
    | CoveredOrUncovered.Covered ->
        let tag = "203=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CoveredOrUncovered.Uncovered ->
        let tag = "203=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOptAttribute valIn =
    let tmp = System.Int32.Parse valIn
    OptAttribute.OptAttribute tmp


let WriteOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:OptAttribute) : int = 
   let tag = "206="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityExchange valIn =
    let tmp =  valIn
    SecurityExchange.SecurityExchange tmp


let WriteSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:SecurityExchange) : int = 
   let tag = "207="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNotifyBrokerOfCredit valIn =
    let tmp = System.Boolean.Parse valIn
    NotifyBrokerOfCredit.NotifyBrokerOfCredit tmp


let WriteNotifyBrokerOfCredit (dest:byte []) (nextFreeIdx:int) (valIn:NotifyBrokerOfCredit) : int = 
   let tag = "208="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocHandlInst (fldValIn:string) : AllocHandlInst = 
    match fldValIn with
    |"1" -> AllocHandlInst.Match
    |"2" -> AllocHandlInst.Forward
    |"3" -> AllocHandlInst.ForwardAndMatch
    | x -> failwith (sprintf "ReadAllocHandlInst unknown fix tag: %A"  x) 


let WriteAllocHandlInst (dest:byte array) (nextFreeIdx:int) (xxIn:AllocHandlInst) : int =
    match xxIn with
    | AllocHandlInst.Match ->
        let tag = "209=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocHandlInst.Forward ->
        let tag = "209=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocHandlInst.ForwardAndMatch ->
        let tag = "209=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMaxShow valIn =
    let tmp = System.Decimal.Parse valIn
    MaxShow.MaxShow tmp


let WriteMaxShow (dest:byte []) (nextFreeIdx:int) (valIn:MaxShow) : int = 
   let tag = "210="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPegOffsetValue valIn =
    let tmp = System.Decimal.Parse valIn
    PegOffsetValue.PegOffsetValue tmp


let WritePegOffsetValue (dest:byte []) (nextFreeIdx:int) (valIn:PegOffsetValue) : int = 
   let tag = "211="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteXmlData (dest:byte []) (nextFreeIdx:int) (fld:XmlData) : int =
    // write the string length part of the compound msg
    let lenTag = "212="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadXmlData valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "213" then failwith "invalid tag reading XmlData"
    if strLen <> raw.Length then failwith "mismatched string len reading XmlData"
    XmlData.XmlData raw


let ReadSettlInstRefID valIn =
    let tmp =  valIn
    SettlInstRefID.SettlInstRefID tmp


let WriteSettlInstRefID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstRefID) : int = 
   let tag = "214="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoRoutingIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoRoutingIDs.NoRoutingIDs tmp


let WriteNoRoutingIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoRoutingIDs) : int = 
   let tag = "215="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRoutingType (fldValIn:string) : RoutingType = 
    match fldValIn with
    |"1" -> RoutingType.TargetFirm
    |"2" -> RoutingType.TargetList
    |"3" -> RoutingType.BlockFirm
    |"4" -> RoutingType.BlockList
    | x -> failwith (sprintf "ReadRoutingType unknown fix tag: %A"  x) 


let WriteRoutingType (dest:byte array) (nextFreeIdx:int) (xxIn:RoutingType) : int =
    match xxIn with
    | RoutingType.TargetFirm ->
        let tag = "216=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.TargetList ->
        let tag = "216=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.BlockFirm ->
        let tag = "216=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoutingType.BlockList ->
        let tag = "216=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoutingID valIn =
    let tmp =  valIn
    RoutingID.RoutingID tmp


let WriteRoutingID (dest:byte []) (nextFreeIdx:int) (valIn:RoutingID) : int = 
   let tag = "217="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSpread valIn =
    let tmp = System.Decimal.Parse valIn
    Spread.Spread tmp


let WriteSpread (dest:byte []) (nextFreeIdx:int) (valIn:Spread) : int = 
   let tag = "218="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkCurveCurrency valIn =
    let tmp =  valIn
    BenchmarkCurveCurrency.BenchmarkCurveCurrency tmp


let WriteBenchmarkCurveCurrency (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkCurveCurrency) : int = 
   let tag = "220="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkCurveName (fldValIn:string) : BenchmarkCurveName = 
    match fldValIn with
    |"MuniAAA" -> BenchmarkCurveName.Muniaaa
    |"FutureSWAP" -> BenchmarkCurveName.Futureswap
    |"LIBID" -> BenchmarkCurveName.Libid
    |"LIBOR" -> BenchmarkCurveName.Libor
    |"OTHER" -> BenchmarkCurveName.Other
    |"SWAP" -> BenchmarkCurveName.Swap
    |"Treasury" -> BenchmarkCurveName.Treasury
    |"Euribor" -> BenchmarkCurveName.Euribor
    |"Pfandbriefe" -> BenchmarkCurveName.Pfandbriefe
    |"EONIA" -> BenchmarkCurveName.Eonia
    |"SONIA" -> BenchmarkCurveName.Sonia
    |"EUREPO" -> BenchmarkCurveName.Eurepo
    | x -> failwith (sprintf "ReadBenchmarkCurveName unknown fix tag: %A"  x) 


let WriteBenchmarkCurveName (dest:byte array) (nextFreeIdx:int) (xxIn:BenchmarkCurveName) : int =
    match xxIn with
    | BenchmarkCurveName.Muniaaa ->
        let tag = "221=MuniAAA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Futureswap ->
        let tag = "221=FutureSWAP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Libid ->
        let tag = "221=LIBID"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Libor ->
        let tag = "221=LIBOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Other ->
        let tag = "221=OTHER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Swap ->
        let tag = "221=SWAP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Treasury ->
        let tag = "221=Treasury"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Euribor ->
        let tag = "221=Euribor"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Pfandbriefe ->
        let tag = "221=Pfandbriefe"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Eonia ->
        let tag = "221=EONIA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Sonia ->
        let tag = "221=SONIA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BenchmarkCurveName.Eurepo ->
        let tag = "221=EUREPO"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBenchmarkCurvePoint valIn =
    let tmp =  valIn
    BenchmarkCurvePoint.BenchmarkCurvePoint tmp


let WriteBenchmarkCurvePoint (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkCurvePoint) : int = 
   let tag = "222="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCouponRate valIn =
    let tmp = System.Decimal.Parse valIn
    CouponRate.CouponRate tmp


let WriteCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:CouponRate) : int = 
   let tag = "223="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCouponPaymentDate valIn =
    let tmp =  valIn
    CouponPaymentDate.CouponPaymentDate tmp


let WriteCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:CouponPaymentDate) : int = 
   let tag = "224="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIssueDate valIn =
    let tmp =  valIn
    IssueDate.IssueDate tmp


let WriteIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:IssueDate) : int = 
   let tag = "225="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRepurchaseTerm valIn =
    let tmp = System.Int32.Parse valIn
    RepurchaseTerm.RepurchaseTerm tmp


let WriteRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:RepurchaseTerm) : int = 
   let tag = "226="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRepurchaseRate valIn =
    let tmp = System.Decimal.Parse valIn
    RepurchaseRate.RepurchaseRate tmp


let WriteRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:RepurchaseRate) : int = 
   let tag = "227="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadFactor valIn =
    let tmp = System.Decimal.Parse valIn
    Factor.Factor tmp


let WriteFactor (dest:byte []) (nextFreeIdx:int) (valIn:Factor) : int = 
   let tag = "228="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeOriginationDate valIn =
    let tmp =  valIn
    TradeOriginationDate.TradeOriginationDate tmp


let WriteTradeOriginationDate (dest:byte []) (nextFreeIdx:int) (valIn:TradeOriginationDate) : int = 
   let tag = "229="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExDate valIn =
    let tmp =  valIn
    ExDate.ExDate tmp


let WriteExDate (dest:byte []) (nextFreeIdx:int) (valIn:ExDate) : int = 
   let tag = "230="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContractMultiplier valIn =
    let tmp = System.Decimal.Parse valIn
    ContractMultiplier.ContractMultiplier tmp


let WriteContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:ContractMultiplier) : int = 
   let tag = "231="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoStipulations valIn =
    let tmp = System.Int32.Parse valIn
    NoStipulations.NoStipulations tmp


let WriteNoStipulations (dest:byte []) (nextFreeIdx:int) (valIn:NoStipulations) : int = 
   let tag = "232="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStipulationType (fldValIn:string) : StipulationType = 
    match fldValIn with
    |"AMT" -> StipulationType.Amt
    |"AUTOREINV" -> StipulationType.AutoReinvestmentAtOrBetter
    |"BANKQUAL" -> StipulationType.BankQualified
    |"BGNCON" -> StipulationType.BargainConditions
    |"COUPON" -> StipulationType.CouponRange
    |"CURRENCY" -> StipulationType.IsoCurrencyCode
    |"CUSTOMDATE" -> StipulationType.CustomStartEndDate
    |"GEOG" -> StipulationType.GeographicsAndPercentRange
    |"HAIRCUT" -> StipulationType.ValuationDiscount
    |"INSURED" -> StipulationType.Insured
    |"ISSUE" -> StipulationType.YearOrYearMonthOfIssue
    |"ISSUER" -> StipulationType.IssuersTicker
    |"ISSUESIZE" -> StipulationType.IssueSizeRange
    |"LOOKBACK" -> StipulationType.LookbackDays
    |"LOT" -> StipulationType.ExplicitLotIdentifier
    |"LOTVAR" -> StipulationType.LotVariance
    |"MAT" -> StipulationType.MaturityYearAndMonth
    |"MATURITY" -> StipulationType.MaturityRange
    |"MAXSUBS" -> StipulationType.MaximumSubstitutions
    |"MINQTY" -> StipulationType.MinimumQuantity
    |"MININCR" -> StipulationType.MinimumIncrement
    |"MINDNOM" -> StipulationType.MinimumDenomination
    |"PAYFREQ" -> StipulationType.PaymentFrequencyCalendar
    |"PIECES" -> StipulationType.NumberOfPieces
    |"PMAX" -> StipulationType.PoolsMaximum
    |"PPM" -> StipulationType.PoolsPerMillion
    |"PPL" -> StipulationType.PoolsPerLot
    |"PPT" -> StipulationType.PoolsPerTrade
    |"PRICE" -> StipulationType.PriceRange
    |"PRICEFREQ" -> StipulationType.PricingFrequency
    |"PROD" -> StipulationType.ProductionYear
    |"PROTECT" -> StipulationType.CallProtection
    |"PURPOSE" -> StipulationType.Purpose
    |"PXSOURCE" -> StipulationType.BenchmarkPriceSource
    |"RATING" -> StipulationType.RatingSourceAndRange
    |"RESTRICTED" -> StipulationType.Restricted
    |"SECTOR" -> StipulationType.MarketSector
    |"SECTYPE" -> StipulationType.SecuritytypeIncludedOrExcluded
    |"STRUCT" -> StipulationType.Structure
    |"SUBSFREQ" -> StipulationType.SubstitutionsFrequency
    |"SUBSLEFT" -> StipulationType.SubstitutionsLeft
    |"TEXT" -> StipulationType.FreeformText
    |"TRDVAR" -> StipulationType.TradeVariance
    |"WAC" -> StipulationType.WeightedAverageCoupon
    |"WAL" -> StipulationType.WeightedAverageLifeCoupon
    |"WALA" -> StipulationType.WeightedAverageLoanAge
    |"WAM" -> StipulationType.WeightedAverageMaturity
    |"WHOLE" -> StipulationType.WholePool
    |"YIELD" -> StipulationType.YieldRange
    |"SMM" -> StipulationType.SingleMonthlyMortality
    |"CPR" -> StipulationType.ConstantPrepaymentRate
    |"CPY" -> StipulationType.ConstantPrepaymentYield
    |"CPP" -> StipulationType.ConstantPrepaymentPenalty
    |"ABS" -> StipulationType.AbsolutePrepaymentSpeed
    |"MPR" -> StipulationType.MonthlyPrepaymentRate
    |"PSA" -> StipulationType.PercentOfBmaPrepaymentCurve
    |"PPC" -> StipulationType.PercentOfProspectusPrepaymentCurve
    |"MHP" -> StipulationType.PercentOfManufacturedHousingPrepaymentCurve
    |"HEP" -> StipulationType.FinalCprOfHomeEquityPrepaymentCurve
    | x -> failwith (sprintf "ReadStipulationType unknown fix tag: %A"  x) 


let WriteStipulationType (dest:byte array) (nextFreeIdx:int) (xxIn:StipulationType) : int =
    match xxIn with
    | StipulationType.Amt ->
        let tag = "233=AMT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.AutoReinvestmentAtOrBetter ->
        let tag = "233=AUTOREINV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BankQualified ->
        let tag = "233=BANKQUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BargainConditions ->
        let tag = "233=BGNCON"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CouponRange ->
        let tag = "233=COUPON"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IsoCurrencyCode ->
        let tag = "233=CURRENCY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CustomStartEndDate ->
        let tag = "233=CUSTOMDATE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.GeographicsAndPercentRange ->
        let tag = "233=GEOG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ValuationDiscount ->
        let tag = "233=HAIRCUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Insured ->
        let tag = "233=INSURED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.YearOrYearMonthOfIssue ->
        let tag = "233=ISSUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IssuersTicker ->
        let tag = "233=ISSUER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.IssueSizeRange ->
        let tag = "233=ISSUESIZE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.LookbackDays ->
        let tag = "233=LOOKBACK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ExplicitLotIdentifier ->
        let tag = "233=LOT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.LotVariance ->
        let tag = "233=LOTVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaturityYearAndMonth ->
        let tag = "233=MAT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaturityRange ->
        let tag = "233=MATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MaximumSubstitutions ->
        let tag = "233=MAXSUBS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumQuantity ->
        let tag = "233=MINQTY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumIncrement ->
        let tag = "233=MININCR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MinimumDenomination ->
        let tag = "233=MINDNOM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PaymentFrequencyCalendar ->
        let tag = "233=PAYFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.NumberOfPieces ->
        let tag = "233=PIECES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsMaximum ->
        let tag = "233=PMAX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerMillion ->
        let tag = "233=PPM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerLot ->
        let tag = "233=PPL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PoolsPerTrade ->
        let tag = "233=PPT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PriceRange ->
        let tag = "233=PRICE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PricingFrequency ->
        let tag = "233=PRICEFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ProductionYear ->
        let tag = "233=PROD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.CallProtection ->
        let tag = "233=PROTECT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Purpose ->
        let tag = "233=PURPOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.BenchmarkPriceSource ->
        let tag = "233=PXSOURCE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.RatingSourceAndRange ->
        let tag = "233=RATING"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Restricted ->
        let tag = "233=RESTRICTED"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MarketSector ->
        let tag = "233=SECTOR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SecuritytypeIncludedOrExcluded ->
        let tag = "233=SECTYPE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.Structure ->
        let tag = "233=STRUCT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SubstitutionsFrequency ->
        let tag = "233=SUBSFREQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SubstitutionsLeft ->
        let tag = "233=SUBSLEFT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.FreeformText ->
        let tag = "233=TEXT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.TradeVariance ->
        let tag = "233=TRDVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageCoupon ->
        let tag = "233=WAC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageLifeCoupon ->
        let tag = "233=WAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageLoanAge ->
        let tag = "233=WALA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WeightedAverageMaturity ->
        let tag = "233=WAM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.WholePool ->
        let tag = "233=WHOLE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.YieldRange ->
        let tag = "233=YIELD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.SingleMonthlyMortality ->
        let tag = "233=SMM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentRate ->
        let tag = "233=CPR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentYield ->
        let tag = "233=CPY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.ConstantPrepaymentPenalty ->
        let tag = "233=CPP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.AbsolutePrepaymentSpeed ->
        let tag = "233=ABS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.MonthlyPrepaymentRate ->
        let tag = "233=MPR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfBmaPrepaymentCurve ->
        let tag = "233=PSA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfProspectusPrepaymentCurve ->
        let tag = "233=PPC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.PercentOfManufacturedHousingPrepaymentCurve ->
        let tag = "233=MHP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationType.FinalCprOfHomeEquityPrepaymentCurve ->
        let tag = "233=HEP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStipulationValue (fldValIn:string) : StipulationValue = 
    match fldValIn with
    |"CD" -> StipulationValue.SpecialCumDividend
    |"XD" -> StipulationValue.SpecialExDividend
    |"CC" -> StipulationValue.SpecialCumCoupon
    |"XC" -> StipulationValue.SpecialExCoupon
    |"CB" -> StipulationValue.SpecialCumBonus
    |"XB" -> StipulationValue.SpecialExBonus
    |"CR" -> StipulationValue.SpecialCumRights
    |"XR" -> StipulationValue.SpecialExRights
    |"CP" -> StipulationValue.SpecialCumCapitalRepayments
    |"XP" -> StipulationValue.SpecialExCapitalRepayments
    |"CS" -> StipulationValue.CashSettlement
    |"SP" -> StipulationValue.SpecialPrice
    |"TR" -> StipulationValue.ReportForEuropeanEquityMarketSecurities
    |"GD" -> StipulationValue.GuaranteedDelivery
    | x -> failwith (sprintf "ReadStipulationValue unknown fix tag: %A"  x) 


let WriteStipulationValue (dest:byte array) (nextFreeIdx:int) (xxIn:StipulationValue) : int =
    match xxIn with
    | StipulationValue.SpecialCumDividend ->
        let tag = "234=CD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExDividend ->
        let tag = "234=XD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumCoupon ->
        let tag = "234=CC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExCoupon ->
        let tag = "234=XC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumBonus ->
        let tag = "234=CB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExBonus ->
        let tag = "234=XB"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumRights ->
        let tag = "234=CR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExRights ->
        let tag = "234=XR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialCumCapitalRepayments ->
        let tag = "234=CP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialExCapitalRepayments ->
        let tag = "234=XP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.CashSettlement ->
        let tag = "234=CS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.SpecialPrice ->
        let tag = "234=SP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.ReportForEuropeanEquityMarketSecurities ->
        let tag = "234=TR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StipulationValue.GuaranteedDelivery ->
        let tag = "234=GD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadYieldType (fldValIn:string) : YieldType = 
    match fldValIn with
    |"AFTERTAX" -> YieldType.AfterTaxYield
    |"ANNUAL" -> YieldType.AnnualYield
    |"ATISSUE" -> YieldType.YieldAtIssue
    |"AVGMATURITY" -> YieldType.YieldToAverageMaturity
    |"BOOK" -> YieldType.BookYield
    |"CALL" -> YieldType.YieldToNextCall
    |"CHANGE" -> YieldType.YieldChangeSinceClose
    |"CLOSE" -> YieldType.ClosingYield
    |"COMPOUND" -> YieldType.CompoundYield
    |"CURRENT" -> YieldType.CurrentYield
    |"GROSS" -> YieldType.TrueGrossYield
    |"GOVTEQUIV" -> YieldType.GovernmentEquivalentYield
    |"INFLATION" -> YieldType.YieldWithInflationAssumption
    |"INVERSEFLOATER" -> YieldType.InverseFloaterBondYield
    |"LASTCLOSE" -> YieldType.MostRecentClosingYield
    |"LASTMONTH" -> YieldType.ClosingYieldMostRecentMonth
    |"LASTQUARTER" -> YieldType.ClosingYieldMostRecentQuarter
    |"LASTYEAR" -> YieldType.ClosingYieldMostRecentYear
    |"LONGAVGLIFE" -> YieldType.YieldToLongestAverageLife
    |"MARK" -> YieldType.MarkToMarketYield
    |"MATURITY" -> YieldType.YieldToMaturity
    |"NEXTREFUND" -> YieldType.YieldToNextRefund
    |"OPENAVG" -> YieldType.OpenAverageYield
    |"PUT" -> YieldType.YieldToNextPut
    |"PREVCLOSE" -> YieldType.PreviousCloseYield
    |"PROCEEDS" -> YieldType.ProceedsYield
    |"SEMIANNUAL" -> YieldType.SemiAnnualYield
    |"SHORTAVGLIFE" -> YieldType.YieldToShortestAverageLife
    |"SIMPLE" -> YieldType.SimpleYield
    |"TAXEQUIV" -> YieldType.TaxEquivalentYield
    |"TENDER" -> YieldType.YieldToTenderDate
    |"TRUE" -> YieldType.TrueYield
    |"VALUE1_32" -> YieldType.YieldValueOf132
    |"WORST" -> YieldType.YieldToWorst
    | x -> failwith (sprintf "ReadYieldType unknown fix tag: %A"  x) 


let WriteYieldType (dest:byte array) (nextFreeIdx:int) (xxIn:YieldType) : int =
    match xxIn with
    | YieldType.AfterTaxYield ->
        let tag = "235=AFTERTAX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.AnnualYield ->
        let tag = "235=ANNUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldAtIssue ->
        let tag = "235=ATISSUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToAverageMaturity ->
        let tag = "235=AVGMATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.BookYield ->
        let tag = "235=BOOK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextCall ->
        let tag = "235=CALL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldChangeSinceClose ->
        let tag = "235=CHANGE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYield ->
        let tag = "235=CLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.CompoundYield ->
        let tag = "235=COMPOUND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.CurrentYield ->
        let tag = "235=CURRENT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TrueGrossYield ->
        let tag = "235=GROSS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.GovernmentEquivalentYield ->
        let tag = "235=GOVTEQUIV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldWithInflationAssumption ->
        let tag = "235=INFLATION"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.InverseFloaterBondYield ->
        let tag = "235=INVERSEFLOATER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.MostRecentClosingYield ->
        let tag = "235=LASTCLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentMonth ->
        let tag = "235=LASTMONTH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentQuarter ->
        let tag = "235=LASTQUARTER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ClosingYieldMostRecentYear ->
        let tag = "235=LASTYEAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToLongestAverageLife ->
        let tag = "235=LONGAVGLIFE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.MarkToMarketYield ->
        let tag = "235=MARK"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToMaturity ->
        let tag = "235=MATURITY"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextRefund ->
        let tag = "235=NEXTREFUND"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.OpenAverageYield ->
        let tag = "235=OPENAVG"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToNextPut ->
        let tag = "235=PUT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.PreviousCloseYield ->
        let tag = "235=PREVCLOSE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.ProceedsYield ->
        let tag = "235=PROCEEDS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.SemiAnnualYield ->
        let tag = "235=SEMIANNUAL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToShortestAverageLife ->
        let tag = "235=SHORTAVGLIFE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.SimpleYield ->
        let tag = "235=SIMPLE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TaxEquivalentYield ->
        let tag = "235=TAXEQUIV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToTenderDate ->
        let tag = "235=TENDER"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.TrueYield ->
        let tag = "235=TRUE"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldValueOf132 ->
        let tag = "235=VALUE1_32"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | YieldType.YieldToWorst ->
        let tag = "235=WORST"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadYield valIn =
    let tmp = System.Decimal.Parse valIn
    Yield.Yield tmp


let WriteYield (dest:byte []) (nextFreeIdx:int) (valIn:Yield) : int = 
   let tag = "236="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotalTakedown valIn =
    let tmp = System.Int32.Parse valIn
    TotalTakedown.TotalTakedown tmp


let WriteTotalTakedown (dest:byte []) (nextFreeIdx:int) (valIn:TotalTakedown) : int = 
   let tag = "237="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConcession valIn =
    let tmp = System.Int32.Parse valIn
    Concession.Concession tmp


let WriteConcession (dest:byte []) (nextFreeIdx:int) (valIn:Concession) : int = 
   let tag = "238="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRepoCollateralSecurityType valIn =
    let tmp = System.Int32.Parse valIn
    RepoCollateralSecurityType.RepoCollateralSecurityType tmp


let WriteRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:RepoCollateralSecurityType) : int = 
   let tag = "239="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRedemptionDate valIn =
    let tmp =  valIn
    RedemptionDate.RedemptionDate tmp


let WriteRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:RedemptionDate) : int = 
   let tag = "240="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCouponPaymentDate valIn =
    let tmp =  valIn
    UnderlyingCouponPaymentDate.UnderlyingCouponPaymentDate tmp


let WriteUnderlyingCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCouponPaymentDate) : int = 
   let tag = "241="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingIssueDate valIn =
    let tmp =  valIn
    UnderlyingIssueDate.UnderlyingIssueDate tmp


let WriteUnderlyingIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingIssueDate) : int = 
   let tag = "242="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingRepoCollateralSecurityType valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingRepoCollateralSecurityType.UnderlyingRepoCollateralSecurityType tmp


let WriteUnderlyingRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepoCollateralSecurityType) : int = 
   let tag = "243="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingRepurchaseTerm valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingRepurchaseTerm.UnderlyingRepurchaseTerm tmp


let WriteUnderlyingRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepurchaseTerm) : int = 
   let tag = "244="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingRepurchaseRate valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingRepurchaseRate.UnderlyingRepurchaseRate tmp


let WriteUnderlyingRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRepurchaseRate) : int = 
   let tag = "245="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingFactor valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingFactor.UnderlyingFactor tmp


let WriteUnderlyingFactor (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingFactor) : int = 
   let tag = "246="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingRedemptionDate valIn =
    let tmp =  valIn
    UnderlyingRedemptionDate.UnderlyingRedemptionDate tmp


let WriteUnderlyingRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingRedemptionDate) : int = 
   let tag = "247="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCouponPaymentDate valIn =
    let tmp =  valIn
    LegCouponPaymentDate.LegCouponPaymentDate tmp


let WriteLegCouponPaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:LegCouponPaymentDate) : int = 
   let tag = "248="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegIssueDate valIn =
    let tmp =  valIn
    LegIssueDate.LegIssueDate tmp


let WriteLegIssueDate (dest:byte []) (nextFreeIdx:int) (valIn:LegIssueDate) : int = 
   let tag = "249="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegRepoCollateralSecurityType valIn =
    let tmp = System.Int32.Parse valIn
    LegRepoCollateralSecurityType.LegRepoCollateralSecurityType tmp


let WriteLegRepoCollateralSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:LegRepoCollateralSecurityType) : int = 
   let tag = "250="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegRepurchaseTerm valIn =
    let tmp = System.Int32.Parse valIn
    LegRepurchaseTerm.LegRepurchaseTerm tmp


let WriteLegRepurchaseTerm (dest:byte []) (nextFreeIdx:int) (valIn:LegRepurchaseTerm) : int = 
   let tag = "251="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegRepurchaseRate valIn =
    let tmp = System.Decimal.Parse valIn
    LegRepurchaseRate.LegRepurchaseRate tmp


let WriteLegRepurchaseRate (dest:byte []) (nextFreeIdx:int) (valIn:LegRepurchaseRate) : int = 
   let tag = "252="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegFactor valIn =
    let tmp = System.Decimal.Parse valIn
    LegFactor.LegFactor tmp


let WriteLegFactor (dest:byte []) (nextFreeIdx:int) (valIn:LegFactor) : int = 
   let tag = "253="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegRedemptionDate valIn =
    let tmp =  valIn
    LegRedemptionDate.LegRedemptionDate tmp


let WriteLegRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:LegRedemptionDate) : int = 
   let tag = "254="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCreditRating valIn =
    let tmp =  valIn
    CreditRating.CreditRating tmp


let WriteCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:CreditRating) : int = 
   let tag = "255="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCreditRating valIn =
    let tmp =  valIn
    UnderlyingCreditRating.UnderlyingCreditRating tmp


let WriteUnderlyingCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCreditRating) : int = 
   let tag = "256="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCreditRating valIn =
    let tmp =  valIn
    LegCreditRating.LegCreditRating tmp


let WriteLegCreditRating (dest:byte []) (nextFreeIdx:int) (valIn:LegCreditRating) : int = 
   let tag = "257="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradedFlatSwitch valIn =
    let tmp = System.Boolean.Parse valIn
    TradedFlatSwitch.TradedFlatSwitch tmp


let WriteTradedFlatSwitch (dest:byte []) (nextFreeIdx:int) (valIn:TradedFlatSwitch) : int = 
   let tag = "258="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBasisFeatureDate valIn =
    let tmp =  valIn
    BasisFeatureDate.BasisFeatureDate tmp


let WriteBasisFeatureDate (dest:byte []) (nextFreeIdx:int) (valIn:BasisFeatureDate) : int = 
   let tag = "259="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBasisFeaturePrice valIn =
    let tmp = System.Decimal.Parse valIn
    BasisFeaturePrice.BasisFeaturePrice tmp


let WriteBasisFeaturePrice (dest:byte []) (nextFreeIdx:int) (valIn:BasisFeaturePrice) : int = 
   let tag = "260="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDReqID valIn =
    let tmp =  valIn
    MDReqID.MDReqID tmp


let WriteMDReqID (dest:byte []) (nextFreeIdx:int) (valIn:MDReqID) : int = 
   let tag = "262="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSubscriptionRequestType (fldValIn:string) : SubscriptionRequestType = 
    match fldValIn with
    |"0" -> SubscriptionRequestType.Snapshot
    |"1" -> SubscriptionRequestType.SnapshotPlusUpdates
    |"2" -> SubscriptionRequestType.DisablePreviousSnapshotPlusUpdateRequest
    | x -> failwith (sprintf "ReadSubscriptionRequestType unknown fix tag: %A"  x) 


let WriteSubscriptionRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SubscriptionRequestType) : int =
    match xxIn with
    | SubscriptionRequestType.Snapshot ->
        let tag = "263=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SubscriptionRequestType.SnapshotPlusUpdates ->
        let tag = "263=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SubscriptionRequestType.DisablePreviousSnapshotPlusUpdateRequest ->
        let tag = "263=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMarketDepth valIn =
    let tmp = System.Int32.Parse valIn
    MarketDepth.MarketDepth tmp


let WriteMarketDepth (dest:byte []) (nextFreeIdx:int) (valIn:MarketDepth) : int = 
   let tag = "264="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDUpdateType (fldValIn:string) : MDUpdateType = 
    match fldValIn with
    |"0" -> MDUpdateType.FullRefresh
    |"1" -> MDUpdateType.IncrementalRefresh
    | x -> failwith (sprintf "ReadMDUpdateType unknown fix tag: %A"  x) 


let WriteMDUpdateType (dest:byte array) (nextFreeIdx:int) (xxIn:MDUpdateType) : int =
    match xxIn with
    | MDUpdateType.FullRefresh ->
        let tag = "265=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateType.IncrementalRefresh ->
        let tag = "265=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAggregatedBook valIn =
    let tmp = System.Boolean.Parse valIn
    AggregatedBook.AggregatedBook tmp


let WriteAggregatedBook (dest:byte []) (nextFreeIdx:int) (valIn:AggregatedBook) : int = 
   let tag = "266="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoMDEntryTypes valIn =
    let tmp = System.Int32.Parse valIn
    NoMDEntryTypes.NoMDEntryTypes tmp


let WriteNoMDEntryTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoMDEntryTypes) : int = 
   let tag = "267="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoMDEntries valIn =
    let tmp = System.Int32.Parse valIn
    NoMDEntries.NoMDEntries tmp


let WriteNoMDEntries (dest:byte []) (nextFreeIdx:int) (valIn:NoMDEntries) : int = 
   let tag = "268="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntryType (fldValIn:string) : MDEntryType = 
    match fldValIn with
    |"0" -> MDEntryType.Bid
    |"1" -> MDEntryType.Offer
    |"2" -> MDEntryType.Trade
    |"3" -> MDEntryType.IndexValue
    |"4" -> MDEntryType.OpeningPrice
    |"5" -> MDEntryType.ClosingPrice
    |"6" -> MDEntryType.SettlementPrice
    |"7" -> MDEntryType.TradingSessionHighPrice
    |"8" -> MDEntryType.TradingSessionLowPrice
    |"9" -> MDEntryType.TradingSessionVwapPrice
    |"A" -> MDEntryType.Imbalance
    |"B" -> MDEntryType.TradeVolume
    |"C" -> MDEntryType.OpenInterest
    | x -> failwith (sprintf "ReadMDEntryType unknown fix tag: %A"  x) 


let WriteMDEntryType (dest:byte array) (nextFreeIdx:int) (xxIn:MDEntryType) : int =
    match xxIn with
    | MDEntryType.Bid ->
        let tag = "269=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Offer ->
        let tag = "269=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Trade ->
        let tag = "269=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.IndexValue ->
        let tag = "269=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.OpeningPrice ->
        let tag = "269=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.ClosingPrice ->
        let tag = "269=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.SettlementPrice ->
        let tag = "269=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionHighPrice ->
        let tag = "269=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionLowPrice ->
        let tag = "269=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradingSessionVwapPrice ->
        let tag = "269=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.Imbalance ->
        let tag = "269=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.TradeVolume ->
        let tag = "269=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDEntryType.OpenInterest ->
        let tag = "269=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryPx valIn =
    let tmp = System.Decimal.Parse valIn
    MDEntryPx.MDEntryPx tmp


let WriteMDEntryPx (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryPx) : int = 
   let tag = "270="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntrySize valIn =
    let tmp = System.Decimal.Parse valIn
    MDEntrySize.MDEntrySize tmp


let WriteMDEntrySize (dest:byte []) (nextFreeIdx:int) (valIn:MDEntrySize) : int = 
   let tag = "271="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntryDate valIn =
    let tmp =  valIn
    MDEntryDate.MDEntryDate tmp


let WriteMDEntryDate (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryDate) : int = 
   let tag = "272="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntryTime valIn =
    let tmp =  valIn
    MDEntryTime.MDEntryTime tmp


let WriteMDEntryTime (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryTime) : int = 
   let tag = "273="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTickDirection (fldValIn:string) : TickDirection = 
    match fldValIn with
    |"0" -> TickDirection.PlusTick
    |"1" -> TickDirection.ZeroPlusTick
    |"2" -> TickDirection.MinusTick
    |"3" -> TickDirection.ZeroMinusTick
    | x -> failwith (sprintf "ReadTickDirection unknown fix tag: %A"  x) 


let WriteTickDirection (dest:byte array) (nextFreeIdx:int) (xxIn:TickDirection) : int =
    match xxIn with
    | TickDirection.PlusTick ->
        let tag = "274=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.ZeroPlusTick ->
        let tag = "274=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.MinusTick ->
        let tag = "274=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TickDirection.ZeroMinusTick ->
        let tag = "274=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDMkt valIn =
    let tmp =  valIn
    MDMkt.MDMkt tmp


let WriteMDMkt (dest:byte []) (nextFreeIdx:int) (valIn:MDMkt) : int = 
   let tag = "275="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteCondition (fldValIn:string) : QuoteCondition = 
    match fldValIn with
    |"A" -> QuoteCondition.OpenActive
    |"B" -> QuoteCondition.ClosedInactive
    |"C" -> QuoteCondition.ExchangeBest
    |"D" -> QuoteCondition.ConsolidatedBest
    |"E" -> QuoteCondition.Locked
    |"F" -> QuoteCondition.Crossed
    |"G" -> QuoteCondition.Depth
    |"H" -> QuoteCondition.FastTrading
    |"I" -> QuoteCondition.NonFirm
    | x -> failwith (sprintf "ReadQuoteCondition unknown fix tag: %A"  x) 


let WriteQuoteCondition (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteCondition) : int =
    match xxIn with
    | QuoteCondition.OpenActive ->
        let tag = "276=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ClosedInactive ->
        let tag = "276=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ExchangeBest ->
        let tag = "276=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.ConsolidatedBest ->
        let tag = "276=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Locked ->
        let tag = "276=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Crossed ->
        let tag = "276=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.Depth ->
        let tag = "276=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.FastTrading ->
        let tag = "276=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCondition.NonFirm ->
        let tag = "276=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeCondition (fldValIn:string) : TradeCondition = 
    match fldValIn with
    |"A" -> TradeCondition.CashMarket
    |"B" -> TradeCondition.AveragePriceTrade
    |"C" -> TradeCondition.CashTrade
    |"D" -> TradeCondition.NextDayMarket
    |"E" -> TradeCondition.OpeningReopeningTradeDetail
    |"F" -> TradeCondition.IntradayTradeDetail
    |"G" -> TradeCondition.Rule127
    |"H" -> TradeCondition.Rule155
    |"I" -> TradeCondition.SoldLast
    |"J" -> TradeCondition.NextDayTrade
    |"K" -> TradeCondition.Opened
    |"L" -> TradeCondition.Seller
    |"M" -> TradeCondition.Sold
    |"N" -> TradeCondition.StoppedStock
    |"P" -> TradeCondition.ImbalanceMoreBuyers
    |"Q" -> TradeCondition.ImbalanceMoreSellers
    |"R" -> TradeCondition.OpeningPrice
    | x -> failwith (sprintf "ReadTradeCondition unknown fix tag: %A"  x) 


let WriteTradeCondition (dest:byte array) (nextFreeIdx:int) (xxIn:TradeCondition) : int =
    match xxIn with
    | TradeCondition.CashMarket ->
        let tag = "277=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.AveragePriceTrade ->
        let tag = "277=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.CashTrade ->
        let tag = "277=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.NextDayMarket ->
        let tag = "277=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.OpeningReopeningTradeDetail ->
        let tag = "277=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.IntradayTradeDetail ->
        let tag = "277=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Rule127 ->
        let tag = "277=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Rule155 ->
        let tag = "277=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.SoldLast ->
        let tag = "277=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.NextDayTrade ->
        let tag = "277=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Opened ->
        let tag = "277=K"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Seller ->
        let tag = "277=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.Sold ->
        let tag = "277=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.StoppedStock ->
        let tag = "277=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.ImbalanceMoreBuyers ->
        let tag = "277=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.ImbalanceMoreSellers ->
        let tag = "277=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeCondition.OpeningPrice ->
        let tag = "277=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryID valIn =
    let tmp =  valIn
    MDEntryID.MDEntryID tmp


let WriteMDEntryID (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryID) : int = 
   let tag = "278="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDUpdateAction (fldValIn:string) : MDUpdateAction = 
    match fldValIn with
    |"0" -> MDUpdateAction.New
    |"1" -> MDUpdateAction.Change
    |"2" -> MDUpdateAction.Delete
    | x -> failwith (sprintf "ReadMDUpdateAction unknown fix tag: %A"  x) 


let WriteMDUpdateAction (dest:byte array) (nextFreeIdx:int) (xxIn:MDUpdateAction) : int =
    match xxIn with
    | MDUpdateAction.New ->
        let tag = "279=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateAction.Change ->
        let tag = "279=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDUpdateAction.Delete ->
        let tag = "279=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryRefID valIn =
    let tmp =  valIn
    MDEntryRefID.MDEntryRefID tmp


let WriteMDEntryRefID (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryRefID) : int = 
   let tag = "280="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDReqRejReason (fldValIn:string) : MDReqRejReason = 
    match fldValIn with
    |"0" -> MDReqRejReason.UnknownSymbol
    |"1" -> MDReqRejReason.DuplicateMdreqid
    |"2" -> MDReqRejReason.InsufficientBandwidth
    |"3" -> MDReqRejReason.InsufficientPermissions
    |"4" -> MDReqRejReason.UnsupportedSubscriptionrequesttype
    |"5" -> MDReqRejReason.UnsupportedMarketdepth
    |"6" -> MDReqRejReason.UnsupportedMdupdatetype
    |"7" -> MDReqRejReason.UnsupportedAggregatedbook
    |"8" -> MDReqRejReason.UnsupportedMdentrytype
    |"9" -> MDReqRejReason.UnsupportedTradingsessionid
    |"A" -> MDReqRejReason.UnsupportedScope
    |"B" -> MDReqRejReason.UnsupportedOpenclosesettleflag
    |"C" -> MDReqRejReason.UnsupportedMdimplicitdelete
    | x -> failwith (sprintf "ReadMDReqRejReason unknown fix tag: %A"  x) 


let WriteMDReqRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:MDReqRejReason) : int =
    match xxIn with
    | MDReqRejReason.UnknownSymbol ->
        let tag = "281=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.DuplicateMdreqid ->
        let tag = "281=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.InsufficientBandwidth ->
        let tag = "281=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.InsufficientPermissions ->
        let tag = "281=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedSubscriptionrequesttype ->
        let tag = "281=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMarketdepth ->
        let tag = "281=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdupdatetype ->
        let tag = "281=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedAggregatedbook ->
        let tag = "281=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdentrytype ->
        let tag = "281=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedTradingsessionid ->
        let tag = "281=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedScope ->
        let tag = "281=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedOpenclosesettleflag ->
        let tag = "281=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MDReqRejReason.UnsupportedMdimplicitdelete ->
        let tag = "281=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDEntryOriginator valIn =
    let tmp =  valIn
    MDEntryOriginator.MDEntryOriginator tmp


let WriteMDEntryOriginator (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryOriginator) : int = 
   let tag = "282="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLocationID valIn =
    let tmp =  valIn
    LocationID.LocationID tmp


let WriteLocationID (dest:byte []) (nextFreeIdx:int) (valIn:LocationID) : int = 
   let tag = "283="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeskID valIn =
    let tmp =  valIn
    DeskID.DeskID tmp


let WriteDeskID (dest:byte []) (nextFreeIdx:int) (valIn:DeskID) : int = 
   let tag = "284="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeleteReason (fldValIn:string) : DeleteReason = 
    match fldValIn with
    |"0" -> DeleteReason.CancelationTradeBust
    |"1" -> DeleteReason.Error
    | x -> failwith (sprintf "ReadDeleteReason unknown fix tag: %A"  x) 


let WriteDeleteReason (dest:byte array) (nextFreeIdx:int) (xxIn:DeleteReason) : int =
    match xxIn with
    | DeleteReason.CancelationTradeBust ->
        let tag = "285=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeleteReason.Error ->
        let tag = "285=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOpenCloseSettlFlag (fldValIn:string) : OpenCloseSettlFlag = 
    match fldValIn with
    |"0" -> OpenCloseSettlFlag.DailyOpenCloseSettlementEntry
    |"1" -> OpenCloseSettlFlag.SessionOpenCloseSettlementEntry
    |"2" -> OpenCloseSettlFlag.DeliverySettlementEntry
    |"3" -> OpenCloseSettlFlag.ExpectedEntry
    |"4" -> OpenCloseSettlFlag.EntryFromPreviousBusinessDay
    |"5" -> OpenCloseSettlFlag.TheoreticalPriceValue
    | x -> failwith (sprintf "ReadOpenCloseSettlFlag unknown fix tag: %A"  x) 


let WriteOpenCloseSettlFlag (dest:byte array) (nextFreeIdx:int) (xxIn:OpenCloseSettlFlag) : int =
    match xxIn with
    | OpenCloseSettlFlag.DailyOpenCloseSettlementEntry ->
        let tag = "286=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.SessionOpenCloseSettlementEntry ->
        let tag = "286=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.DeliverySettlementEntry ->
        let tag = "286=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.ExpectedEntry ->
        let tag = "286=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.EntryFromPreviousBusinessDay ->
        let tag = "286=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OpenCloseSettlFlag.TheoreticalPriceValue ->
        let tag = "286=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSellerDays valIn =
    let tmp = System.Int32.Parse valIn
    SellerDays.SellerDays tmp


let WriteSellerDays (dest:byte []) (nextFreeIdx:int) (valIn:SellerDays) : int = 
   let tag = "287="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntryBuyer valIn =
    let tmp =  valIn
    MDEntryBuyer.MDEntryBuyer tmp


let WriteMDEntryBuyer (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryBuyer) : int = 
   let tag = "288="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntrySeller valIn =
    let tmp =  valIn
    MDEntrySeller.MDEntrySeller tmp


let WriteMDEntrySeller (dest:byte []) (nextFreeIdx:int) (valIn:MDEntrySeller) : int = 
   let tag = "289="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMDEntryPositionNo valIn =
    let tmp = System.Int32.Parse valIn
    MDEntryPositionNo.MDEntryPositionNo tmp


let WriteMDEntryPositionNo (dest:byte []) (nextFreeIdx:int) (valIn:MDEntryPositionNo) : int = 
   let tag = "290="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadFinancialStatus (fldValIn:string) : FinancialStatus = 
    match fldValIn with
    |"1" -> FinancialStatus.Bankrupt
    |"2" -> FinancialStatus.PendingDelisting
    | x -> failwith (sprintf "ReadFinancialStatus unknown fix tag: %A"  x) 


let WriteFinancialStatus (dest:byte array) (nextFreeIdx:int) (xxIn:FinancialStatus) : int =
    match xxIn with
    | FinancialStatus.Bankrupt ->
        let tag = "291=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | FinancialStatus.PendingDelisting ->
        let tag = "291=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCorporateAction (fldValIn:string) : CorporateAction = 
    match fldValIn with
    |"A" -> CorporateAction.ExDividend
    |"B" -> CorporateAction.ExDistribution
    |"C" -> CorporateAction.ExRights
    |"D" -> CorporateAction.New
    |"E" -> CorporateAction.ExInterest
    | x -> failwith (sprintf "ReadCorporateAction unknown fix tag: %A"  x) 


let WriteCorporateAction (dest:byte array) (nextFreeIdx:int) (xxIn:CorporateAction) : int =
    match xxIn with
    | CorporateAction.ExDividend ->
        let tag = "292=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExDistribution ->
        let tag = "292=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExRights ->
        let tag = "292=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.New ->
        let tag = "292=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CorporateAction.ExInterest ->
        let tag = "292=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDefBidSize valIn =
    let tmp = System.Decimal.Parse valIn
    DefBidSize.DefBidSize tmp


let WriteDefBidSize (dest:byte []) (nextFreeIdx:int) (valIn:DefBidSize) : int = 
   let tag = "293="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDefOfferSize valIn =
    let tmp = System.Decimal.Parse valIn
    DefOfferSize.DefOfferSize tmp


let WriteDefOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:DefOfferSize) : int = 
   let tag = "294="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoQuoteEntries valIn =
    let tmp = System.Int32.Parse valIn
    NoQuoteEntries.NoQuoteEntries tmp


let WriteNoQuoteEntries (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteEntries) : int = 
   let tag = "295="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoQuoteSets valIn =
    let tmp = System.Int32.Parse valIn
    NoQuoteSets.NoQuoteSets tmp


let WriteNoQuoteSets (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteSets) : int = 
   let tag = "296="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteStatus (fldValIn:string) : QuoteStatus = 
    match fldValIn with
    |"0" -> QuoteStatus.Accepted
    |"1" -> QuoteStatus.CanceledForSymbol
    |"2" -> QuoteStatus.CanceledForSecurityType
    |"3" -> QuoteStatus.CanceledForUnderlying
    |"4" -> QuoteStatus.CanceledAll
    |"5" -> QuoteStatus.Rejected
    |"6" -> QuoteStatus.RemovedFromMarket
    |"7" -> QuoteStatus.Expired
    |"8" -> QuoteStatus.Query
    |"9" -> QuoteStatus.QuoteNotFound
    |"10" -> QuoteStatus.Pending
    |"11" -> QuoteStatus.Pass
    |"12" -> QuoteStatus.LockedMarketWarning
    |"13" -> QuoteStatus.CrossMarketWarning
    |"14" -> QuoteStatus.CanceledDueToLockMarket
    |"15" -> QuoteStatus.CanceledDueToCrossMarket
    | x -> failwith (sprintf "ReadQuoteStatus unknown fix tag: %A"  x) 


let WriteQuoteStatus (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteStatus) : int =
    match xxIn with
    | QuoteStatus.Accepted ->
        let tag = "297=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForSymbol ->
        let tag = "297=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForSecurityType ->
        let tag = "297=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledForUnderlying ->
        let tag = "297=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledAll ->
        let tag = "297=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Rejected ->
        let tag = "297=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.RemovedFromMarket ->
        let tag = "297=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Expired ->
        let tag = "297=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Query ->
        let tag = "297=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.QuoteNotFound ->
        let tag = "297=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Pending ->
        let tag = "297=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.Pass ->
        let tag = "297=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.LockedMarketWarning ->
        let tag = "297=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CrossMarketWarning ->
        let tag = "297=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledDueToLockMarket ->
        let tag = "297=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteStatus.CanceledDueToCrossMarket ->
        let tag = "297=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteCancelType (fldValIn:string) : QuoteCancelType = 
    match fldValIn with
    |"1" -> QuoteCancelType.CancelForSymbol
    |"2" -> QuoteCancelType.CancelForSecurityType
    |"3" -> QuoteCancelType.CancelForUnderlyingSymbol
    |"4" -> QuoteCancelType.CancelAllQuotes
    | x -> failwith (sprintf "ReadQuoteCancelType unknown fix tag: %A"  x) 


let WriteQuoteCancelType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteCancelType) : int =
    match xxIn with
    | QuoteCancelType.CancelForSymbol ->
        let tag = "298=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelForSecurityType ->
        let tag = "298=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelForUnderlyingSymbol ->
        let tag = "298=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteCancelType.CancelAllQuotes ->
        let tag = "298=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteEntryID valIn =
    let tmp =  valIn
    QuoteEntryID.QuoteEntryID tmp


let WriteQuoteEntryID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteEntryID) : int = 
   let tag = "299="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteRejectReason (fldValIn:string) : QuoteRejectReason = 
    match fldValIn with
    |"1" -> QuoteRejectReason.UnknownSymbol
    |"2" -> QuoteRejectReason.ExchangeClosed
    |"3" -> QuoteRejectReason.QuoteRequestExceedsLimit
    |"4" -> QuoteRejectReason.TooLateToEnter
    |"5" -> QuoteRejectReason.UnknownQuote
    |"6" -> QuoteRejectReason.DuplicateQuote
    |"7" -> QuoteRejectReason.InvalidBidAskSpread
    |"8" -> QuoteRejectReason.InvalidPrice
    |"9" -> QuoteRejectReason.NotAuthorizedToQuoteSecurity
    |"99" -> QuoteRejectReason.Other
    | x -> failwith (sprintf "ReadQuoteRejectReason unknown fix tag: %A"  x) 


let WriteQuoteRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRejectReason) : int =
    match xxIn with
    | QuoteRejectReason.UnknownSymbol ->
        let tag = "300=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.ExchangeClosed ->
        let tag = "300=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.QuoteRequestExceedsLimit ->
        let tag = "300=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.TooLateToEnter ->
        let tag = "300=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.UnknownQuote ->
        let tag = "300=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.DuplicateQuote ->
        let tag = "300=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.InvalidBidAskSpread ->
        let tag = "300=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.InvalidPrice ->
        let tag = "300=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.NotAuthorizedToQuoteSecurity ->
        let tag = "300=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRejectReason.Other ->
        let tag = "300=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteResponseLevel (fldValIn:string) : QuoteResponseLevel = 
    match fldValIn with
    |"0" -> QuoteResponseLevel.NoAcknowledgement
    |"1" -> QuoteResponseLevel.AcknowledgeOnlyNegativeOrErroneousQuotes
    |"2" -> QuoteResponseLevel.AcknowledgeEachQuoteMessages
    | x -> failwith (sprintf "ReadQuoteResponseLevel unknown fix tag: %A"  x) 


let WriteQuoteResponseLevel (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteResponseLevel) : int =
    match xxIn with
    | QuoteResponseLevel.NoAcknowledgement ->
        let tag = "301=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteResponseLevel.AcknowledgeOnlyNegativeOrErroneousQuotes ->
        let tag = "301=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteResponseLevel.AcknowledgeEachQuoteMessages ->
        let tag = "301=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteSetID valIn =
    let tmp =  valIn
    QuoteSetID.QuoteSetID tmp


let WriteQuoteSetID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteSetID) : int = 
   let tag = "302="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteRequestType (fldValIn:string) : QuoteRequestType = 
    match fldValIn with
    |"1" -> QuoteRequestType.Manual
    |"2" -> QuoteRequestType.Automatic
    | x -> failwith (sprintf "ReadQuoteRequestType unknown fix tag: %A"  x) 


let WriteQuoteRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRequestType) : int =
    match xxIn with
    | QuoteRequestType.Manual ->
        let tag = "303=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestType.Automatic ->
        let tag = "303=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNoQuoteEntries valIn =
    let tmp = System.Int32.Parse valIn
    TotNoQuoteEntries.TotNoQuoteEntries tmp


let WriteTotNoQuoteEntries (dest:byte []) (nextFreeIdx:int) (valIn:TotNoQuoteEntries) : int = 
   let tag = "304="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityIDSource valIn =
    let tmp =  valIn
    UnderlyingSecurityIDSource.UnderlyingSecurityIDSource tmp


let WriteUnderlyingSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityIDSource) : int = 
   let tag = "305="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingIssuer valIn =
    let tmp =  valIn
    UnderlyingIssuer.UnderlyingIssuer tmp


let WriteUnderlyingIssuer (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingIssuer) : int = 
   let tag = "306="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityDesc valIn =
    let tmp =  valIn
    UnderlyingSecurityDesc.UnderlyingSecurityDesc tmp


let WriteUnderlyingSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityDesc) : int = 
   let tag = "307="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityExchange valIn =
    let tmp =  valIn
    UnderlyingSecurityExchange.UnderlyingSecurityExchange tmp


let WriteUnderlyingSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityExchange) : int = 
   let tag = "308="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityID valIn =
    let tmp =  valIn
    UnderlyingSecurityID.UnderlyingSecurityID tmp


let WriteUnderlyingSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityID) : int = 
   let tag = "309="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityType valIn =
    let tmp =  valIn
    UnderlyingSecurityType.UnderlyingSecurityType tmp


let WriteUnderlyingSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityType) : int = 
   let tag = "310="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSymbol valIn =
    let tmp =  valIn
    UnderlyingSymbol.UnderlyingSymbol tmp


let WriteUnderlyingSymbol (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSymbol) : int = 
   let tag = "311="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSymbolSfx valIn =
    let tmp =  valIn
    UnderlyingSymbolSfx.UnderlyingSymbolSfx tmp


let WriteUnderlyingSymbolSfx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSymbolSfx) : int = 
   let tag = "312="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingMaturityMonthYear valIn =
    let tmp =  valIn
    UnderlyingMaturityMonthYear.UnderlyingMaturityMonthYear tmp


let WriteUnderlyingMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingMaturityMonthYear) : int = 
   let tag = "313="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingPutOrCall (fldValIn:string) : UnderlyingPutOrCall = 
    match fldValIn with
    |"0" -> UnderlyingPutOrCall.Put
    |"1" -> UnderlyingPutOrCall.Call
    | x -> failwith (sprintf "ReadUnderlyingPutOrCall unknown fix tag: %A"  x) 


let WriteUnderlyingPutOrCall (dest:byte array) (nextFreeIdx:int) (xxIn:UnderlyingPutOrCall) : int =
    match xxIn with
    | UnderlyingPutOrCall.Put ->
        let tag = "315=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UnderlyingPutOrCall.Call ->
        let tag = "315=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingStrikePrice valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingStrikePrice.UnderlyingStrikePrice tmp


let WriteUnderlyingStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStrikePrice) : int = 
   let tag = "316="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingOptAttribute valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingOptAttribute.UnderlyingOptAttribute tmp


let WriteUnderlyingOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingOptAttribute) : int = 
   let tag = "317="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCurrency valIn =
    let tmp =  valIn
    UnderlyingCurrency.UnderlyingCurrency tmp


let WriteUnderlyingCurrency (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCurrency) : int = 
   let tag = "318="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityReqID valIn =
    let tmp =  valIn
    SecurityReqID.SecurityReqID tmp


let WriteSecurityReqID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityReqID) : int = 
   let tag = "320="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityRequestType (fldValIn:string) : SecurityRequestType = 
    match fldValIn with
    |"0" -> SecurityRequestType.RequestSecurityIdentityAndSpecifications
    |"1" -> SecurityRequestType.RequestSecurityIdentityForTheSpecificationsProvided
    |"2" -> SecurityRequestType.RequestListSecurityTypes
    |"3" -> SecurityRequestType.RequestListSecurities
    | x -> failwith (sprintf "ReadSecurityRequestType unknown fix tag: %A"  x) 


let WriteSecurityRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityRequestType) : int =
    match xxIn with
    | SecurityRequestType.RequestSecurityIdentityAndSpecifications ->
        let tag = "321=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestSecurityIdentityForTheSpecificationsProvided ->
        let tag = "321=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestListSecurityTypes ->
        let tag = "321=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestType.RequestListSecurities ->
        let tag = "321=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityResponseID valIn =
    let tmp =  valIn
    SecurityResponseID.SecurityResponseID tmp


let WriteSecurityResponseID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityResponseID) : int = 
   let tag = "322="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityResponseType (fldValIn:string) : SecurityResponseType = 
    match fldValIn with
    |"1" -> SecurityResponseType.AcceptSecurityProposalAsIs
    |"2" -> SecurityResponseType.AcceptSecurityProposalWithRevisionsAsIndicatedInTheMessage
    |"3" -> SecurityResponseType.ListOfSecurityTypesReturnedPerRequest
    |"4" -> SecurityResponseType.ListOfSecuritiesReturnedPerRequest
    |"5" -> SecurityResponseType.RejectSecurityProposal
    |"6" -> SecurityResponseType.CanNotMatchSelectionCriteria
    | x -> failwith (sprintf "ReadSecurityResponseType unknown fix tag: %A"  x) 


let WriteSecurityResponseType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityResponseType) : int =
    match xxIn with
    | SecurityResponseType.AcceptSecurityProposalAsIs ->
        let tag = "323=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.AcceptSecurityProposalWithRevisionsAsIndicatedInTheMessage ->
        let tag = "323=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.ListOfSecurityTypesReturnedPerRequest ->
        let tag = "323=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.ListOfSecuritiesReturnedPerRequest ->
        let tag = "323=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.RejectSecurityProposal ->
        let tag = "323=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityResponseType.CanNotMatchSelectionCriteria ->
        let tag = "323=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityStatusReqID valIn =
    let tmp =  valIn
    SecurityStatusReqID.SecurityStatusReqID tmp


let WriteSecurityStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityStatusReqID) : int = 
   let tag = "324="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnsolicitedIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    UnsolicitedIndicator.UnsolicitedIndicator tmp


let WriteUnsolicitedIndicator (dest:byte []) (nextFreeIdx:int) (valIn:UnsolicitedIndicator) : int = 
   let tag = "325="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityTradingStatus (fldValIn:string) : SecurityTradingStatus = 
    match fldValIn with
    |"1" -> SecurityTradingStatus.OpeningDelay
    |"2" -> SecurityTradingStatus.TradingHalt
    |"3" -> SecurityTradingStatus.Resume
    |"4" -> SecurityTradingStatus.NoOpenNoResume
    |"5" -> SecurityTradingStatus.PriceIndication
    |"6" -> SecurityTradingStatus.TradingRangeIndication
    |"7" -> SecurityTradingStatus.MarketImbalanceBuy
    |"8" -> SecurityTradingStatus.MarketImbalanceSell
    |"9" -> SecurityTradingStatus.MarketOnCloseImbalanceBuy
    |"10" -> SecurityTradingStatus.MarketOnCloseImbalanceSell
    |"11" -> SecurityTradingStatus.NotAssigned
    |"12" -> SecurityTradingStatus.NoMarketImbalance
    |"13" -> SecurityTradingStatus.NoMarketOnCloseImbalance
    |"14" -> SecurityTradingStatus.ItsPreOpening
    |"15" -> SecurityTradingStatus.NewPriceIndication
    |"16" -> SecurityTradingStatus.TradeDisseminationTime
    |"17" -> SecurityTradingStatus.ReadyToTradeStartOfSession
    |"18" -> SecurityTradingStatus.NotAvailableForTradingEndOfSession
    |"19" -> SecurityTradingStatus.NotTradedOnThisMarket
    |"20" -> SecurityTradingStatus.UnknownOrInvalid
    |"21" -> SecurityTradingStatus.PreOpen
    |"22" -> SecurityTradingStatus.OpeningRotation
    |"23" -> SecurityTradingStatus.FastMarket
    | x -> failwith (sprintf "ReadSecurityTradingStatus unknown fix tag: %A"  x) 


let WriteSecurityTradingStatus (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityTradingStatus) : int =
    match xxIn with
    | SecurityTradingStatus.OpeningDelay ->
        let tag = "326=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradingHalt ->
        let tag = "326=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.Resume ->
        let tag = "326=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoOpenNoResume ->
        let tag = "326=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.PriceIndication ->
        let tag = "326=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradingRangeIndication ->
        let tag = "326=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketImbalanceBuy ->
        let tag = "326=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketImbalanceSell ->
        let tag = "326=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketOnCloseImbalanceBuy ->
        let tag = "326=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.MarketOnCloseImbalanceSell ->
        let tag = "326=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotAssigned ->
        let tag = "326=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoMarketImbalance ->
        let tag = "326=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NoMarketOnCloseImbalance ->
        let tag = "326=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.ItsPreOpening ->
        let tag = "326=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NewPriceIndication ->
        let tag = "326=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.TradeDisseminationTime ->
        let tag = "326=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.ReadyToTradeStartOfSession ->
        let tag = "326=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotAvailableForTradingEndOfSession ->
        let tag = "326=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.NotTradedOnThisMarket ->
        let tag = "326=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.UnknownOrInvalid ->
        let tag = "326=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.PreOpen ->
        let tag = "326=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.OpeningRotation ->
        let tag = "326=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityTradingStatus.FastMarket ->
        let tag = "326=23"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadHaltReason (fldValIn:string) : HaltReason = 
    match fldValIn with
    |"I" -> HaltReason.OrderImbalance
    |"X" -> HaltReason.EquipmentChangeover
    |"P" -> HaltReason.NewsPending
    |"D" -> HaltReason.NewsDissemination
    |"E" -> HaltReason.OrderInflux
    |"M" -> HaltReason.AdditionalInformation
    | x -> failwith (sprintf "ReadHaltReason unknown fix tag: %A"  x) 


let WriteHaltReason (dest:byte array) (nextFreeIdx:int) (xxIn:HaltReason) : int =
    match xxIn with
    | HaltReason.OrderImbalance ->
        let tag = "327=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.EquipmentChangeover ->
        let tag = "327=X"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.NewsPending ->
        let tag = "327=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.NewsDissemination ->
        let tag = "327=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.OrderInflux ->
        let tag = "327=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | HaltReason.AdditionalInformation ->
        let tag = "327=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadInViewOfCommon valIn =
    let tmp = System.Boolean.Parse valIn
    InViewOfCommon.InViewOfCommon tmp


let WriteInViewOfCommon (dest:byte []) (nextFreeIdx:int) (valIn:InViewOfCommon) : int = 
   let tag = "328="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDueToRelated valIn =
    let tmp = System.Boolean.Parse valIn
    DueToRelated.DueToRelated tmp


let WriteDueToRelated (dest:byte []) (nextFreeIdx:int) (valIn:DueToRelated) : int = 
   let tag = "329="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBuyVolume valIn =
    let tmp = System.Decimal.Parse valIn
    BuyVolume.BuyVolume tmp


let WriteBuyVolume (dest:byte []) (nextFreeIdx:int) (valIn:BuyVolume) : int = 
   let tag = "330="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSellVolume valIn =
    let tmp = System.Decimal.Parse valIn
    SellVolume.SellVolume tmp


let WriteSellVolume (dest:byte []) (nextFreeIdx:int) (valIn:SellVolume) : int = 
   let tag = "331="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHighPx valIn =
    let tmp = System.Decimal.Parse valIn
    HighPx.HighPx tmp


let WriteHighPx (dest:byte []) (nextFreeIdx:int) (valIn:HighPx) : int = 
   let tag = "332="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLowPx valIn =
    let tmp = System.Decimal.Parse valIn
    LowPx.LowPx tmp


let WriteLowPx (dest:byte []) (nextFreeIdx:int) (valIn:LowPx) : int = 
   let tag = "333="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAdjustment (fldValIn:string) : Adjustment = 
    match fldValIn with
    |"1" -> Adjustment.Cancel
    |"2" -> Adjustment.Error
    |"3" -> Adjustment.Correction
    | x -> failwith (sprintf "ReadAdjustment unknown fix tag: %A"  x) 


let WriteAdjustment (dest:byte array) (nextFreeIdx:int) (xxIn:Adjustment) : int =
    match xxIn with
    | Adjustment.Cancel ->
        let tag = "334=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Adjustment.Error ->
        let tag = "334=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Adjustment.Correction ->
        let tag = "334=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesReqID valIn =
    let tmp =  valIn
    TradSesReqID.TradSesReqID tmp


let WriteTradSesReqID (dest:byte []) (nextFreeIdx:int) (valIn:TradSesReqID) : int = 
   let tag = "335="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradingSessionID valIn =
    let tmp =  valIn
    TradingSessionID.TradingSessionID tmp


let WriteTradingSessionID (dest:byte []) (nextFreeIdx:int) (valIn:TradingSessionID) : int = 
   let tag = "336="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContraTrader valIn =
    let tmp =  valIn
    ContraTrader.ContraTrader tmp


let WriteContraTrader (dest:byte []) (nextFreeIdx:int) (valIn:ContraTrader) : int = 
   let tag = "337="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesMethod (fldValIn:string) : TradSesMethod = 
    match fldValIn with
    |"1" -> TradSesMethod.Electronic
    |"2" -> TradSesMethod.OpenOutcry
    |"3" -> TradSesMethod.TwoParty
    | x -> failwith (sprintf "ReadTradSesMethod unknown fix tag: %A"  x) 


let WriteTradSesMethod (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesMethod) : int =
    match xxIn with
    | TradSesMethod.Electronic ->
        let tag = "338=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMethod.OpenOutcry ->
        let tag = "338=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMethod.TwoParty ->
        let tag = "338=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesMode (fldValIn:string) : TradSesMode = 
    match fldValIn with
    |"1" -> TradSesMode.Testing
    |"2" -> TradSesMode.Simulated
    |"3" -> TradSesMode.Production
    | x -> failwith (sprintf "ReadTradSesMode unknown fix tag: %A"  x) 


let WriteTradSesMode (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesMode) : int =
    match xxIn with
    | TradSesMode.Testing ->
        let tag = "339=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMode.Simulated ->
        let tag = "339=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesMode.Production ->
        let tag = "339=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesStatus (fldValIn:string) : TradSesStatus = 
    match fldValIn with
    |"0" -> TradSesStatus.Unknown
    |"1" -> TradSesStatus.Halted
    |"2" -> TradSesStatus.Open
    |"3" -> TradSesStatus.Closed
    |"4" -> TradSesStatus.PreOpen
    |"5" -> TradSesStatus.PreClose
    |"6" -> TradSesStatus.RequestRejected
    | x -> failwith (sprintf "ReadTradSesStatus unknown fix tag: %A"  x) 


let WriteTradSesStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesStatus) : int =
    match xxIn with
    | TradSesStatus.Unknown ->
        let tag = "340=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Halted ->
        let tag = "340=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Open ->
        let tag = "340=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.Closed ->
        let tag = "340=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.PreOpen ->
        let tag = "340=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.PreClose ->
        let tag = "340=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradSesStatus.RequestRejected ->
        let tag = "340=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradSesStartTime valIn =
    let tmp =  valIn
    TradSesStartTime.TradSesStartTime tmp


let WriteTradSesStartTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesStartTime) : int = 
   let tag = "341="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesOpenTime valIn =
    let tmp =  valIn
    TradSesOpenTime.TradSesOpenTime tmp


let WriteTradSesOpenTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesOpenTime) : int = 
   let tag = "342="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesPreCloseTime valIn =
    let tmp =  valIn
    TradSesPreCloseTime.TradSesPreCloseTime tmp


let WriteTradSesPreCloseTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesPreCloseTime) : int = 
   let tag = "343="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesCloseTime valIn =
    let tmp =  valIn
    TradSesCloseTime.TradSesCloseTime tmp


let WriteTradSesCloseTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesCloseTime) : int = 
   let tag = "344="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesEndTime valIn =
    let tmp =  valIn
    TradSesEndTime.TradSesEndTime tmp


let WriteTradSesEndTime (dest:byte []) (nextFreeIdx:int) (valIn:TradSesEndTime) : int = 
   let tag = "345="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNumberOfOrders valIn =
    let tmp = System.Int32.Parse valIn
    NumberOfOrders.NumberOfOrders tmp


let WriteNumberOfOrders (dest:byte []) (nextFreeIdx:int) (valIn:NumberOfOrders) : int = 
   let tag = "346="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMessageEncoding (fldValIn:string) : MessageEncoding = 
    match fldValIn with
    |"ISO-2022-JP" -> MessageEncoding.Iso2022Jp
    |"EUC-JP" -> MessageEncoding.EucJp
    |"SHIFT_JIS" -> MessageEncoding.ShiftJis
    |"UTF-8" -> MessageEncoding.Utf8
    | x -> failwith (sprintf "ReadMessageEncoding unknown fix tag: %A"  x) 


let WriteMessageEncoding (dest:byte array) (nextFreeIdx:int) (xxIn:MessageEncoding) : int =
    match xxIn with
    | MessageEncoding.Iso2022Jp ->
        let tag = "347=ISO-2022-JP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.EucJp ->
        let tag = "347=EUC-JP"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.ShiftJis ->
        let tag = "347=SHIFT_JIS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MessageEncoding.Utf8 ->
        let tag = "347=UTF-8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "348="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedIssuer valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "349" then failwith "invalid tag reading EncodedIssuer"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedIssuer"
    EncodedIssuer.EncodedIssuer raw


// compound write, of a length field and the corresponding string field
let WriteEncodedSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "350="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedSecurityDesc valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "351" then failwith "invalid tag reading EncodedSecurityDesc"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedSecurityDesc"
    EncodedSecurityDesc.EncodedSecurityDesc raw


// compound write, of a length field and the corresponding string field
let WriteEncodedListExecInst (dest:byte []) (nextFreeIdx:int) (fld:EncodedListExecInst) : int =
    // write the string length part of the compound msg
    let lenTag = "352="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedListExecInst valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "353" then failwith "invalid tag reading EncodedListExecInst"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedListExecInst"
    EncodedListExecInst.EncodedListExecInst raw


// compound write, of a length field and the corresponding string field
let WriteEncodedText (dest:byte []) (nextFreeIdx:int) (fld:EncodedText) : int =
    // write the string length part of the compound msg
    let lenTag = "354="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedText valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "355" then failwith "invalid tag reading EncodedText"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedText"
    EncodedText.EncodedText raw


// compound write, of a length field and the corresponding string field
let WriteEncodedSubject (dest:byte []) (nextFreeIdx:int) (fld:EncodedSubject) : int =
    // write the string length part of the compound msg
    let lenTag = "356="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedSubject valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "357" then failwith "invalid tag reading EncodedSubject"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedSubject"
    EncodedSubject.EncodedSubject raw


// compound write, of a length field and the corresponding string field
let WriteEncodedHeadline (dest:byte []) (nextFreeIdx:int) (fld:EncodedHeadline) : int =
    // write the string length part of the compound msg
    let lenTag = "358="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedHeadline valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "359" then failwith "invalid tag reading EncodedHeadline"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedHeadline"
    EncodedHeadline.EncodedHeadline raw


// compound write, of a length field and the corresponding string field
let WriteEncodedAllocText (dest:byte []) (nextFreeIdx:int) (fld:EncodedAllocText) : int =
    // write the string length part of the compound msg
    let lenTag = "360="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedAllocText valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "361" then failwith "invalid tag reading EncodedAllocText"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedAllocText"
    EncodedAllocText.EncodedAllocText raw


// compound write, of a length field and the corresponding string field
let WriteEncodedUnderlyingIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedUnderlyingIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "362="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedUnderlyingIssuer valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "363" then failwith "invalid tag reading EncodedUnderlyingIssuer"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedUnderlyingIssuer"
    EncodedUnderlyingIssuer.EncodedUnderlyingIssuer raw


// compound write, of a length field and the corresponding string field
let WriteEncodedUnderlyingSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedUnderlyingSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "364="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedUnderlyingSecurityDesc valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "365" then failwith "invalid tag reading EncodedUnderlyingSecurityDesc"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedUnderlyingSecurityDesc"
    EncodedUnderlyingSecurityDesc.EncodedUnderlyingSecurityDesc raw


let ReadAllocPrice valIn =
    let tmp = System.Decimal.Parse valIn
    AllocPrice.AllocPrice tmp


let WriteAllocPrice (dest:byte []) (nextFreeIdx:int) (valIn:AllocPrice) : int = 
   let tag = "366="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteSetValidUntilTime valIn =
    let tmp =  valIn
    QuoteSetValidUntilTime.QuoteSetValidUntilTime tmp


let WriteQuoteSetValidUntilTime (dest:byte []) (nextFreeIdx:int) (valIn:QuoteSetValidUntilTime) : int = 
   let tag = "367="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteEntryRejectReason (fldValIn:string) : QuoteEntryRejectReason = 
    match fldValIn with
    |"1" -> QuoteEntryRejectReason.UnknownSymbol
    |"2" -> QuoteEntryRejectReason.ExchangeClosed
    |"3" -> QuoteEntryRejectReason.QuoteExceedsLimit
    |"4" -> QuoteEntryRejectReason.TooLateToEnter
    |"5" -> QuoteEntryRejectReason.UnknownQuote
    |"6" -> QuoteEntryRejectReason.DuplicateQuote
    |"7" -> QuoteEntryRejectReason.InvalidBidAskSpread
    |"8" -> QuoteEntryRejectReason.InvalidPrice
    |"9" -> QuoteEntryRejectReason.NotAuthorizedToQuoteSecurity
    | x -> failwith (sprintf "ReadQuoteEntryRejectReason unknown fix tag: %A"  x) 


let WriteQuoteEntryRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteEntryRejectReason) : int =
    match xxIn with
    | QuoteEntryRejectReason.UnknownSymbol ->
        let tag = "368=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.ExchangeClosed ->
        let tag = "368=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.QuoteExceedsLimit ->
        let tag = "368=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.TooLateToEnter ->
        let tag = "368=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.UnknownQuote ->
        let tag = "368=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.DuplicateQuote ->
        let tag = "368=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.InvalidBidAskSpread ->
        let tag = "368=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.InvalidPrice ->
        let tag = "368=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteEntryRejectReason.NotAuthorizedToQuoteSecurity ->
        let tag = "368=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastMsgSeqNumProcessed valIn =
    let tmp = System.Int32.Parse valIn
    LastMsgSeqNumProcessed.LastMsgSeqNumProcessed tmp


let WriteLastMsgSeqNumProcessed (dest:byte []) (nextFreeIdx:int) (valIn:LastMsgSeqNumProcessed) : int = 
   let tag = "369="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRefTagID valIn =
    let tmp = System.Int32.Parse valIn
    RefTagID.RefTagID tmp


let WriteRefTagID (dest:byte []) (nextFreeIdx:int) (valIn:RefTagID) : int = 
   let tag = "371="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRefMsgType valIn =
    let tmp =  valIn
    RefMsgType.RefMsgType tmp


let WriteRefMsgType (dest:byte []) (nextFreeIdx:int) (valIn:RefMsgType) : int = 
   let tag = "372="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSessionRejectReason (fldValIn:string) : SessionRejectReason = 
    match fldValIn with
    |"0" -> SessionRejectReason.InvalidTagNumber
    |"1" -> SessionRejectReason.RequiredTagMissing
    |"2" -> SessionRejectReason.TagNotDefinedForThisMessageType
    |"3" -> SessionRejectReason.UndefinedTag
    |"4" -> SessionRejectReason.TagSpecifiedWithoutAValue
    |"5" -> SessionRejectReason.ValueIsIncorrect
    |"6" -> SessionRejectReason.IncorrectDataFormatForValue
    |"7" -> SessionRejectReason.DecryptionProblem
    |"8" -> SessionRejectReason.SignatureProblem
    |"9" -> SessionRejectReason.CompidProblem
    |"10" -> SessionRejectReason.SendingtimeAccuracyProblem
    |"11" -> SessionRejectReason.InvalidMsgtype
    |"12" -> SessionRejectReason.XmlValidationError
    |"13" -> SessionRejectReason.TagAppearsMoreThanOnce
    |"14" -> SessionRejectReason.TagSpecifiedOutOfRequiredOrder
    |"15" -> SessionRejectReason.RepeatingGroupFieldsOutOfOrder
    |"16" -> SessionRejectReason.IncorrectNumingroupCountForRepeatingGroup
    |"17" -> SessionRejectReason.NonDataValueIncludesFieldDelimiter
    |"99" -> SessionRejectReason.Other
    | x -> failwith (sprintf "ReadSessionRejectReason unknown fix tag: %A"  x) 


let WriteSessionRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:SessionRejectReason) : int =
    match xxIn with
    | SessionRejectReason.InvalidTagNumber ->
        let tag = "373=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.RequiredTagMissing ->
        let tag = "373=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagNotDefinedForThisMessageType ->
        let tag = "373=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.UndefinedTag ->
        let tag = "373=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagSpecifiedWithoutAValue ->
        let tag = "373=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.ValueIsIncorrect ->
        let tag = "373=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.IncorrectDataFormatForValue ->
        let tag = "373=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.DecryptionProblem ->
        let tag = "373=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.SignatureProblem ->
        let tag = "373=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.CompidProblem ->
        let tag = "373=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.SendingtimeAccuracyProblem ->
        let tag = "373=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.InvalidMsgtype ->
        let tag = "373=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.XmlValidationError ->
        let tag = "373=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagAppearsMoreThanOnce ->
        let tag = "373=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.TagSpecifiedOutOfRequiredOrder ->
        let tag = "373=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.RepeatingGroupFieldsOutOfOrder ->
        let tag = "373=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.IncorrectNumingroupCountForRepeatingGroup ->
        let tag = "373=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.NonDataValueIncludesFieldDelimiter ->
        let tag = "373=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SessionRejectReason.Other ->
        let tag = "373=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidRequestTransType (fldValIn:string) : BidRequestTransType = 
    match fldValIn with
    |"N" -> BidRequestTransType.New
    |"C" -> BidRequestTransType.Cancel
    | x -> failwith (sprintf "ReadBidRequestTransType unknown fix tag: %A"  x) 


let WriteBidRequestTransType (dest:byte array) (nextFreeIdx:int) (xxIn:BidRequestTransType) : int =
    match xxIn with
    | BidRequestTransType.New ->
        let tag = "374=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidRequestTransType.Cancel ->
        let tag = "374=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContraBroker valIn =
    let tmp =  valIn
    ContraBroker.ContraBroker tmp


let WriteContraBroker (dest:byte []) (nextFreeIdx:int) (valIn:ContraBroker) : int = 
   let tag = "375="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadComplianceID valIn =
    let tmp =  valIn
    ComplianceID.ComplianceID tmp


let WriteComplianceID (dest:byte []) (nextFreeIdx:int) (valIn:ComplianceID) : int = 
   let tag = "376="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSolicitedFlag valIn =
    let tmp = System.Boolean.Parse valIn
    SolicitedFlag.SolicitedFlag tmp


let WriteSolicitedFlag (dest:byte []) (nextFreeIdx:int) (valIn:SolicitedFlag) : int = 
   let tag = "377="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExecRestatementReason (fldValIn:string) : ExecRestatementReason = 
    match fldValIn with
    |"0" -> ExecRestatementReason.GtCorporateAction
    |"1" -> ExecRestatementReason.GtRenewalRestatement
    |"2" -> ExecRestatementReason.VerbalChange
    |"3" -> ExecRestatementReason.RepricingOfOrder
    |"4" -> ExecRestatementReason.BrokerOption
    |"5" -> ExecRestatementReason.PartialDeclineOfOrderqty
    |"6" -> ExecRestatementReason.CancelOnTradingHalt
    |"7" -> ExecRestatementReason.CancelOnSystemFailure
    |"8" -> ExecRestatementReason.MarketOption
    |"9" -> ExecRestatementReason.CanceledNotBest
    | x -> failwith (sprintf "ReadExecRestatementReason unknown fix tag: %A"  x) 


let WriteExecRestatementReason (dest:byte array) (nextFreeIdx:int) (xxIn:ExecRestatementReason) : int =
    match xxIn with
    | ExecRestatementReason.GtCorporateAction ->
        let tag = "378=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.GtRenewalRestatement ->
        let tag = "378=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.VerbalChange ->
        let tag = "378=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.RepricingOfOrder ->
        let tag = "378=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.BrokerOption ->
        let tag = "378=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.PartialDeclineOfOrderqty ->
        let tag = "378=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CancelOnTradingHalt ->
        let tag = "378=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CancelOnSystemFailure ->
        let tag = "378=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.MarketOption ->
        let tag = "378=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecRestatementReason.CanceledNotBest ->
        let tag = "378=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBusinessRejectRefID valIn =
    let tmp =  valIn
    BusinessRejectRefID.BusinessRejectRefID tmp


let WriteBusinessRejectRefID (dest:byte []) (nextFreeIdx:int) (valIn:BusinessRejectRefID) : int = 
   let tag = "379="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBusinessRejectReason (fldValIn:string) : BusinessRejectReason = 
    match fldValIn with
    |"0" -> BusinessRejectReason.Other
    |"1" -> BusinessRejectReason.UnkownId
    |"2" -> BusinessRejectReason.UnknownSecurity
    |"3" -> BusinessRejectReason.UnsupportedMessageType
    |"4" -> BusinessRejectReason.ApplicationNotAvailable
    |"5" -> BusinessRejectReason.ConditionallyRequiredFieldMissing
    |"6" -> BusinessRejectReason.NotAuthorized
    |"7" -> BusinessRejectReason.DelivertoFirmNotAvailableAtThisTime
    | x -> failwith (sprintf "ReadBusinessRejectReason unknown fix tag: %A"  x) 


let WriteBusinessRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:BusinessRejectReason) : int =
    match xxIn with
    | BusinessRejectReason.Other ->
        let tag = "380=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnkownId ->
        let tag = "380=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnknownSecurity ->
        let tag = "380=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.UnsupportedMessageType ->
        let tag = "380=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.ApplicationNotAvailable ->
        let tag = "380=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.ConditionallyRequiredFieldMissing ->
        let tag = "380=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.NotAuthorized ->
        let tag = "380=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BusinessRejectReason.DelivertoFirmNotAvailableAtThisTime ->
        let tag = "380=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadGrossTradeAmt valIn =
    let tmp = System.Int32.Parse valIn
    GrossTradeAmt.GrossTradeAmt tmp


let WriteGrossTradeAmt (dest:byte []) (nextFreeIdx:int) (valIn:GrossTradeAmt) : int = 
   let tag = "381="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoContraBrokers valIn =
    let tmp = System.Int32.Parse valIn
    NoContraBrokers.NoContraBrokers tmp


let WriteNoContraBrokers (dest:byte []) (nextFreeIdx:int) (valIn:NoContraBrokers) : int = 
   let tag = "382="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMaxMessageSize valIn =
    let tmp = System.Int32.Parse valIn
    MaxMessageSize.MaxMessageSize tmp


let WriteMaxMessageSize (dest:byte []) (nextFreeIdx:int) (valIn:MaxMessageSize) : int = 
   let tag = "383="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoMsgTypes valIn =
    let tmp = System.Int32.Parse valIn
    NoMsgTypes.NoMsgTypes tmp


let WriteNoMsgTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoMsgTypes) : int = 
   let tag = "384="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMsgDirection (fldValIn:string) : MsgDirection = 
    match fldValIn with
    |"S" -> MsgDirection.Send
    |"R" -> MsgDirection.Receive
    | x -> failwith (sprintf "ReadMsgDirection unknown fix tag: %A"  x) 


let WriteMsgDirection (dest:byte array) (nextFreeIdx:int) (xxIn:MsgDirection) : int =
    match xxIn with
    | MsgDirection.Send ->
        let tag = "385=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MsgDirection.Receive ->
        let tag = "385=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoTradingSessions valIn =
    let tmp = System.Int32.Parse valIn
    NoTradingSessions.NoTradingSessions tmp


let WriteNoTradingSessions (dest:byte []) (nextFreeIdx:int) (valIn:NoTradingSessions) : int = 
   let tag = "386="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotalVolumeTraded valIn =
    let tmp = System.Decimal.Parse valIn
    TotalVolumeTraded.TotalVolumeTraded tmp


let WriteTotalVolumeTraded (dest:byte []) (nextFreeIdx:int) (valIn:TotalVolumeTraded) : int = 
   let tag = "387="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDiscretionInst (fldValIn:string) : DiscretionInst = 
    match fldValIn with
    |"0" -> DiscretionInst.RelatedToDisplayedPrice
    |"1" -> DiscretionInst.RelatedToMarketPrice
    |"2" -> DiscretionInst.RelatedToPrimaryPrice
    |"3" -> DiscretionInst.RelatedToLocalPrimaryPrice
    |"4" -> DiscretionInst.RelatedToMidpointPrice
    |"5" -> DiscretionInst.RelatedToLastTradePrice
    |"6" -> DiscretionInst.RelatedToVwap
    | x -> failwith (sprintf "ReadDiscretionInst unknown fix tag: %A"  x) 


let WriteDiscretionInst (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionInst) : int =
    match xxIn with
    | DiscretionInst.RelatedToDisplayedPrice ->
        let tag = "388=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToMarketPrice ->
        let tag = "388=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToPrimaryPrice ->
        let tag = "388=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToLocalPrimaryPrice ->
        let tag = "388=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToMidpointPrice ->
        let tag = "388=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToLastTradePrice ->
        let tag = "388=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionInst.RelatedToVwap ->
        let tag = "388=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionOffsetValue valIn =
    let tmp = System.Decimal.Parse valIn
    DiscretionOffsetValue.DiscretionOffsetValue tmp


let WriteDiscretionOffsetValue (dest:byte []) (nextFreeIdx:int) (valIn:DiscretionOffsetValue) : int = 
   let tag = "389="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidID valIn =
    let tmp =  valIn
    BidID.BidID tmp


let WriteBidID (dest:byte []) (nextFreeIdx:int) (valIn:BidID) : int = 
   let tag = "390="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadClientBidID valIn =
    let tmp =  valIn
    ClientBidID.ClientBidID tmp


let WriteClientBidID (dest:byte []) (nextFreeIdx:int) (valIn:ClientBidID) : int = 
   let tag = "391="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListName valIn =
    let tmp =  valIn
    ListName.ListName tmp


let WriteListName (dest:byte []) (nextFreeIdx:int) (valIn:ListName) : int = 
   let tag = "392="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotNoRelatedSym valIn =
    let tmp = System.Int32.Parse valIn
    TotNoRelatedSym.TotNoRelatedSym tmp


let WriteTotNoRelatedSym (dest:byte []) (nextFreeIdx:int) (valIn:TotNoRelatedSym) : int = 
   let tag = "393="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidType (fldValIn:string) : BidType = 
    match fldValIn with
    |"1" -> BidType.NonDisclosed
    |"2" -> BidType.DisclosedStyle
    |"3" -> BidType.NoBiddingProcess
    | x -> failwith (sprintf "ReadBidType unknown fix tag: %A"  x) 


let WriteBidType (dest:byte array) (nextFreeIdx:int) (xxIn:BidType) : int =
    match xxIn with
    | BidType.NonDisclosed ->
        let tag = "394=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidType.DisclosedStyle ->
        let tag = "394=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidType.NoBiddingProcess ->
        let tag = "394=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumTickets valIn =
    let tmp = System.Int32.Parse valIn
    NumTickets.NumTickets tmp


let WriteNumTickets (dest:byte []) (nextFreeIdx:int) (valIn:NumTickets) : int = 
   let tag = "395="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSideValue1 valIn =
    let tmp = System.Int32.Parse valIn
    SideValue1.SideValue1 tmp


let WriteSideValue1 (dest:byte []) (nextFreeIdx:int) (valIn:SideValue1) : int = 
   let tag = "396="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSideValue2 valIn =
    let tmp = System.Int32.Parse valIn
    SideValue2.SideValue2 tmp


let WriteSideValue2 (dest:byte []) (nextFreeIdx:int) (valIn:SideValue2) : int = 
   let tag = "397="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoBidDescriptors valIn =
    let tmp = System.Int32.Parse valIn
    NoBidDescriptors.NoBidDescriptors tmp


let WriteNoBidDescriptors (dest:byte []) (nextFreeIdx:int) (valIn:NoBidDescriptors) : int = 
   let tag = "398="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidDescriptorType (fldValIn:string) : BidDescriptorType = 
    match fldValIn with
    |"1" -> BidDescriptorType.Sector
    |"2" -> BidDescriptorType.Country
    |"3" -> BidDescriptorType.Index
    | x -> failwith (sprintf "ReadBidDescriptorType unknown fix tag: %A"  x) 


let WriteBidDescriptorType (dest:byte array) (nextFreeIdx:int) (xxIn:BidDescriptorType) : int =
    match xxIn with
    | BidDescriptorType.Sector ->
        let tag = "399=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidDescriptorType.Country ->
        let tag = "399=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidDescriptorType.Index ->
        let tag = "399=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBidDescriptor valIn =
    let tmp =  valIn
    BidDescriptor.BidDescriptor tmp


let WriteBidDescriptor (dest:byte []) (nextFreeIdx:int) (valIn:BidDescriptor) : int = 
   let tag = "400="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSideValueInd (fldValIn:string) : SideValueInd = 
    match fldValIn with
    |"1" -> SideValueInd.Sidevalue1
    |"2" -> SideValueInd.Sidevalue2
    | x -> failwith (sprintf "ReadSideValueInd unknown fix tag: %A"  x) 


let WriteSideValueInd (dest:byte array) (nextFreeIdx:int) (xxIn:SideValueInd) : int =
    match xxIn with
    | SideValueInd.Sidevalue1 ->
        let tag = "401=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideValueInd.Sidevalue2 ->
        let tag = "401=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLiquidityPctLow valIn =
    let tmp = System.Decimal.Parse valIn
    LiquidityPctLow.LiquidityPctLow tmp


let WriteLiquidityPctLow (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityPctLow) : int = 
   let tag = "402="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLiquidityPctHigh valIn =
    let tmp = System.Decimal.Parse valIn
    LiquidityPctHigh.LiquidityPctHigh tmp


let WriteLiquidityPctHigh (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityPctHigh) : int = 
   let tag = "403="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLiquidityValue valIn =
    let tmp = System.Int32.Parse valIn
    LiquidityValue.LiquidityValue tmp


let WriteLiquidityValue (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityValue) : int = 
   let tag = "404="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEFPTrackingError valIn =
    let tmp = System.Decimal.Parse valIn
    EFPTrackingError.EFPTrackingError tmp


let WriteEFPTrackingError (dest:byte []) (nextFreeIdx:int) (valIn:EFPTrackingError) : int = 
   let tag = "405="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadFairValue valIn =
    let tmp = System.Int32.Parse valIn
    FairValue.FairValue tmp


let WriteFairValue (dest:byte []) (nextFreeIdx:int) (valIn:FairValue) : int = 
   let tag = "406="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOutsideIndexPct valIn =
    let tmp = System.Decimal.Parse valIn
    OutsideIndexPct.OutsideIndexPct tmp


let WriteOutsideIndexPct (dest:byte []) (nextFreeIdx:int) (valIn:OutsideIndexPct) : int = 
   let tag = "407="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadValueOfFutures valIn =
    let tmp = System.Int32.Parse valIn
    ValueOfFutures.ValueOfFutures tmp


let WriteValueOfFutures (dest:byte []) (nextFreeIdx:int) (valIn:ValueOfFutures) : int = 
   let tag = "408="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLiquidityIndType (fldValIn:string) : LiquidityIndType = 
    match fldValIn with
    |"1" -> LiquidityIndType.FivedayMovingAverage
    |"2" -> LiquidityIndType.TwentydayMovingAverage
    |"3" -> LiquidityIndType.NormalMarketSize
    |"4" -> LiquidityIndType.Other
    | x -> failwith (sprintf "ReadLiquidityIndType unknown fix tag: %A"  x) 


let WriteLiquidityIndType (dest:byte array) (nextFreeIdx:int) (xxIn:LiquidityIndType) : int =
    match xxIn with
    | LiquidityIndType.FivedayMovingAverage ->
        let tag = "409=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.TwentydayMovingAverage ->
        let tag = "409=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.NormalMarketSize ->
        let tag = "409=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LiquidityIndType.Other ->
        let tag = "409=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWtAverageLiquidity valIn =
    let tmp = System.Decimal.Parse valIn
    WtAverageLiquidity.WtAverageLiquidity tmp


let WriteWtAverageLiquidity (dest:byte []) (nextFreeIdx:int) (valIn:WtAverageLiquidity) : int = 
   let tag = "410="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExchangeForPhysical valIn =
    let tmp = System.Boolean.Parse valIn
    ExchangeForPhysical.ExchangeForPhysical tmp


let WriteExchangeForPhysical (dest:byte []) (nextFreeIdx:int) (valIn:ExchangeForPhysical) : int = 
   let tag = "411="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOutMainCntryUIndex valIn =
    let tmp = System.Int32.Parse valIn
    OutMainCntryUIndex.OutMainCntryUIndex tmp


let WriteOutMainCntryUIndex (dest:byte []) (nextFreeIdx:int) (valIn:OutMainCntryUIndex) : int = 
   let tag = "412="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCrossPercent valIn =
    let tmp = System.Decimal.Parse valIn
    CrossPercent.CrossPercent tmp


let WriteCrossPercent (dest:byte []) (nextFreeIdx:int) (valIn:CrossPercent) : int = 
   let tag = "413="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadProgRptReqs (fldValIn:string) : ProgRptReqs = 
    match fldValIn with
    |"1" -> ProgRptReqs.BuysideExplicitlyRequestsStatusUsingStatusrequest
    |"2" -> ProgRptReqs.SellsidePeriodicallySendsStatusUsingListstatus
    |"3" -> ProgRptReqs.RealTimeExecutionReports
    | x -> failwith (sprintf "ReadProgRptReqs unknown fix tag: %A"  x) 


let WriteProgRptReqs (dest:byte array) (nextFreeIdx:int) (xxIn:ProgRptReqs) : int =
    match xxIn with
    | ProgRptReqs.BuysideExplicitlyRequestsStatusUsingStatusrequest ->
        let tag = "414=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProgRptReqs.SellsidePeriodicallySendsStatusUsingListstatus ->
        let tag = "414=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ProgRptReqs.RealTimeExecutionReports ->
        let tag = "414=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadProgPeriodInterval valIn =
    let tmp = System.Int32.Parse valIn
    ProgPeriodInterval.ProgPeriodInterval tmp


let WriteProgPeriodInterval (dest:byte []) (nextFreeIdx:int) (valIn:ProgPeriodInterval) : int = 
   let tag = "415="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIncTaxInd (fldValIn:string) : IncTaxInd = 
    match fldValIn with
    |"1" -> IncTaxInd.Net
    |"2" -> IncTaxInd.Gross
    | x -> failwith (sprintf "ReadIncTaxInd unknown fix tag: %A"  x) 


let WriteIncTaxInd (dest:byte array) (nextFreeIdx:int) (xxIn:IncTaxInd) : int =
    match xxIn with
    | IncTaxInd.Net ->
        let tag = "416=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | IncTaxInd.Gross ->
        let tag = "416=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNumBidders valIn =
    let tmp = System.Int32.Parse valIn
    NumBidders.NumBidders tmp


let WriteNumBidders (dest:byte []) (nextFreeIdx:int) (valIn:NumBidders) : int = 
   let tag = "417="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidTradeType (fldValIn:string) : BidTradeType = 
    match fldValIn with
    |"R" -> BidTradeType.RiskTrade
    |"G" -> BidTradeType.VwapGuarantee
    |"A" -> BidTradeType.Agency
    |"J" -> BidTradeType.GuaranteedClose
    | x -> failwith (sprintf "ReadBidTradeType unknown fix tag: %A"  x) 


let WriteBidTradeType (dest:byte array) (nextFreeIdx:int) (xxIn:BidTradeType) : int =
    match xxIn with
    | BidTradeType.RiskTrade ->
        let tag = "418=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.VwapGuarantee ->
        let tag = "418=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.Agency ->
        let tag = "418=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BidTradeType.GuaranteedClose ->
        let tag = "418=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBasisPxType (fldValIn:string) : BasisPxType = 
    match fldValIn with
    |"2" -> BasisPxType.ClosingPriceAtMorningSession
    |"3" -> BasisPxType.ClosingPrice
    |"4" -> BasisPxType.CurrentPrice
    |"5" -> BasisPxType.Sq
    |"6" -> BasisPxType.VwapThroughADay
    |"7" -> BasisPxType.VwapThroughAMorningSession
    |"8" -> BasisPxType.VwapThroughAnAfternoonSession
    |"9" -> BasisPxType.VwapThroughADayExceptYori
    |"A" -> BasisPxType.VwapThroughAMorningSessionExceptYori
    |"B" -> BasisPxType.VwapThroughAnAfternoonSessionExceptYori
    |"C" -> BasisPxType.Strike
    |"D" -> BasisPxType.Open
    |"Z" -> BasisPxType.Others
    | x -> failwith (sprintf "ReadBasisPxType unknown fix tag: %A"  x) 


let WriteBasisPxType (dest:byte array) (nextFreeIdx:int) (xxIn:BasisPxType) : int =
    match xxIn with
    | BasisPxType.ClosingPriceAtMorningSession ->
        let tag = "419=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.ClosingPrice ->
        let tag = "419=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.CurrentPrice ->
        let tag = "419=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Sq ->
        let tag = "419=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughADay ->
        let tag = "419=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAMorningSession ->
        let tag = "419=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAnAfternoonSession ->
        let tag = "419=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughADayExceptYori ->
        let tag = "419=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAMorningSessionExceptYori ->
        let tag = "419=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.VwapThroughAnAfternoonSessionExceptYori ->
        let tag = "419=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Strike ->
        let tag = "419=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Open ->
        let tag = "419=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BasisPxType.Others ->
        let tag = "419=Z"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoBidComponents valIn =
    let tmp = System.Int32.Parse valIn
    NoBidComponents.NoBidComponents tmp


let WriteNoBidComponents (dest:byte []) (nextFreeIdx:int) (valIn:NoBidComponents) : int = 
   let tag = "420="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCountry valIn =
    let tmp =  valIn
    Country.Country tmp


let WriteCountry (dest:byte []) (nextFreeIdx:int) (valIn:Country) : int = 
   let tag = "421="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotNoStrikes valIn =
    let tmp = System.Int32.Parse valIn
    TotNoStrikes.TotNoStrikes tmp


let WriteTotNoStrikes (dest:byte []) (nextFreeIdx:int) (valIn:TotNoStrikes) : int = 
   let tag = "422="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPriceType (fldValIn:string) : PriceType = 
    match fldValIn with
    |"1" -> PriceType.Percentage
    |"2" -> PriceType.PerUnit
    |"3" -> PriceType.FixedAmount
    |"4" -> PriceType.Discount
    |"5" -> PriceType.Premium
    |"6" -> PriceType.Spread
    |"7" -> PriceType.TedPrice
    |"8" -> PriceType.TedYield
    |"9" -> PriceType.Yield
    |"10" -> PriceType.FixedCabinetTradePrice
    |"11" -> PriceType.VariableCabinetTradePrice
    | x -> failwith (sprintf "ReadPriceType unknown fix tag: %A"  x) 


let WritePriceType (dest:byte array) (nextFreeIdx:int) (xxIn:PriceType) : int =
    match xxIn with
    | PriceType.Percentage ->
        let tag = "423=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.PerUnit ->
        let tag = "423=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.FixedAmount ->
        let tag = "423=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Discount ->
        let tag = "423=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Premium ->
        let tag = "423=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Spread ->
        let tag = "423=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.TedPrice ->
        let tag = "423=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.TedYield ->
        let tag = "423=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.Yield ->
        let tag = "423=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.FixedCabinetTradePrice ->
        let tag = "423=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriceType.VariableCabinetTradePrice ->
        let tag = "423=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDayOrderQty valIn =
    let tmp = System.Decimal.Parse valIn
    DayOrderQty.DayOrderQty tmp


let WriteDayOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:DayOrderQty) : int = 
   let tag = "424="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDayCumQty valIn =
    let tmp = System.Decimal.Parse valIn
    DayCumQty.DayCumQty tmp


let WriteDayCumQty (dest:byte []) (nextFreeIdx:int) (valIn:DayCumQty) : int = 
   let tag = "425="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDayAvgPx valIn =
    let tmp = System.Decimal.Parse valIn
    DayAvgPx.DayAvgPx tmp


let WriteDayAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:DayAvgPx) : int = 
   let tag = "426="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadGTBookingInst (fldValIn:string) : GTBookingInst = 
    match fldValIn with
    |"0" -> GTBookingInst.BookOutAllTradesOnDayOfExecution
    |"1" -> GTBookingInst.AccumulateExecutionsUntilOrderIsFilledOrExpires
    |"2" -> GTBookingInst.AccumulateUntilVerballyNotifiedOtherwise
    | x -> failwith (sprintf "ReadGTBookingInst unknown fix tag: %A"  x) 


let WriteGTBookingInst (dest:byte array) (nextFreeIdx:int) (xxIn:GTBookingInst) : int =
    match xxIn with
    | GTBookingInst.BookOutAllTradesOnDayOfExecution ->
        let tag = "427=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | GTBookingInst.AccumulateExecutionsUntilOrderIsFilledOrExpires ->
        let tag = "427=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | GTBookingInst.AccumulateUntilVerballyNotifiedOtherwise ->
        let tag = "427=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoStrikes valIn =
    let tmp = System.Int32.Parse valIn
    NoStrikes.NoStrikes tmp


let WriteNoStrikes (dest:byte []) (nextFreeIdx:int) (valIn:NoStrikes) : int = 
   let tag = "428="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListStatusType (fldValIn:string) : ListStatusType = 
    match fldValIn with
    |"1" -> ListStatusType.Ack
    |"2" -> ListStatusType.Response
    |"3" -> ListStatusType.Timed
    |"4" -> ListStatusType.Execstarted
    |"5" -> ListStatusType.Alldone
    |"6" -> ListStatusType.Alert
    | x -> failwith (sprintf "ReadListStatusType unknown fix tag: %A"  x) 


let WriteListStatusType (dest:byte array) (nextFreeIdx:int) (xxIn:ListStatusType) : int =
    match xxIn with
    | ListStatusType.Ack ->
        let tag = "429=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Response ->
        let tag = "429=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Timed ->
        let tag = "429=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Execstarted ->
        let tag = "429=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Alldone ->
        let tag = "429=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListStatusType.Alert ->
        let tag = "429=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNetGrossInd (fldValIn:string) : NetGrossInd = 
    match fldValIn with
    |"1" -> NetGrossInd.Net
    |"2" -> NetGrossInd.Gross
    | x -> failwith (sprintf "ReadNetGrossInd unknown fix tag: %A"  x) 


let WriteNetGrossInd (dest:byte array) (nextFreeIdx:int) (xxIn:NetGrossInd) : int =
    match xxIn with
    | NetGrossInd.Net ->
        let tag = "430=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetGrossInd.Gross ->
        let tag = "430=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadListOrderStatus (fldValIn:string) : ListOrderStatus = 
    match fldValIn with
    |"1" -> ListOrderStatus.Inbiddingprocess
    |"2" -> ListOrderStatus.Receivedforexecution
    |"3" -> ListOrderStatus.Executing
    |"4" -> ListOrderStatus.Canceling
    |"5" -> ListOrderStatus.Alert
    |"6" -> ListOrderStatus.AllDone
    |"7" -> ListOrderStatus.Reject
    | x -> failwith (sprintf "ReadListOrderStatus unknown fix tag: %A"  x) 


let WriteListOrderStatus (dest:byte array) (nextFreeIdx:int) (xxIn:ListOrderStatus) : int =
    match xxIn with
    | ListOrderStatus.Inbiddingprocess ->
        let tag = "431=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Receivedforexecution ->
        let tag = "431=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Executing ->
        let tag = "431=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Canceling ->
        let tag = "431=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Alert ->
        let tag = "431=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.AllDone ->
        let tag = "431=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListOrderStatus.Reject ->
        let tag = "431=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExpireDate valIn =
    let tmp =  valIn
    ExpireDate.ExpireDate tmp


let WriteExpireDate (dest:byte []) (nextFreeIdx:int) (valIn:ExpireDate) : int = 
   let tag = "432="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListExecInstType (fldValIn:string) : ListExecInstType = 
    match fldValIn with
    |"1" -> ListExecInstType.Immediate
    |"2" -> ListExecInstType.WaitForExecuteInstruction
    |"3" -> ListExecInstType.ExchangeSwitchCivOrderSellDriven
    |"4" -> ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashTopUp
    |"5" -> ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashWithdraw
    | x -> failwith (sprintf "ReadListExecInstType unknown fix tag: %A"  x) 


let WriteListExecInstType (dest:byte array) (nextFreeIdx:int) (xxIn:ListExecInstType) : int =
    match xxIn with
    | ListExecInstType.Immediate ->
        let tag = "433=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.WaitForExecuteInstruction ->
        let tag = "433=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderSellDriven ->
        let tag = "433=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashTopUp ->
        let tag = "433=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ListExecInstType.ExchangeSwitchCivOrderBuyDrivenCashWithdraw ->
        let tag = "433=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCxlRejResponseTo (fldValIn:string) : CxlRejResponseTo = 
    match fldValIn with
    |"1" -> CxlRejResponseTo.OrderCancelRequest
    |"2" -> CxlRejResponseTo.OrderCancelReplaceRequest
    | x -> failwith (sprintf "ReadCxlRejResponseTo unknown fix tag: %A"  x) 


let WriteCxlRejResponseTo (dest:byte array) (nextFreeIdx:int) (xxIn:CxlRejResponseTo) : int =
    match xxIn with
    | CxlRejResponseTo.OrderCancelRequest ->
        let tag = "434=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CxlRejResponseTo.OrderCancelReplaceRequest ->
        let tag = "434=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingCouponRate valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingCouponRate.UnderlyingCouponRate tmp


let WriteUnderlyingCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCouponRate) : int = 
   let tag = "435="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingContractMultiplier valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingContractMultiplier.UnderlyingContractMultiplier tmp


let WriteUnderlyingContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingContractMultiplier) : int = 
   let tag = "436="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContraTradeQty valIn =
    let tmp = System.Decimal.Parse valIn
    ContraTradeQty.ContraTradeQty tmp


let WriteContraTradeQty (dest:byte []) (nextFreeIdx:int) (valIn:ContraTradeQty) : int = 
   let tag = "437="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContraTradeTime valIn =
    let tmp =  valIn
    ContraTradeTime.ContraTradeTime tmp


let WriteContraTradeTime (dest:byte []) (nextFreeIdx:int) (valIn:ContraTradeTime) : int = 
   let tag = "438="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLiquidityNumSecurities valIn =
    let tmp = System.Int32.Parse valIn
    LiquidityNumSecurities.LiquidityNumSecurities tmp


let WriteLiquidityNumSecurities (dest:byte []) (nextFreeIdx:int) (valIn:LiquidityNumSecurities) : int = 
   let tag = "441="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMultiLegReportingType (fldValIn:string) : MultiLegReportingType = 
    match fldValIn with
    |"1" -> MultiLegReportingType.SingleSecurity
    |"2" -> MultiLegReportingType.IndividualLegOfAMultiLegSecurity
    |"3" -> MultiLegReportingType.MultiLegSecurity
    | x -> failwith (sprintf "ReadMultiLegReportingType unknown fix tag: %A"  x) 


let WriteMultiLegReportingType (dest:byte array) (nextFreeIdx:int) (xxIn:MultiLegReportingType) : int =
    match xxIn with
    | MultiLegReportingType.SingleSecurity ->
        let tag = "442=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegReportingType.IndividualLegOfAMultiLegSecurity ->
        let tag = "442=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegReportingType.MultiLegSecurity ->
        let tag = "442=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikeTime valIn =
    let tmp =  valIn
    StrikeTime.StrikeTime tmp


let WriteStrikeTime (dest:byte []) (nextFreeIdx:int) (valIn:StrikeTime) : int = 
   let tag = "443="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadListStatusText valIn =
    let tmp =  valIn
    ListStatusText.ListStatusText tmp


let WriteListStatusText (dest:byte []) (nextFreeIdx:int) (valIn:ListStatusText) : int = 
   let tag = "444="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedListStatusText (dest:byte []) (nextFreeIdx:int) (fld:EncodedListStatusText) : int =
    // write the string length part of the compound msg
    let lenTag = "445="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedListStatusText valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "446" then failwith "invalid tag reading EncodedListStatusText"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedListStatusText"
    EncodedListStatusText.EncodedListStatusText raw


let ReadPartyIDSource (fldValIn:string) : PartyIDSource = 
    match fldValIn with
    |"B" -> PartyIDSource.Bic
    |"C" -> PartyIDSource.GenerallyAcceptedMarketParticipantIdentifier
    |"D" -> PartyIDSource.ProprietaryCustomCode
    |"E" -> PartyIDSource.IsoCountryCode
    |"F" -> PartyIDSource.SettlementEntityLocation
    |"G" -> PartyIDSource.Mic
    |"H" -> PartyIDSource.CsdParticipantMemberCode
    |"1" -> PartyIDSource.KoreanInvestorId
    |"2" -> PartyIDSource.TaiwaneseQualifiedForeignInvestorIdQfiiFid
    |"3" -> PartyIDSource.TaiwaneseTradingAccount
    |"4" -> PartyIDSource.MalaysianCentralDepositoryNumber
    |"5" -> PartyIDSource.ChineseBShare
    |"6" -> PartyIDSource.UkNationalInsuranceOrPensionNumber
    |"7" -> PartyIDSource.UsSocialSecurityNumber
    |"8" -> PartyIDSource.UsEmployerIdentificationNumber
    |"9" -> PartyIDSource.AustralianBusinessNumber
    |"A" -> PartyIDSource.AustralianTaxFileNumber
    |"I" -> PartyIDSource.DirectedBroker
    | x -> failwith (sprintf "ReadPartyIDSource unknown fix tag: %A"  x) 


let WritePartyIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:PartyIDSource) : int =
    match xxIn with
    | PartyIDSource.Bic ->
        let tag = "447=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.GenerallyAcceptedMarketParticipantIdentifier ->
        let tag = "447=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.ProprietaryCustomCode ->
        let tag = "447=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.IsoCountryCode ->
        let tag = "447=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.SettlementEntityLocation ->
        let tag = "447=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.Mic ->
        let tag = "447=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.CsdParticipantMemberCode ->
        let tag = "447=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.KoreanInvestorId ->
        let tag = "447=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.TaiwaneseQualifiedForeignInvestorIdQfiiFid ->
        let tag = "447=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.TaiwaneseTradingAccount ->
        let tag = "447=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.MalaysianCentralDepositoryNumber ->
        let tag = "447=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.ChineseBShare ->
        let tag = "447=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UkNationalInsuranceOrPensionNumber ->
        let tag = "447=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UsSocialSecurityNumber ->
        let tag = "447=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.UsEmployerIdentificationNumber ->
        let tag = "447=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.AustralianBusinessNumber ->
        let tag = "447=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.AustralianTaxFileNumber ->
        let tag = "447=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyIDSource.DirectedBroker ->
        let tag = "447=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPartyID valIn =
    let tmp =  valIn
    PartyID.PartyID tmp


let WritePartyID (dest:byte []) (nextFreeIdx:int) (valIn:PartyID) : int = 
   let tag = "448="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetChgPrevDay valIn =
    let tmp = System.Decimal.Parse valIn
    NetChgPrevDay.NetChgPrevDay tmp


let WriteNetChgPrevDay (dest:byte []) (nextFreeIdx:int) (valIn:NetChgPrevDay) : int = 
   let tag = "451="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPartyRole (fldValIn:string) : PartyRole = 
    match fldValIn with
    |"1" -> PartyRole.ExecutingFirm
    |"2" -> PartyRole.BrokerOfCredit
    |"3" -> PartyRole.ClientId
    |"4" -> PartyRole.ClearingFirm
    |"5" -> PartyRole.InvestorId
    |"6" -> PartyRole.IntroducingFirm
    |"7" -> PartyRole.EnteringFirm
    |"8" -> PartyRole.LocateLendingFirm
    |"9" -> PartyRole.FundManagerClientId
    |"10" -> PartyRole.SettlementLocation
    |"11" -> PartyRole.OrderOriginationTrader
    |"12" -> PartyRole.ExecutingTrader
    |"13" -> PartyRole.OrderOriginationFirm
    |"14" -> PartyRole.GiveupClearingFirm
    |"15" -> PartyRole.CorrespondantClearingFirm
    |"16" -> PartyRole.ExecutingSystem
    |"17" -> PartyRole.ContraFirm
    |"18" -> PartyRole.ContraClearingFirm
    |"19" -> PartyRole.SponsoringFirm
    |"20" -> PartyRole.UnderlyingContraFirm
    |"21" -> PartyRole.ClearingOrganization
    |"22" -> PartyRole.Exchange
    |"24" -> PartyRole.CustomerAccount
    |"25" -> PartyRole.CorrespondentClearingOrganization
    |"26" -> PartyRole.CorrespondentBroker
    |"27" -> PartyRole.BuyerSeller
    |"28" -> PartyRole.Custodian
    |"29" -> PartyRole.Intermediary
    |"30" -> PartyRole.Agent
    |"31" -> PartyRole.SubCustodian
    |"32" -> PartyRole.Beneficiary
    |"33" -> PartyRole.InterestedParty
    |"34" -> PartyRole.RegulatoryBody
    |"35" -> PartyRole.LiquidityProvider
    |"36" -> PartyRole.EnteringTrader
    |"37" -> PartyRole.ContraTrader
    |"38" -> PartyRole.PositionAccount
    | x -> failwith (sprintf "ReadPartyRole unknown fix tag: %A"  x) 


let WritePartyRole (dest:byte array) (nextFreeIdx:int) (xxIn:PartyRole) : int =
    match xxIn with
    | PartyRole.ExecutingFirm ->
        let tag = "452=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.BrokerOfCredit ->
        let tag = "452=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClientId ->
        let tag = "452=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClearingFirm ->
        let tag = "452=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.InvestorId ->
        let tag = "452=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.IntroducingFirm ->
        let tag = "452=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.EnteringFirm ->
        let tag = "452=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.LocateLendingFirm ->
        let tag = "452=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.FundManagerClientId ->
        let tag = "452=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SettlementLocation ->
        let tag = "452=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.OrderOriginationTrader ->
        let tag = "452=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ExecutingTrader ->
        let tag = "452=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.OrderOriginationFirm ->
        let tag = "452=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.GiveupClearingFirm ->
        let tag = "452=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondantClearingFirm ->
        let tag = "452=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ExecutingSystem ->
        let tag = "452=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraFirm ->
        let tag = "452=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraClearingFirm ->
        let tag = "452=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SponsoringFirm ->
        let tag = "452=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.UnderlyingContraFirm ->
        let tag = "452=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ClearingOrganization ->
        let tag = "452=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Exchange ->
        let tag = "452=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CustomerAccount ->
        let tag = "452=24"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondentClearingOrganization ->
        let tag = "452=25"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.CorrespondentBroker ->
        let tag = "452=26"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.BuyerSeller ->
        let tag = "452=27"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Custodian ->
        let tag = "452=28"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Intermediary ->
        let tag = "452=29"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Agent ->
        let tag = "452=30"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.SubCustodian ->
        let tag = "452=31"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.Beneficiary ->
        let tag = "452=32"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.InterestedParty ->
        let tag = "452=33"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.RegulatoryBody ->
        let tag = "452=34"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.LiquidityProvider ->
        let tag = "452=35"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.EnteringTrader ->
        let tag = "452=36"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.ContraTrader ->
        let tag = "452=37"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PartyRole.PositionAccount ->
        let tag = "452=38"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoPartyIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoPartyIDs.NoPartyIDs tmp


let WriteNoPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoPartyIDs) : int = 
   let tag = "453="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoSecurityAltID valIn =
    let tmp = System.Int32.Parse valIn
    NoSecurityAltID.NoSecurityAltID tmp


let WriteNoSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoSecurityAltID) : int = 
   let tag = "454="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityAltID valIn =
    let tmp =  valIn
    SecurityAltID.SecurityAltID tmp


let WriteSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:SecurityAltID) : int = 
   let tag = "455="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityAltIDSource valIn =
    let tmp =  valIn
    SecurityAltIDSource.SecurityAltIDSource tmp


let WriteSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:SecurityAltIDSource) : int = 
   let tag = "456="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoUnderlyingSecurityAltID valIn =
    let tmp = System.Int32.Parse valIn
    NoUnderlyingSecurityAltID.NoUnderlyingSecurityAltID tmp


let WriteNoUnderlyingSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyingSecurityAltID) : int = 
   let tag = "457="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityAltID valIn =
    let tmp =  valIn
    UnderlyingSecurityAltID.UnderlyingSecurityAltID tmp


let WriteUnderlyingSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityAltID) : int = 
   let tag = "458="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecurityAltIDSource valIn =
    let tmp =  valIn
    UnderlyingSecurityAltIDSource.UnderlyingSecurityAltIDSource tmp


let WriteUnderlyingSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecurityAltIDSource) : int = 
   let tag = "459="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadProduct (fldValIn:string) : Product = 
    match fldValIn with
    |"1" -> Product.Agency
    |"2" -> Product.Commodity
    |"3" -> Product.Corporate
    |"4" -> Product.Currency
    |"5" -> Product.Equity
    |"6" -> Product.Government
    |"7" -> Product.Index
    |"8" -> Product.Loan
    |"9" -> Product.Moneymarket
    |"10" -> Product.Mortgage
    |"11" -> Product.Municipal
    |"12" -> Product.Other
    |"13" -> Product.Financing
    | x -> failwith (sprintf "ReadProduct unknown fix tag: %A"  x) 


let WriteProduct (dest:byte array) (nextFreeIdx:int) (xxIn:Product) : int =
    match xxIn with
    | Product.Agency ->
        let tag = "460=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Commodity ->
        let tag = "460=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Corporate ->
        let tag = "460=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Currency ->
        let tag = "460=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Equity ->
        let tag = "460=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Government ->
        let tag = "460=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Index ->
        let tag = "460=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Loan ->
        let tag = "460=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Moneymarket ->
        let tag = "460=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Mortgage ->
        let tag = "460=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Municipal ->
        let tag = "460=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Other ->
        let tag = "460=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Product.Financing ->
        let tag = "460=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCFICode valIn =
    let tmp =  valIn
    CFICode.CFICode tmp


let WriteCFICode (dest:byte []) (nextFreeIdx:int) (valIn:CFICode) : int = 
   let tag = "461="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingProduct valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingProduct.UnderlyingProduct tmp


let WriteUnderlyingProduct (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingProduct) : int = 
   let tag = "462="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCFICode valIn =
    let tmp =  valIn
    UnderlyingCFICode.UnderlyingCFICode tmp


let WriteUnderlyingCFICode (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCFICode) : int = 
   let tag = "463="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTestMessageIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    TestMessageIndicator.TestMessageIndicator tmp


let WriteTestMessageIndicator (dest:byte []) (nextFreeIdx:int) (valIn:TestMessageIndicator) : int = 
   let tag = "464="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuantityType (fldValIn:string) : QuantityType = 
    match fldValIn with
    |"1" -> QuantityType.Shares
    |"2" -> QuantityType.Bonds
    |"3" -> QuantityType.Currentface
    |"4" -> QuantityType.Originalface
    |"5" -> QuantityType.Currency
    |"6" -> QuantityType.Contracts
    |"7" -> QuantityType.Other
    |"8" -> QuantityType.Par
    | x -> failwith (sprintf "ReadQuantityType unknown fix tag: %A"  x) 


let WriteQuantityType (dest:byte array) (nextFreeIdx:int) (xxIn:QuantityType) : int =
    match xxIn with
    | QuantityType.Shares ->
        let tag = "465=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Bonds ->
        let tag = "465=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Currentface ->
        let tag = "465=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Originalface ->
        let tag = "465=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Currency ->
        let tag = "465=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Contracts ->
        let tag = "465=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Other ->
        let tag = "465=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuantityType.Par ->
        let tag = "465=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingRefID valIn =
    let tmp =  valIn
    BookingRefID.BookingRefID tmp


let WriteBookingRefID (dest:byte []) (nextFreeIdx:int) (valIn:BookingRefID) : int = 
   let tag = "466="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadIndividualAllocID valIn =
    let tmp =  valIn
    IndividualAllocID.IndividualAllocID tmp


let WriteIndividualAllocID (dest:byte []) (nextFreeIdx:int) (valIn:IndividualAllocID) : int = 
   let tag = "467="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRoundingDirection (fldValIn:string) : RoundingDirection = 
    match fldValIn with
    |"0" -> RoundingDirection.RoundToNearest
    |"1" -> RoundingDirection.RoundDown
    |"2" -> RoundingDirection.RoundUp
    | x -> failwith (sprintf "ReadRoundingDirection unknown fix tag: %A"  x) 


let WriteRoundingDirection (dest:byte array) (nextFreeIdx:int) (xxIn:RoundingDirection) : int =
    match xxIn with
    | RoundingDirection.RoundToNearest ->
        let tag = "468=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoundingDirection.RoundDown ->
        let tag = "468=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RoundingDirection.RoundUp ->
        let tag = "468=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoundingModulus valIn =
    let tmp = System.Decimal.Parse valIn
    RoundingModulus.RoundingModulus tmp


let WriteRoundingModulus (dest:byte []) (nextFreeIdx:int) (valIn:RoundingModulus) : int = 
   let tag = "469="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCountryOfIssue valIn =
    let tmp =  valIn
    CountryOfIssue.CountryOfIssue tmp


let WriteCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:CountryOfIssue) : int = 
   let tag = "470="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStateOrProvinceOfIssue valIn =
    let tmp =  valIn
    StateOrProvinceOfIssue.StateOrProvinceOfIssue tmp


let WriteStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:StateOrProvinceOfIssue) : int = 
   let tag = "471="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLocaleOfIssue valIn =
    let tmp =  valIn
    LocaleOfIssue.LocaleOfIssue tmp


let WriteLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LocaleOfIssue) : int = 
   let tag = "472="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoRegistDtls valIn =
    let tmp = System.Int32.Parse valIn
    NoRegistDtls.NoRegistDtls tmp


let WriteNoRegistDtls (dest:byte []) (nextFreeIdx:int) (valIn:NoRegistDtls) : int = 
   let tag = "473="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMailingDtls valIn =
    let tmp =  valIn
    MailingDtls.MailingDtls tmp


let WriteMailingDtls (dest:byte []) (nextFreeIdx:int) (valIn:MailingDtls) : int = 
   let tag = "474="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadInvestorCountryOfResidence valIn =
    let tmp =  valIn
    InvestorCountryOfResidence.InvestorCountryOfResidence tmp


let WriteInvestorCountryOfResidence (dest:byte []) (nextFreeIdx:int) (valIn:InvestorCountryOfResidence) : int = 
   let tag = "475="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPaymentRef valIn =
    let tmp =  valIn
    PaymentRef.PaymentRef tmp


let WritePaymentRef (dest:byte []) (nextFreeIdx:int) (valIn:PaymentRef) : int = 
   let tag = "476="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDistribPaymentMethod (fldValIn:string) : DistribPaymentMethod = 
    match fldValIn with
    |"1" -> DistribPaymentMethod.Crest
    |"2" -> DistribPaymentMethod.Nscc
    |"3" -> DistribPaymentMethod.Euroclear
    |"4" -> DistribPaymentMethod.Clearstream
    |"5" -> DistribPaymentMethod.Cheque
    |"6" -> DistribPaymentMethod.TelegraphicTransfer
    |"7" -> DistribPaymentMethod.Fedwire
    |"8" -> DistribPaymentMethod.DirectCredit
    |"9" -> DistribPaymentMethod.AchCredit
    |"10" -> DistribPaymentMethod.Bpay
    |"11" -> DistribPaymentMethod.HighValueClearingSystem
    |"12" -> DistribPaymentMethod.ReinvestInFund
    | x -> failwith (sprintf "ReadDistribPaymentMethod unknown fix tag: %A"  x) 


let WriteDistribPaymentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:DistribPaymentMethod) : int =
    match xxIn with
    | DistribPaymentMethod.Crest ->
        let tag = "477=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Nscc ->
        let tag = "477=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Euroclear ->
        let tag = "477=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Clearstream ->
        let tag = "477=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Cheque ->
        let tag = "477=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.TelegraphicTransfer ->
        let tag = "477=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Fedwire ->
        let tag = "477=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.DirectCredit ->
        let tag = "477=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.AchCredit ->
        let tag = "477=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.Bpay ->
        let tag = "477=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.HighValueClearingSystem ->
        let tag = "477=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DistribPaymentMethod.ReinvestInFund ->
        let tag = "477=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCashDistribCurr valIn =
    let tmp =  valIn
    CashDistribCurr.CashDistribCurr tmp


let WriteCashDistribCurr (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribCurr) : int = 
   let tag = "478="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCommCurrency valIn =
    let tmp =  valIn
    CommCurrency.CommCurrency tmp


let WriteCommCurrency (dest:byte []) (nextFreeIdx:int) (valIn:CommCurrency) : int = 
   let tag = "479="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCancellationRights (fldValIn:string) : CancellationRights = 
    match fldValIn with
    |"Y" -> CancellationRights.Yes
    |"N" -> CancellationRights.NoExecutionOnly
    |"M" -> CancellationRights.NoWaiverAgreement
    |"O" -> CancellationRights.NoInstitutional
    | x -> failwith (sprintf "ReadCancellationRights unknown fix tag: %A"  x) 


let WriteCancellationRights (dest:byte array) (nextFreeIdx:int) (xxIn:CancellationRights) : int =
    match xxIn with
    | CancellationRights.Yes ->
        let tag = "480=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoExecutionOnly ->
        let tag = "480=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoWaiverAgreement ->
        let tag = "480=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CancellationRights.NoInstitutional ->
        let tag = "480=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMoneyLaunderingStatus (fldValIn:string) : MoneyLaunderingStatus = 
    match fldValIn with
    |"Y" -> MoneyLaunderingStatus.Passed
    |"N" -> MoneyLaunderingStatus.NotChecked
    |"1" -> MoneyLaunderingStatus.ExemptBelowTheLimit
    |"2" -> MoneyLaunderingStatus.ExemptClientMoneyTypeExemption
    |"3" -> MoneyLaunderingStatus.ExemptAuthorisedCreditOrFinancialInstitution
    | x -> failwith (sprintf "ReadMoneyLaunderingStatus unknown fix tag: %A"  x) 


let WriteMoneyLaunderingStatus (dest:byte array) (nextFreeIdx:int) (xxIn:MoneyLaunderingStatus) : int =
    match xxIn with
    | MoneyLaunderingStatus.Passed ->
        let tag = "481=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.NotChecked ->
        let tag = "481=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptBelowTheLimit ->
        let tag = "481=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptClientMoneyTypeExemption ->
        let tag = "481=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MoneyLaunderingStatus.ExemptAuthorisedCreditOrFinancialInstitution ->
        let tag = "481=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMailingInst valIn =
    let tmp =  valIn
    MailingInst.MailingInst tmp


let WriteMailingInst (dest:byte []) (nextFreeIdx:int) (valIn:MailingInst) : int = 
   let tag = "482="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTransBkdTime valIn =
    let tmp =  valIn
    TransBkdTime.TransBkdTime tmp


let WriteTransBkdTime (dest:byte []) (nextFreeIdx:int) (valIn:TransBkdTime) : int = 
   let tag = "483="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExecPriceType (fldValIn:string) : ExecPriceType = 
    match fldValIn with
    |"B" -> ExecPriceType.BidPrice
    |"C" -> ExecPriceType.CreationPrice
    |"D" -> ExecPriceType.CreationPricePlusAdjustmentPercent
    |"E" -> ExecPriceType.CreationPricePlusAdjustmentAmount
    |"O" -> ExecPriceType.OfferPrice
    |"P" -> ExecPriceType.OfferPriceMinusAdjustmentPercent
    |"Q" -> ExecPriceType.OfferPriceMinusAdjustmentAmount
    |"S" -> ExecPriceType.SinglePrice
    | x -> failwith (sprintf "ReadExecPriceType unknown fix tag: %A"  x) 


let WriteExecPriceType (dest:byte array) (nextFreeIdx:int) (xxIn:ExecPriceType) : int =
    match xxIn with
    | ExecPriceType.BidPrice ->
        let tag = "484=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPrice ->
        let tag = "484=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPricePlusAdjustmentPercent ->
        let tag = "484=D"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.CreationPricePlusAdjustmentAmount ->
        let tag = "484=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPrice ->
        let tag = "484=O"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPriceMinusAdjustmentPercent ->
        let tag = "484=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.OfferPriceMinusAdjustmentAmount ->
        let tag = "484=Q"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExecPriceType.SinglePrice ->
        let tag = "484=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecPriceAdjustment valIn =
    let tmp = System.Decimal.Parse valIn
    ExecPriceAdjustment.ExecPriceAdjustment tmp


let WriteExecPriceAdjustment (dest:byte []) (nextFreeIdx:int) (valIn:ExecPriceAdjustment) : int = 
   let tag = "485="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDateOfBirth valIn =
    let tmp =  valIn
    DateOfBirth.DateOfBirth tmp


let WriteDateOfBirth (dest:byte []) (nextFreeIdx:int) (valIn:DateOfBirth) : int = 
   let tag = "486="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeReportTransType (fldValIn:string) : TradeReportTransType = 
    match fldValIn with
    |"0" -> TradeReportTransType.New
    |"1" -> TradeReportTransType.Cancel
    |"2" -> TradeReportTransType.Replace
    |"3" -> TradeReportTransType.Release
    |"4" -> TradeReportTransType.Reverse
    | x -> failwith (sprintf "ReadTradeReportTransType unknown fix tag: %A"  x) 


let WriteTradeReportTransType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportTransType) : int =
    match xxIn with
    | TradeReportTransType.New ->
        let tag = "487=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Cancel ->
        let tag = "487=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Replace ->
        let tag = "487=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Release ->
        let tag = "487=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportTransType.Reverse ->
        let tag = "487=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCardHolderName valIn =
    let tmp =  valIn
    CardHolderName.CardHolderName tmp


let WriteCardHolderName (dest:byte []) (nextFreeIdx:int) (valIn:CardHolderName) : int = 
   let tag = "488="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCardNumber valIn =
    let tmp =  valIn
    CardNumber.CardNumber tmp


let WriteCardNumber (dest:byte []) (nextFreeIdx:int) (valIn:CardNumber) : int = 
   let tag = "489="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCardExpDate valIn =
    let tmp =  valIn
    CardExpDate.CardExpDate tmp


let WriteCardExpDate (dest:byte []) (nextFreeIdx:int) (valIn:CardExpDate) : int = 
   let tag = "490="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCardIssNum valIn =
    let tmp =  valIn
    CardIssNum.CardIssNum tmp


let WriteCardIssNum (dest:byte []) (nextFreeIdx:int) (valIn:CardIssNum) : int = 
   let tag = "491="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPaymentMethod (fldValIn:string) : PaymentMethod = 
    match fldValIn with
    |"1" -> PaymentMethod.Crest
    |"2" -> PaymentMethod.Nscc
    |"3" -> PaymentMethod.Euroclear
    |"4" -> PaymentMethod.Clearstream
    |"5" -> PaymentMethod.Cheque
    |"6" -> PaymentMethod.TelegraphicTransfer
    |"7" -> PaymentMethod.Fedwire
    |"8" -> PaymentMethod.DebitCard
    |"9" -> PaymentMethod.DirectDebit
    |"10" -> PaymentMethod.DirectCredit
    |"11" -> PaymentMethod.CreditCard
    |"12" -> PaymentMethod.AchDebit
    |"13" -> PaymentMethod.AchCredit
    |"14" -> PaymentMethod.Bpay
    |"15" -> PaymentMethod.HighValueClearingSystem
    | x -> failwith (sprintf "ReadPaymentMethod unknown fix tag: %A"  x) 


let WritePaymentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:PaymentMethod) : int =
    match xxIn with
    | PaymentMethod.Crest ->
        let tag = "492=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Nscc ->
        let tag = "492=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Euroclear ->
        let tag = "492=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Clearstream ->
        let tag = "492=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Cheque ->
        let tag = "492=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.TelegraphicTransfer ->
        let tag = "492=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Fedwire ->
        let tag = "492=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DebitCard ->
        let tag = "492=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DirectDebit ->
        let tag = "492=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.DirectCredit ->
        let tag = "492=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.CreditCard ->
        let tag = "492=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.AchDebit ->
        let tag = "492=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.AchCredit ->
        let tag = "492=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.Bpay ->
        let tag = "492=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PaymentMethod.HighValueClearingSystem ->
        let tag = "492=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistAcctType valIn =
    let tmp =  valIn
    RegistAcctType.RegistAcctType tmp


let WriteRegistAcctType (dest:byte []) (nextFreeIdx:int) (valIn:RegistAcctType) : int = 
   let tag = "493="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDesignation valIn =
    let tmp =  valIn
    Designation.Designation tmp


let WriteDesignation (dest:byte []) (nextFreeIdx:int) (valIn:Designation) : int = 
   let tag = "494="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTaxAdvantageType (fldValIn:string) : TaxAdvantageType = 
    match fldValIn with
    |"0" -> TaxAdvantageType.NNone
    |"1" -> TaxAdvantageType.MaxiIsa
    |"2" -> TaxAdvantageType.Tessa
    |"3" -> TaxAdvantageType.MiniCashIsa
    |"4" -> TaxAdvantageType.MiniStocksAndSharesIsa
    |"5" -> TaxAdvantageType.MiniInsuranceIsa
    |"6" -> TaxAdvantageType.CurrentYearPayment
    |"7" -> TaxAdvantageType.PriorYearPayment
    |"8" -> TaxAdvantageType.AssetTransfer
    |"9" -> TaxAdvantageType.EmployeePriorYear
    |"999" -> TaxAdvantageType.Other
    | x -> failwith (sprintf "ReadTaxAdvantageType unknown fix tag: %A"  x) 


let WriteTaxAdvantageType (dest:byte array) (nextFreeIdx:int) (xxIn:TaxAdvantageType) : int =
    match xxIn with
    | TaxAdvantageType.NNone ->
        let tag = "495=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MaxiIsa ->
        let tag = "495=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.Tessa ->
        let tag = "495=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniCashIsa ->
        let tag = "495=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniStocksAndSharesIsa ->
        let tag = "495=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.MiniInsuranceIsa ->
        let tag = "495=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.CurrentYearPayment ->
        let tag = "495=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.PriorYearPayment ->
        let tag = "495=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.AssetTransfer ->
        let tag = "495=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.EmployeePriorYear ->
        let tag = "495=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TaxAdvantageType.Other ->
        let tag = "495=999"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRejReasonText valIn =
    let tmp =  valIn
    RegistRejReasonText.RegistRejReasonText tmp


let WriteRegistRejReasonText (dest:byte []) (nextFreeIdx:int) (valIn:RegistRejReasonText) : int = 
   let tag = "496="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadFundRenewWaiv (fldValIn:string) : FundRenewWaiv = 
    match fldValIn with
    |"Y" -> FundRenewWaiv.Yes
    |"N" -> FundRenewWaiv.No
    | x -> failwith (sprintf "ReadFundRenewWaiv unknown fix tag: %A"  x) 


let WriteFundRenewWaiv (dest:byte array) (nextFreeIdx:int) (xxIn:FundRenewWaiv) : int =
    match xxIn with
    | FundRenewWaiv.Yes ->
        let tag = "497=Y"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | FundRenewWaiv.No ->
        let tag = "497=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCashDistribAgentName valIn =
    let tmp =  valIn
    CashDistribAgentName.CashDistribAgentName tmp


let WriteCashDistribAgentName (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentName) : int = 
   let tag = "498="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashDistribAgentCode valIn =
    let tmp =  valIn
    CashDistribAgentCode.CashDistribAgentCode tmp


let WriteCashDistribAgentCode (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentCode) : int = 
   let tag = "499="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashDistribAgentAcctNumber valIn =
    let tmp =  valIn
    CashDistribAgentAcctNumber.CashDistribAgentAcctNumber tmp


let WriteCashDistribAgentAcctNumber (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentAcctNumber) : int = 
   let tag = "500="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashDistribPayRef valIn =
    let tmp =  valIn
    CashDistribPayRef.CashDistribPayRef tmp


let WriteCashDistribPayRef (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribPayRef) : int = 
   let tag = "501="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashDistribAgentAcctName valIn =
    let tmp =  valIn
    CashDistribAgentAcctName.CashDistribAgentAcctName tmp


let WriteCashDistribAgentAcctName (dest:byte []) (nextFreeIdx:int) (valIn:CashDistribAgentAcctName) : int = 
   let tag = "502="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCardStartDate valIn =
    let tmp =  valIn
    CardStartDate.CardStartDate tmp


let WriteCardStartDate (dest:byte []) (nextFreeIdx:int) (valIn:CardStartDate) : int = 
   let tag = "503="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPaymentDate valIn =
    let tmp =  valIn
    PaymentDate.PaymentDate tmp


let WritePaymentDate (dest:byte []) (nextFreeIdx:int) (valIn:PaymentDate) : int = 
   let tag = "504="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPaymentRemitterID valIn =
    let tmp =  valIn
    PaymentRemitterID.PaymentRemitterID tmp


let WritePaymentRemitterID (dest:byte []) (nextFreeIdx:int) (valIn:PaymentRemitterID) : int = 
   let tag = "505="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRegistStatus (fldValIn:string) : RegistStatus = 
    match fldValIn with
    |"A" -> RegistStatus.Accepted
    |"R" -> RegistStatus.Rejected
    |"H" -> RegistStatus.Held
    |"N" -> RegistStatus.Reminder
    | x -> failwith (sprintf "ReadRegistStatus unknown fix tag: %A"  x) 


let WriteRegistStatus (dest:byte array) (nextFreeIdx:int) (xxIn:RegistStatus) : int =
    match xxIn with
    | RegistStatus.Accepted ->
        let tag = "506=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Rejected ->
        let tag = "506=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Held ->
        let tag = "506=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistStatus.Reminder ->
        let tag = "506=N"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRejReasonCode (fldValIn:string) : RegistRejReasonCode = 
    match fldValIn with
    |"1" -> RegistRejReasonCode.InvalidUnacceptableAccountType
    |"2" -> RegistRejReasonCode.InvalidUnacceptableTaxExemptType
    |"3" -> RegistRejReasonCode.InvalidUnacceptableOwnershipType
    |"4" -> RegistRejReasonCode.InvalidUnacceptableNoRegDetls
    |"5" -> RegistRejReasonCode.InvalidUnacceptableRegSeqNo
    |"6" -> RegistRejReasonCode.InvalidUnacceptableRegDtls
    |"7" -> RegistRejReasonCode.InvalidUnacceptableMailingDtls
    |"8" -> RegistRejReasonCode.InvalidUnacceptableMailingInst
    |"9" -> RegistRejReasonCode.InvalidUnacceptableInvestorId
    |"10" -> RegistRejReasonCode.InvalidUnacceptableInvestorIdSource
    |"11" -> RegistRejReasonCode.InvalidUnacceptableDateOfBirth
    |"12" -> RegistRejReasonCode.InvalidUnacceptableInvestorCountryOfResidence
    |"13" -> RegistRejReasonCode.InvalidUnacceptableNodistribinstns
    |"14" -> RegistRejReasonCode.InvalidUnacceptableDistribPercentage
    |"15" -> RegistRejReasonCode.InvalidUnacceptableDistribPaymentMethod
    |"16" -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctName
    |"17" -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentCode
    |"18" -> RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctNum
    |"99" -> RegistRejReasonCode.Other
    | x -> failwith (sprintf "ReadRegistRejReasonCode unknown fix tag: %A"  x) 


let WriteRegistRejReasonCode (dest:byte array) (nextFreeIdx:int) (xxIn:RegistRejReasonCode) : int =
    match xxIn with
    | RegistRejReasonCode.InvalidUnacceptableAccountType ->
        let tag = "507=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableTaxExemptType ->
        let tag = "507=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableOwnershipType ->
        let tag = "507=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableNoRegDetls ->
        let tag = "507=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableRegSeqNo ->
        let tag = "507=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableRegDtls ->
        let tag = "507=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableMailingDtls ->
        let tag = "507=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableMailingInst ->
        let tag = "507=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorId ->
        let tag = "507=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorIdSource ->
        let tag = "507=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDateOfBirth ->
        let tag = "507=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableInvestorCountryOfResidence ->
        let tag = "507=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableNodistribinstns ->
        let tag = "507=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDistribPercentage ->
        let tag = "507=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableDistribPaymentMethod ->
        let tag = "507=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctName ->
        let tag = "507=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentCode ->
        let tag = "507=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.InvalidUnacceptableCashDistribAgentAcctNum ->
        let tag = "507=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistRejReasonCode.Other ->
        let tag = "507=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRegistRefID valIn =
    let tmp =  valIn
    RegistRefID.RegistRefID tmp


let WriteRegistRefID (dest:byte []) (nextFreeIdx:int) (valIn:RegistRefID) : int = 
   let tag = "508="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRegistDtls valIn =
    let tmp =  valIn
    RegistDtls.RegistDtls tmp


let WriteRegistDtls (dest:byte []) (nextFreeIdx:int) (valIn:RegistDtls) : int = 
   let tag = "509="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoDistribInsts valIn =
    let tmp = System.Int32.Parse valIn
    NoDistribInsts.NoDistribInsts tmp


let WriteNoDistribInsts (dest:byte []) (nextFreeIdx:int) (valIn:NoDistribInsts) : int = 
   let tag = "510="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRegistEmail valIn =
    let tmp =  valIn
    RegistEmail.RegistEmail tmp


let WriteRegistEmail (dest:byte []) (nextFreeIdx:int) (valIn:RegistEmail) : int = 
   let tag = "511="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDistribPercentage valIn =
    let tmp = System.Decimal.Parse valIn
    DistribPercentage.DistribPercentage tmp


let WriteDistribPercentage (dest:byte []) (nextFreeIdx:int) (valIn:DistribPercentage) : int = 
   let tag = "512="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRegistID valIn =
    let tmp =  valIn
    RegistID.RegistID tmp


let WriteRegistID (dest:byte []) (nextFreeIdx:int) (valIn:RegistID) : int = 
   let tag = "513="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRegistTransType (fldValIn:string) : RegistTransType = 
    match fldValIn with
    |"0" -> RegistTransType.New
    |"1" -> RegistTransType.Replace
    |"2" -> RegistTransType.Cancel
    | x -> failwith (sprintf "ReadRegistTransType unknown fix tag: %A"  x) 


let WriteRegistTransType (dest:byte array) (nextFreeIdx:int) (xxIn:RegistTransType) : int =
    match xxIn with
    | RegistTransType.New ->
        let tag = "514=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistTransType.Replace ->
        let tag = "514=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | RegistTransType.Cancel ->
        let tag = "514=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExecValuationPoint valIn =
    let tmp =  valIn
    ExecValuationPoint.ExecValuationPoint tmp


let WriteExecValuationPoint (dest:byte []) (nextFreeIdx:int) (valIn:ExecValuationPoint) : int = 
   let tag = "515="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderPercent valIn =
    let tmp = System.Decimal.Parse valIn
    OrderPercent.OrderPercent tmp


let WriteOrderPercent (dest:byte []) (nextFreeIdx:int) (valIn:OrderPercent) : int = 
   let tag = "516="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOwnershipType (fldValIn:string) : OwnershipType = 
    match fldValIn with
    |"J" -> OwnershipType.JointInvestors
    |"T" -> OwnershipType.TenantsInCommon
    |"2" -> OwnershipType.JointTrustees
    | x -> failwith (sprintf "ReadOwnershipType unknown fix tag: %A"  x) 


let WriteOwnershipType (dest:byte array) (nextFreeIdx:int) (xxIn:OwnershipType) : int =
    match xxIn with
    | OwnershipType.JointInvestors ->
        let tag = "517=J"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnershipType.TenantsInCommon ->
        let tag = "517=T"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnershipType.JointTrustees ->
        let tag = "517=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoContAmts valIn =
    let tmp = System.Int32.Parse valIn
    NoContAmts.NoContAmts tmp


let WriteNoContAmts (dest:byte []) (nextFreeIdx:int) (valIn:NoContAmts) : int = 
   let tag = "518="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContAmtType (fldValIn:string) : ContAmtType = 
    match fldValIn with
    |"1" -> ContAmtType.CommissionAmount
    |"2" -> ContAmtType.CommissionPercent
    |"3" -> ContAmtType.InitialChargeAmount
    |"4" -> ContAmtType.InitialChargePercent
    |"5" -> ContAmtType.DiscountAmount
    |"6" -> ContAmtType.DiscountPercent
    |"7" -> ContAmtType.DilutionLevyAmount
    |"8" -> ContAmtType.DilutionLevyPercent
    |"9" -> ContAmtType.ExitChargeAmount
    | x -> failwith (sprintf "ReadContAmtType unknown fix tag: %A"  x) 


let WriteContAmtType (dest:byte array) (nextFreeIdx:int) (xxIn:ContAmtType) : int =
    match xxIn with
    | ContAmtType.CommissionAmount ->
        let tag = "519=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.CommissionPercent ->
        let tag = "519=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.InitialChargeAmount ->
        let tag = "519=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.InitialChargePercent ->
        let tag = "519=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DiscountAmount ->
        let tag = "519=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DiscountPercent ->
        let tag = "519=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DilutionLevyAmount ->
        let tag = "519=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.DilutionLevyPercent ->
        let tag = "519=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ContAmtType.ExitChargeAmount ->
        let tag = "519=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContAmtValue valIn =
    let tmp = System.Decimal.Parse valIn
    ContAmtValue.ContAmtValue tmp


let WriteContAmtValue (dest:byte []) (nextFreeIdx:int) (valIn:ContAmtValue) : int = 
   let tag = "520="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContAmtCurr valIn =
    let tmp =  valIn
    ContAmtCurr.ContAmtCurr tmp


let WriteContAmtCurr (dest:byte []) (nextFreeIdx:int) (valIn:ContAmtCurr) : int = 
   let tag = "521="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOwnerType (fldValIn:string) : OwnerType = 
    match fldValIn with
    |"1" -> OwnerType.IndividualInvestor
    |"2" -> OwnerType.PublicCompany
    |"3" -> OwnerType.PrivateCompany
    |"4" -> OwnerType.IndividualTrustee
    |"5" -> OwnerType.CompanyTrustee
    |"6" -> OwnerType.PensionPlan
    |"7" -> OwnerType.CustodianUnderGiftsToMinorsAct
    |"8" -> OwnerType.Trusts
    |"9" -> OwnerType.Fiduciaries
    |"10" -> OwnerType.NetworkingSubAccount
    |"11" -> OwnerType.NonProfitOrganization
    |"12" -> OwnerType.CorporateBody
    |"13" -> OwnerType.Nominee
    | x -> failwith (sprintf "ReadOwnerType unknown fix tag: %A"  x) 


let WriteOwnerType (dest:byte array) (nextFreeIdx:int) (xxIn:OwnerType) : int =
    match xxIn with
    | OwnerType.IndividualInvestor ->
        let tag = "522=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PublicCompany ->
        let tag = "522=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PrivateCompany ->
        let tag = "522=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.IndividualTrustee ->
        let tag = "522=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CompanyTrustee ->
        let tag = "522=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.PensionPlan ->
        let tag = "522=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CustodianUnderGiftsToMinorsAct ->
        let tag = "522=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Trusts ->
        let tag = "522=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Fiduciaries ->
        let tag = "522=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.NetworkingSubAccount ->
        let tag = "522=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.NonProfitOrganization ->
        let tag = "522=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.CorporateBody ->
        let tag = "522=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OwnerType.Nominee ->
        let tag = "522=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPartySubID valIn =
    let tmp =  valIn
    PartySubID.PartySubID tmp


let WritePartySubID (dest:byte []) (nextFreeIdx:int) (valIn:PartySubID) : int = 
   let tag = "523="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNestedPartyID valIn =
    let tmp =  valIn
    NestedPartyID.NestedPartyID tmp


let WriteNestedPartyID (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyID) : int = 
   let tag = "524="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNestedPartyIDSource valIn =
    let tmp = System.Int32.Parse valIn
    NestedPartyIDSource.NestedPartyIDSource tmp


let WriteNestedPartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyIDSource) : int = 
   let tag = "525="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecondaryClOrdID valIn =
    let tmp =  valIn
    SecondaryClOrdID.SecondaryClOrdID tmp


let WriteSecondaryClOrdID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryClOrdID) : int = 
   let tag = "526="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecondaryExecID valIn =
    let tmp =  valIn
    SecondaryExecID.SecondaryExecID tmp


let WriteSecondaryExecID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryExecID) : int = 
   let tag = "527="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderCapacity (fldValIn:string) : OrderCapacity = 
    match fldValIn with
    |"A" -> OrderCapacity.Agency
    |"G" -> OrderCapacity.Proprietary
    |"I" -> OrderCapacity.Individual
    |"P" -> OrderCapacity.Principal
    |"R" -> OrderCapacity.RisklessPrincipal
    |"W" -> OrderCapacity.AgentForOtherMember
    | x -> failwith (sprintf "ReadOrderCapacity unknown fix tag: %A"  x) 


let WriteOrderCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:OrderCapacity) : int =
    match xxIn with
    | OrderCapacity.Agency ->
        let tag = "528=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Proprietary ->
        let tag = "528=G"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Individual ->
        let tag = "528=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.Principal ->
        let tag = "528=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.RisklessPrincipal ->
        let tag = "528=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderCapacity.AgentForOtherMember ->
        let tag = "528=W"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrderRestrictions (fldValIn:string) : OrderRestrictions = 
    match fldValIn with
    |"1" -> OrderRestrictions.ProgramTrade
    |"2" -> OrderRestrictions.IndexArbitrage
    |"3" -> OrderRestrictions.NonIndexArbitrage
    |"4" -> OrderRestrictions.CompetingMarketMaker
    |"5" -> OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheSecurity
    |"6" -> OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheUnderlyingSecurityOfADerivativeSecurity
    |"7" -> OrderRestrictions.ForeignEntity
    |"8" -> OrderRestrictions.ExternalMarketParticipant
    |"9" -> OrderRestrictions.ExternalInterConnectedMarketLinkage
    |"A" -> OrderRestrictions.RisklessArbitrage
    | x -> failwith (sprintf "ReadOrderRestrictions unknown fix tag: %A"  x) 


let WriteOrderRestrictions (dest:byte array) (nextFreeIdx:int) (xxIn:OrderRestrictions) : int =
    match xxIn with
    | OrderRestrictions.ProgramTrade ->
        let tag = "529=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.IndexArbitrage ->
        let tag = "529=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.NonIndexArbitrage ->
        let tag = "529=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.CompetingMarketMaker ->
        let tag = "529=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheSecurity ->
        let tag = "529=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ActingAsMarketMakerOrSpecialistInTheUnderlyingSecurityOfADerivativeSecurity ->
        let tag = "529=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ForeignEntity ->
        let tag = "529=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ExternalMarketParticipant ->
        let tag = "529=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.ExternalInterConnectedMarketLinkage ->
        let tag = "529=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | OrderRestrictions.RisklessArbitrage ->
        let tag = "529=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelRequestType (fldValIn:string) : MassCancelRequestType = 
    match fldValIn with
    |"1" -> MassCancelRequestType.CancelOrdersForASecurity
    |"2" -> MassCancelRequestType.CancelOrdersForAnUnderlyingSecurity
    |"3" -> MassCancelRequestType.CancelOrdersForAProduct
    |"4" -> MassCancelRequestType.CancelOrdersForACficode
    |"5" -> MassCancelRequestType.CancelOrdersForASecuritytype
    |"6" -> MassCancelRequestType.CancelOrdersForATradingSession
    |"7" -> MassCancelRequestType.CancelAllOrders
    | x -> failwith (sprintf "ReadMassCancelRequestType unknown fix tag: %A"  x) 


let WriteMassCancelRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelRequestType) : int =
    match xxIn with
    | MassCancelRequestType.CancelOrdersForASecurity ->
        let tag = "530=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForAnUnderlyingSecurity ->
        let tag = "530=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForAProduct ->
        let tag = "530=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForACficode ->
        let tag = "530=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForASecuritytype ->
        let tag = "530=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelOrdersForATradingSession ->
        let tag = "530=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRequestType.CancelAllOrders ->
        let tag = "530=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelResponse (fldValIn:string) : MassCancelResponse = 
    match fldValIn with
    |"0" -> MassCancelResponse.CancelRequestRejected
    |"1" -> MassCancelResponse.CancelOrdersForASecurity
    |"2" -> MassCancelResponse.CancelOrdersForAnUnderlyingSecurity
    |"3" -> MassCancelResponse.CancelOrdersForAProduct
    |"4" -> MassCancelResponse.CancelOrdersForACficode
    |"5" -> MassCancelResponse.CancelOrdersForASecuritytype
    |"6" -> MassCancelResponse.CancelOrdersForATradingSession
    |"7" -> MassCancelResponse.CancelAllOrders
    | x -> failwith (sprintf "ReadMassCancelResponse unknown fix tag: %A"  x) 


let WriteMassCancelResponse (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelResponse) : int =
    match xxIn with
    | MassCancelResponse.CancelRequestRejected ->
        let tag = "531=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForASecurity ->
        let tag = "531=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForAnUnderlyingSecurity ->
        let tag = "531=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForAProduct ->
        let tag = "531=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForACficode ->
        let tag = "531=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForASecuritytype ->
        let tag = "531=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelOrdersForATradingSession ->
        let tag = "531=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelResponse.CancelAllOrders ->
        let tag = "531=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMassCancelRejectReason (fldValIn:string) : MassCancelRejectReason = 
    match fldValIn with
    |"0" -> MassCancelRejectReason.MassCancelNotSupported
    |"1" -> MassCancelRejectReason.InvalidOrUnknownSecurity
    |"2" -> MassCancelRejectReason.InvalidOrUnknownUnderlying
    |"3" -> MassCancelRejectReason.InvalidOrUnknownProduct
    |"4" -> MassCancelRejectReason.InvalidOrUnknownCficode
    |"5" -> MassCancelRejectReason.InvalidOrUnknownSecurityType
    |"6" -> MassCancelRejectReason.InvalidOrUnknownTradingSession
    |"99" -> MassCancelRejectReason.Other
    | x -> failwith (sprintf "ReadMassCancelRejectReason unknown fix tag: %A"  x) 


let WriteMassCancelRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:MassCancelRejectReason) : int =
    match xxIn with
    | MassCancelRejectReason.MassCancelNotSupported ->
        let tag = "532=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownSecurity ->
        let tag = "532=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownUnderlying ->
        let tag = "532=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownProduct ->
        let tag = "532=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownCficode ->
        let tag = "532=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownSecurityType ->
        let tag = "532=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.InvalidOrUnknownTradingSession ->
        let tag = "532=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassCancelRejectReason.Other ->
        let tag = "532=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotalAffectedOrders valIn =
    let tmp = System.Int32.Parse valIn
    TotalAffectedOrders.TotalAffectedOrders tmp


let WriteTotalAffectedOrders (dest:byte []) (nextFreeIdx:int) (valIn:TotalAffectedOrders) : int = 
   let tag = "533="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoAffectedOrders valIn =
    let tmp = System.Int32.Parse valIn
    NoAffectedOrders.NoAffectedOrders tmp


let WriteNoAffectedOrders (dest:byte []) (nextFreeIdx:int) (valIn:NoAffectedOrders) : int = 
   let tag = "534="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAffectedOrderID valIn =
    let tmp =  valIn
    AffectedOrderID.AffectedOrderID tmp


let WriteAffectedOrderID (dest:byte []) (nextFreeIdx:int) (valIn:AffectedOrderID) : int = 
   let tag = "535="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAffectedSecondaryOrderID valIn =
    let tmp =  valIn
    AffectedSecondaryOrderID.AffectedSecondaryOrderID tmp


let WriteAffectedSecondaryOrderID (dest:byte []) (nextFreeIdx:int) (valIn:AffectedSecondaryOrderID) : int = 
   let tag = "536="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteType (fldValIn:string) : QuoteType = 
    match fldValIn with
    |"0" -> QuoteType.Indicative
    |"1" -> QuoteType.Tradeable
    |"2" -> QuoteType.RestrictedTradeable
    |"3" -> QuoteType.Counter
    | x -> failwith (sprintf "ReadQuoteType unknown fix tag: %A"  x) 


let WriteQuoteType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteType) : int =
    match xxIn with
    | QuoteType.Indicative ->
        let tag = "537=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.Tradeable ->
        let tag = "537=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.RestrictedTradeable ->
        let tag = "537=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteType.Counter ->
        let tag = "537=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNestedPartyRole valIn =
    let tmp = System.Int32.Parse valIn
    NestedPartyRole.NestedPartyRole tmp


let WriteNestedPartyRole (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartyRole) : int = 
   let tag = "538="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNestedPartyIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNestedPartyIDs.NoNestedPartyIDs tmp


let WriteNoNestedPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNestedPartyIDs) : int = 
   let tag = "539="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotalAccruedInterestAmt valIn =
    let tmp = System.Int32.Parse valIn
    TotalAccruedInterestAmt.TotalAccruedInterestAmt tmp


let WriteTotalAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:TotalAccruedInterestAmt) : int = 
   let tag = "540="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMaturityDate valIn =
    let tmp =  valIn
    MaturityDate.MaturityDate tmp


let WriteMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:MaturityDate) : int = 
   let tag = "541="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingMaturityDate valIn =
    let tmp =  valIn
    UnderlyingMaturityDate.UnderlyingMaturityDate tmp


let WriteUnderlyingMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingMaturityDate) : int = 
   let tag = "542="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadInstrRegistry valIn =
    let tmp =  valIn
    InstrRegistry.InstrRegistry tmp


let WriteInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:InstrRegistry) : int = 
   let tag = "543="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashMargin (fldValIn:string) : CashMargin = 
    match fldValIn with
    |"1" -> CashMargin.Cash
    |"2" -> CashMargin.MarginOpen
    |"3" -> CashMargin.MarginClose
    | x -> failwith (sprintf "ReadCashMargin unknown fix tag: %A"  x) 


let WriteCashMargin (dest:byte array) (nextFreeIdx:int) (xxIn:CashMargin) : int =
    match xxIn with
    | CashMargin.Cash ->
        let tag = "544=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CashMargin.MarginOpen ->
        let tag = "544=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CashMargin.MarginClose ->
        let tag = "544=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNestedPartySubID valIn =
    let tmp =  valIn
    NestedPartySubID.NestedPartySubID tmp


let WriteNestedPartySubID (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartySubID) : int = 
   let tag = "545="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadScope (fldValIn:string) : Scope = 
    match fldValIn with
    |"1" -> Scope.Local
    |"2" -> Scope.National
    |"3" -> Scope.Global
    | x -> failwith (sprintf "ReadScope unknown fix tag: %A"  x) 


let WriteScope (dest:byte array) (nextFreeIdx:int) (xxIn:Scope) : int =
    match xxIn with
    | Scope.Local ->
        let tag = "546=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Scope.National ->
        let tag = "546=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | Scope.Global ->
        let tag = "546=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMDImplicitDelete valIn =
    let tmp = System.Boolean.Parse valIn
    MDImplicitDelete.MDImplicitDelete tmp


let WriteMDImplicitDelete (dest:byte []) (nextFreeIdx:int) (valIn:MDImplicitDelete) : int = 
   let tag = "547="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCrossID valIn =
    let tmp =  valIn
    CrossID.CrossID tmp


let WriteCrossID (dest:byte []) (nextFreeIdx:int) (valIn:CrossID) : int = 
   let tag = "548="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCrossType (fldValIn:string) : CrossType = 
    match fldValIn with
    |"1" -> CrossType.CrossTradeWhichIsExecutedCompletelyOrNot
    |"2" -> CrossType.CrossTradeWhichIsExecutedPartiallyAndTheRestIsCancelled
    |"3" -> CrossType.CrossTradeWhichIsPartiallyExecutedWithTheUnfilledPortionsRemainingActive
    |"4" -> CrossType.CrossTradeIsExecutedWithExistingOrdersWithTheSamePrice
    | x -> failwith (sprintf "ReadCrossType unknown fix tag: %A"  x) 


let WriteCrossType (dest:byte array) (nextFreeIdx:int) (xxIn:CrossType) : int =
    match xxIn with
    | CrossType.CrossTradeWhichIsExecutedCompletelyOrNot ->
        let tag = "549=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeWhichIsExecutedPartiallyAndTheRestIsCancelled ->
        let tag = "549=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeWhichIsPartiallyExecutedWithTheUnfilledPortionsRemainingActive ->
        let tag = "549=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossType.CrossTradeIsExecutedWithExistingOrdersWithTheSamePrice ->
        let tag = "549=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCrossPrioritization (fldValIn:string) : CrossPrioritization = 
    match fldValIn with
    |"0" -> CrossPrioritization.NNone
    |"1" -> CrossPrioritization.BuySideIsPrioritized
    |"2" -> CrossPrioritization.SellSideIsPrioritized
    | x -> failwith (sprintf "ReadCrossPrioritization unknown fix tag: %A"  x) 


let WriteCrossPrioritization (dest:byte array) (nextFreeIdx:int) (xxIn:CrossPrioritization) : int =
    match xxIn with
    | CrossPrioritization.NNone ->
        let tag = "550=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossPrioritization.BuySideIsPrioritized ->
        let tag = "550=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CrossPrioritization.SellSideIsPrioritized ->
        let tag = "550=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigCrossID valIn =
    let tmp =  valIn
    OrigCrossID.OrigCrossID tmp


let WriteOrigCrossID (dest:byte []) (nextFreeIdx:int) (valIn:OrigCrossID) : int = 
   let tag = "551="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoSides (fldValIn:string) : NoSides = 
    match fldValIn with
    |"1" -> NoSides.OneSide
    |"2" -> NoSides.BothSides
    | x -> failwith (sprintf "ReadNoSides unknown fix tag: %A"  x) 


let WriteNoSides (dest:byte array) (nextFreeIdx:int) (xxIn:NoSides) : int =
    match xxIn with
    | NoSides.OneSide ->
        let tag = "552=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NoSides.BothSides ->
        let tag = "552=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUsername valIn =
    let tmp =  valIn
    Username.Username tmp


let WriteUsername (dest:byte []) (nextFreeIdx:int) (valIn:Username) : int = 
   let tag = "553="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPassword valIn =
    let tmp =  valIn
    Password.Password tmp


let WritePassword (dest:byte []) (nextFreeIdx:int) (valIn:Password) : int = 
   let tag = "554="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoLegs valIn =
    let tmp = System.Int32.Parse valIn
    NoLegs.NoLegs tmp


let WriteNoLegs (dest:byte []) (nextFreeIdx:int) (valIn:NoLegs) : int = 
   let tag = "555="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCurrency valIn =
    let tmp =  valIn
    LegCurrency.LegCurrency tmp


let WriteLegCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegCurrency) : int = 
   let tag = "556="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotNoSecurityTypes valIn =
    let tmp = System.Int32.Parse valIn
    TotNoSecurityTypes.TotNoSecurityTypes tmp


let WriteTotNoSecurityTypes (dest:byte []) (nextFreeIdx:int) (valIn:TotNoSecurityTypes) : int = 
   let tag = "557="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoSecurityTypes valIn =
    let tmp = System.Int32.Parse valIn
    NoSecurityTypes.NoSecurityTypes tmp


let WriteNoSecurityTypes (dest:byte []) (nextFreeIdx:int) (valIn:NoSecurityTypes) : int = 
   let tag = "558="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecurityListRequestType (fldValIn:string) : SecurityListRequestType = 
    match fldValIn with
    |"0" -> SecurityListRequestType.Symbol
    |"1" -> SecurityListRequestType.SecuritytypeAndOrCficode
    |"2" -> SecurityListRequestType.Product
    |"3" -> SecurityListRequestType.Tradingsessionid
    |"4" -> SecurityListRequestType.AllSecurities
    | x -> failwith (sprintf "ReadSecurityListRequestType unknown fix tag: %A"  x) 


let WriteSecurityListRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityListRequestType) : int =
    match xxIn with
    | SecurityListRequestType.Symbol ->
        let tag = "559=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.SecuritytypeAndOrCficode ->
        let tag = "559=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.Product ->
        let tag = "559=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.Tradingsessionid ->
        let tag = "559=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityListRequestType.AllSecurities ->
        let tag = "559=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecurityRequestResult (fldValIn:string) : SecurityRequestResult = 
    match fldValIn with
    |"0" -> SecurityRequestResult.ValidRequest
    |"1" -> SecurityRequestResult.InvalidOrUnsupportedRequest
    |"2" -> SecurityRequestResult.NoInstrumentsFoundThatMatchSelectionCriteria
    |"3" -> SecurityRequestResult.NotAuthorizedToRetrieveInstrumentData
    |"4" -> SecurityRequestResult.InstrumentDataTemporarilyUnavailable
    |"5" -> SecurityRequestResult.RequestForInstrumentDataNotSupported
    | x -> failwith (sprintf "ReadSecurityRequestResult unknown fix tag: %A"  x) 


let WriteSecurityRequestResult (dest:byte array) (nextFreeIdx:int) (xxIn:SecurityRequestResult) : int =
    match xxIn with
    | SecurityRequestResult.ValidRequest ->
        let tag = "560=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.InvalidOrUnsupportedRequest ->
        let tag = "560=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.NoInstrumentsFoundThatMatchSelectionCriteria ->
        let tag = "560=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.NotAuthorizedToRetrieveInstrumentData ->
        let tag = "560=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.InstrumentDataTemporarilyUnavailable ->
        let tag = "560=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SecurityRequestResult.RequestForInstrumentDataNotSupported ->
        let tag = "560=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadRoundLot valIn =
    let tmp = System.Decimal.Parse valIn
    RoundLot.RoundLot tmp


let WriteRoundLot (dest:byte []) (nextFreeIdx:int) (valIn:RoundLot) : int = 
   let tag = "561="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMinTradeVol valIn =
    let tmp = System.Decimal.Parse valIn
    MinTradeVol.MinTradeVol tmp


let WriteMinTradeVol (dest:byte []) (nextFreeIdx:int) (valIn:MinTradeVol) : int = 
   let tag = "562="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMultiLegRptTypeReq (fldValIn:string) : MultiLegRptTypeReq = 
    match fldValIn with
    |"0" -> MultiLegRptTypeReq.ReportByMulitlegSecurityOnly
    |"1" -> MultiLegRptTypeReq.ReportByMultilegSecurityAndByInstrumentLegsBelongingToTheMultilegSecurity
    |"2" -> MultiLegRptTypeReq.ReportByInstrumentLegsBelongingToTheMultilegSecurityOnly
    | x -> failwith (sprintf "ReadMultiLegRptTypeReq unknown fix tag: %A"  x) 


let WriteMultiLegRptTypeReq (dest:byte array) (nextFreeIdx:int) (xxIn:MultiLegRptTypeReq) : int =
    match xxIn with
    | MultiLegRptTypeReq.ReportByMulitlegSecurityOnly ->
        let tag = "563=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegRptTypeReq.ReportByMultilegSecurityAndByInstrumentLegsBelongingToTheMultilegSecurity ->
        let tag = "563=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MultiLegRptTypeReq.ReportByInstrumentLegsBelongingToTheMultilegSecurityOnly ->
        let tag = "563=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLegPositionEffect valIn =
    let tmp = System.Int32.Parse valIn
    LegPositionEffect.LegPositionEffect tmp


let WriteLegPositionEffect (dest:byte []) (nextFreeIdx:int) (valIn:LegPositionEffect) : int = 
   let tag = "564="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCoveredOrUncovered valIn =
    let tmp = System.Int32.Parse valIn
    LegCoveredOrUncovered.LegCoveredOrUncovered tmp


let WriteLegCoveredOrUncovered (dest:byte []) (nextFreeIdx:int) (valIn:LegCoveredOrUncovered) : int = 
   let tag = "565="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegPrice valIn =
    let tmp = System.Decimal.Parse valIn
    LegPrice.LegPrice tmp


let WriteLegPrice (dest:byte []) (nextFreeIdx:int) (valIn:LegPrice) : int = 
   let tag = "566="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradSesStatusRejReason (fldValIn:string) : TradSesStatusRejReason = 
    match fldValIn with
    |"1" -> TradSesStatusRejReason.UnknownOrInvalidTradingsessionid
    | x -> failwith (sprintf "ReadTradSesStatusRejReason unknown fix tag: %A"  x) 


let WriteTradSesStatusRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:TradSesStatusRejReason) : int =
    match xxIn with
    | TradSesStatusRejReason.UnknownOrInvalidTradingsessionid ->
        let tag = "567=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeRequestID valIn =
    let tmp =  valIn
    TradeRequestID.TradeRequestID tmp


let WriteTradeRequestID (dest:byte []) (nextFreeIdx:int) (valIn:TradeRequestID) : int = 
   let tag = "568="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeRequestType (fldValIn:string) : TradeRequestType = 
    match fldValIn with
    |"0" -> TradeRequestType.AllTrades
    |"1" -> TradeRequestType.MatchedTradesMatchingCriteriaProvidedOnRequest
    |"2" -> TradeRequestType.UnmatchedTradesThatMatchCriteria
    |"3" -> TradeRequestType.UnreportedTradesThatMatchCriteria
    |"4" -> TradeRequestType.AdvisoriesThatMatchCriteria
    | x -> failwith (sprintf "ReadTradeRequestType unknown fix tag: %A"  x) 


let WriteTradeRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestType) : int =
    match xxIn with
    | TradeRequestType.AllTrades ->
        let tag = "569=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.MatchedTradesMatchingCriteriaProvidedOnRequest ->
        let tag = "569=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.UnmatchedTradesThatMatchCriteria ->
        let tag = "569=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.UnreportedTradesThatMatchCriteria ->
        let tag = "569=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestType.AdvisoriesThatMatchCriteria ->
        let tag = "569=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPreviouslyReported valIn =
    let tmp = System.Boolean.Parse valIn
    PreviouslyReported.PreviouslyReported tmp


let WritePreviouslyReported (dest:byte []) (nextFreeIdx:int) (valIn:PreviouslyReported) : int = 
   let tag = "570="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeReportID valIn =
    let tmp =  valIn
    TradeReportID.TradeReportID tmp


let WriteTradeReportID (dest:byte []) (nextFreeIdx:int) (valIn:TradeReportID) : int = 
   let tag = "571="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeReportRefID valIn =
    let tmp =  valIn
    TradeReportRefID.TradeReportRefID tmp


let WriteTradeReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:TradeReportRefID) : int = 
   let tag = "572="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMatchStatus (fldValIn:string) : MatchStatus = 
    match fldValIn with
    |"0" -> MatchStatus.ComparedMatchedOrAffirmed
    |"1" -> MatchStatus.UncomparedUnmatchedOrUnaffirmed
    |"2" -> MatchStatus.AdvisoryOrAlert
    | x -> failwith (sprintf "ReadMatchStatus unknown fix tag: %A"  x) 


let WriteMatchStatus (dest:byte array) (nextFreeIdx:int) (xxIn:MatchStatus) : int =
    match xxIn with
    | MatchStatus.ComparedMatchedOrAffirmed ->
        let tag = "573=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MatchStatus.UncomparedUnmatchedOrUnaffirmed ->
        let tag = "573=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MatchStatus.AdvisoryOrAlert ->
        let tag = "573=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadMatchType valIn =
    let tmp =  valIn
    MatchType.MatchType tmp


let WriteMatchType (dest:byte []) (nextFreeIdx:int) (valIn:MatchType) : int = 
   let tag = "574="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOddLot valIn =
    let tmp = System.Boolean.Parse valIn
    OddLot.OddLot tmp


let WriteOddLot (dest:byte []) (nextFreeIdx:int) (valIn:OddLot) : int = 
   let tag = "575="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoClearingInstructions valIn =
    let tmp = System.Int32.Parse valIn
    NoClearingInstructions.NoClearingInstructions tmp


let WriteNoClearingInstructions (dest:byte []) (nextFreeIdx:int) (valIn:NoClearingInstructions) : int = 
   let tag = "576="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadClearingInstruction (fldValIn:string) : ClearingInstruction = 
    match fldValIn with
    |"0" -> ClearingInstruction.ProcessNormally
    |"1" -> ClearingInstruction.ExcludeFromAllNetting
    |"2" -> ClearingInstruction.BilateralNettingOnly
    |"3" -> ClearingInstruction.ExClearing
    |"4" -> ClearingInstruction.SpecialTrade
    |"5" -> ClearingInstruction.MultilateralNetting
    |"6" -> ClearingInstruction.ClearAgainstCentralCounterparty
    |"7" -> ClearingInstruction.ExcludeFromCentralCounterparty
    |"8" -> ClearingInstruction.ManualMode
    |"9" -> ClearingInstruction.AutomaticPostingMode
    |"10" -> ClearingInstruction.AutomaticGiveUpMode
    |"11" -> ClearingInstruction.QualifiedServiceRepresentative
    |"12" -> ClearingInstruction.CustomerTrade
    |"13" -> ClearingInstruction.SelfClearing
    | x -> failwith (sprintf "ReadClearingInstruction unknown fix tag: %A"  x) 


let WriteClearingInstruction (dest:byte array) (nextFreeIdx:int) (xxIn:ClearingInstruction) : int =
    match xxIn with
    | ClearingInstruction.ProcessNormally ->
        let tag = "577=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExcludeFromAllNetting ->
        let tag = "577=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.BilateralNettingOnly ->
        let tag = "577=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExClearing ->
        let tag = "577=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.SpecialTrade ->
        let tag = "577=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.MultilateralNetting ->
        let tag = "577=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ClearAgainstCentralCounterparty ->
        let tag = "577=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ExcludeFromCentralCounterparty ->
        let tag = "577=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.ManualMode ->
        let tag = "577=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.AutomaticPostingMode ->
        let tag = "577=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.AutomaticGiveUpMode ->
        let tag = "577=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.QualifiedServiceRepresentative ->
        let tag = "577=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.CustomerTrade ->
        let tag = "577=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingInstruction.SelfClearing ->
        let tag = "577=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeInputSource valIn =
    let tmp =  valIn
    TradeInputSource.TradeInputSource tmp


let WriteTradeInputSource (dest:byte []) (nextFreeIdx:int) (valIn:TradeInputSource) : int = 
   let tag = "578="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeInputDevice valIn =
    let tmp =  valIn
    TradeInputDevice.TradeInputDevice tmp


let WriteTradeInputDevice (dest:byte []) (nextFreeIdx:int) (valIn:TradeInputDevice) : int = 
   let tag = "579="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoDates valIn =
    let tmp = System.Int32.Parse valIn
    NoDates.NoDates tmp


let WriteNoDates (dest:byte []) (nextFreeIdx:int) (valIn:NoDates) : int = 
   let tag = "580="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAccountType (fldValIn:string) : AccountType = 
    match fldValIn with
    |"1" -> AccountType.AccountIsCarriedOnCustomerSideOfBooks
    |"2" -> AccountType.AccountIsCarriedOnNonCustomerSideOfBooks
    |"3" -> AccountType.HouseTrader
    |"4" -> AccountType.FloorTrader
    |"6" -> AccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined
    |"7" -> AccountType.AccountIsHouseTraderAndIsCrossMargined
    |"8" -> AccountType.JointBackofficeAccount
    | x -> failwith (sprintf "ReadAccountType unknown fix tag: %A"  x) 


let WriteAccountType (dest:byte array) (nextFreeIdx:int) (xxIn:AccountType) : int =
    match xxIn with
    | AccountType.AccountIsCarriedOnCustomerSideOfBooks ->
        let tag = "581=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsCarriedOnNonCustomerSideOfBooks ->
        let tag = "581=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.HouseTrader ->
        let tag = "581=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.FloorTrader ->
        let tag = "581=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined ->
        let tag = "581=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.AccountIsHouseTraderAndIsCrossMargined ->
        let tag = "581=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AccountType.JointBackofficeAccount ->
        let tag = "581=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCustOrderCapacity (fldValIn:string) : CustOrderCapacity = 
    match fldValIn with
    |"1" -> CustOrderCapacity.MemberTradingForTheirOwnAccount
    |"2" -> CustOrderCapacity.ClearingFirmTradingForItsProprietaryAccount
    |"3" -> CustOrderCapacity.MemberTradingForAnotherMember
    |"4" -> CustOrderCapacity.AllOther
    | x -> failwith (sprintf "ReadCustOrderCapacity unknown fix tag: %A"  x) 


let WriteCustOrderCapacity (dest:byte array) (nextFreeIdx:int) (xxIn:CustOrderCapacity) : int =
    match xxIn with
    | CustOrderCapacity.MemberTradingForTheirOwnAccount ->
        let tag = "582=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.ClearingFirmTradingForItsProprietaryAccount ->
        let tag = "582=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.MemberTradingForAnotherMember ->
        let tag = "582=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CustOrderCapacity.AllOther ->
        let tag = "582=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadClOrdLinkID valIn =
    let tmp =  valIn
    ClOrdLinkID.ClOrdLinkID tmp


let WriteClOrdLinkID (dest:byte []) (nextFreeIdx:int) (valIn:ClOrdLinkID) : int = 
   let tag = "583="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMassStatusReqID valIn =
    let tmp =  valIn
    MassStatusReqID.MassStatusReqID tmp


let WriteMassStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:MassStatusReqID) : int = 
   let tag = "584="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMassStatusReqType (fldValIn:string) : MassStatusReqType = 
    match fldValIn with
    |"1" -> MassStatusReqType.StatusForOrdersForASecurity
    |"2" -> MassStatusReqType.StatusForOrdersForAnUnderlyingSecurity
    |"3" -> MassStatusReqType.StatusForOrdersForAProduct
    |"4" -> MassStatusReqType.StatusForOrdersForACficode
    |"5" -> MassStatusReqType.StatusForOrdersForASecuritytype
    |"6" -> MassStatusReqType.StatusForOrdersForATradingSession
    |"7" -> MassStatusReqType.StatusForAllOrders
    |"8" -> MassStatusReqType.StatusForOrdersForAPartyid
    | x -> failwith (sprintf "ReadMassStatusReqType unknown fix tag: %A"  x) 


let WriteMassStatusReqType (dest:byte array) (nextFreeIdx:int) (xxIn:MassStatusReqType) : int =
    match xxIn with
    | MassStatusReqType.StatusForOrdersForASecurity ->
        let tag = "585=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAnUnderlyingSecurity ->
        let tag = "585=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAProduct ->
        let tag = "585=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForACficode ->
        let tag = "585=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForASecuritytype ->
        let tag = "585=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForATradingSession ->
        let tag = "585=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForAllOrders ->
        let tag = "585=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MassStatusReqType.StatusForOrdersForAPartyid ->
        let tag = "585=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigOrdModTime valIn =
    let tmp =  valIn
    OrigOrdModTime.OrigOrdModTime tmp


let WriteOrigOrdModTime (dest:byte []) (nextFreeIdx:int) (valIn:OrigOrdModTime) : int = 
   let tag = "586="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSettlType valIn =
    let tmp = System.Int32.Parse valIn
    LegSettlType.LegSettlType tmp


let WriteLegSettlType (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlType) : int = 
   let tag = "587="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSettlDate valIn =
    let tmp =  valIn
    LegSettlDate.LegSettlDate tmp


let WriteLegSettlDate (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlDate) : int = 
   let tag = "588="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDayBookingInst (fldValIn:string) : DayBookingInst = 
    match fldValIn with
    |"0" -> DayBookingInst.CanTriggerBookingWithoutReferenceToTheOrderInitiator
    |"1" -> DayBookingInst.SpeakWithOrderInitiatorBeforeBooking
    |"2" -> DayBookingInst.Accumulate
    | x -> failwith (sprintf "ReadDayBookingInst unknown fix tag: %A"  x) 


let WriteDayBookingInst (dest:byte array) (nextFreeIdx:int) (xxIn:DayBookingInst) : int =
    match xxIn with
    | DayBookingInst.CanTriggerBookingWithoutReferenceToTheOrderInitiator ->
        let tag = "589=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DayBookingInst.SpeakWithOrderInitiatorBeforeBooking ->
        let tag = "589=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DayBookingInst.Accumulate ->
        let tag = "589=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingUnit (fldValIn:string) : BookingUnit = 
    match fldValIn with
    |"0" -> BookingUnit.EachPartialExecutionIsABookableUnit
    |"1" -> BookingUnit.AggregatePartialExecutionsOnThisOrderAndBookOneTradePerOrder
    |"2" -> BookingUnit.AggregateExecutionsForThisSymbolSideAndSettlementDate
    | x -> failwith (sprintf "ReadBookingUnit unknown fix tag: %A"  x) 


let WriteBookingUnit (dest:byte array) (nextFreeIdx:int) (xxIn:BookingUnit) : int =
    match xxIn with
    | BookingUnit.EachPartialExecutionIsABookableUnit ->
        let tag = "590=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingUnit.AggregatePartialExecutionsOnThisOrderAndBookOneTradePerOrder ->
        let tag = "590=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingUnit.AggregateExecutionsForThisSymbolSideAndSettlementDate ->
        let tag = "590=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPreallocMethod (fldValIn:string) : PreallocMethod = 
    match fldValIn with
    |"0" -> PreallocMethod.ProRata
    |"1" -> PreallocMethod.DoNotProRata
    | x -> failwith (sprintf "ReadPreallocMethod unknown fix tag: %A"  x) 


let WritePreallocMethod (dest:byte array) (nextFreeIdx:int) (xxIn:PreallocMethod) : int =
    match xxIn with
    | PreallocMethod.ProRata ->
        let tag = "591=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PreallocMethod.DoNotProRata ->
        let tag = "591=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingCountryOfIssue valIn =
    let tmp =  valIn
    UnderlyingCountryOfIssue.UnderlyingCountryOfIssue tmp


let WriteUnderlyingCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCountryOfIssue) : int = 
   let tag = "592="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingStateOrProvinceOfIssue valIn =
    let tmp =  valIn
    UnderlyingStateOrProvinceOfIssue.UnderlyingStateOrProvinceOfIssue tmp


let WriteUnderlyingStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStateOrProvinceOfIssue) : int = 
   let tag = "593="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingLocaleOfIssue valIn =
    let tmp =  valIn
    UnderlyingLocaleOfIssue.UnderlyingLocaleOfIssue tmp


let WriteUnderlyingLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLocaleOfIssue) : int = 
   let tag = "594="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingInstrRegistry valIn =
    let tmp =  valIn
    UnderlyingInstrRegistry.UnderlyingInstrRegistry tmp


let WriteUnderlyingInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingInstrRegistry) : int = 
   let tag = "595="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCountryOfIssue valIn =
    let tmp =  valIn
    LegCountryOfIssue.LegCountryOfIssue tmp


let WriteLegCountryOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegCountryOfIssue) : int = 
   let tag = "596="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegStateOrProvinceOfIssue valIn =
    let tmp =  valIn
    LegStateOrProvinceOfIssue.LegStateOrProvinceOfIssue tmp


let WriteLegStateOrProvinceOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegStateOrProvinceOfIssue) : int = 
   let tag = "597="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegLocaleOfIssue valIn =
    let tmp =  valIn
    LegLocaleOfIssue.LegLocaleOfIssue tmp


let WriteLegLocaleOfIssue (dest:byte []) (nextFreeIdx:int) (valIn:LegLocaleOfIssue) : int = 
   let tag = "598="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegInstrRegistry valIn =
    let tmp =  valIn
    LegInstrRegistry.LegInstrRegistry tmp


let WriteLegInstrRegistry (dest:byte []) (nextFreeIdx:int) (valIn:LegInstrRegistry) : int = 
   let tag = "599="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSymbol valIn =
    let tmp =  valIn
    LegSymbol.LegSymbol tmp


let WriteLegSymbol (dest:byte []) (nextFreeIdx:int) (valIn:LegSymbol) : int = 
   let tag = "600="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSymbolSfx valIn =
    let tmp =  valIn
    LegSymbolSfx.LegSymbolSfx tmp


let WriteLegSymbolSfx (dest:byte []) (nextFreeIdx:int) (valIn:LegSymbolSfx) : int = 
   let tag = "601="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityID valIn =
    let tmp =  valIn
    LegSecurityID.LegSecurityID tmp


let WriteLegSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityID) : int = 
   let tag = "602="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityIDSource valIn =
    let tmp =  valIn
    LegSecurityIDSource.LegSecurityIDSource tmp


let WriteLegSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityIDSource) : int = 
   let tag = "603="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoLegSecurityAltID valIn =
    let tmp = System.Int32.Parse valIn
    NoLegSecurityAltID.NoLegSecurityAltID tmp


let WriteNoLegSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:NoLegSecurityAltID) : int = 
   let tag = "604="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityAltID valIn =
    let tmp =  valIn
    LegSecurityAltID.LegSecurityAltID tmp


let WriteLegSecurityAltID (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityAltID) : int = 
   let tag = "605="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityAltIDSource valIn =
    let tmp =  valIn
    LegSecurityAltIDSource.LegSecurityAltIDSource tmp


let WriteLegSecurityAltIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityAltIDSource) : int = 
   let tag = "606="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegProduct valIn =
    let tmp = System.Int32.Parse valIn
    LegProduct.LegProduct tmp


let WriteLegProduct (dest:byte []) (nextFreeIdx:int) (valIn:LegProduct) : int = 
   let tag = "607="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCFICode valIn =
    let tmp =  valIn
    LegCFICode.LegCFICode tmp


let WriteLegCFICode (dest:byte []) (nextFreeIdx:int) (valIn:LegCFICode) : int = 
   let tag = "608="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityType valIn =
    let tmp =  valIn
    LegSecurityType.LegSecurityType tmp


let WriteLegSecurityType (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityType) : int = 
   let tag = "609="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegMaturityMonthYear valIn =
    let tmp =  valIn
    LegMaturityMonthYear.LegMaturityMonthYear tmp


let WriteLegMaturityMonthYear (dest:byte []) (nextFreeIdx:int) (valIn:LegMaturityMonthYear) : int = 
   let tag = "610="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegMaturityDate valIn =
    let tmp =  valIn
    LegMaturityDate.LegMaturityDate tmp


let WriteLegMaturityDate (dest:byte []) (nextFreeIdx:int) (valIn:LegMaturityDate) : int = 
   let tag = "611="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegStrikePrice valIn =
    let tmp = System.Decimal.Parse valIn
    LegStrikePrice.LegStrikePrice tmp


let WriteLegStrikePrice (dest:byte []) (nextFreeIdx:int) (valIn:LegStrikePrice) : int = 
   let tag = "612="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegOptAttribute valIn =
    let tmp = System.Int32.Parse valIn
    LegOptAttribute.LegOptAttribute tmp


let WriteLegOptAttribute (dest:byte []) (nextFreeIdx:int) (valIn:LegOptAttribute) : int = 
   let tag = "613="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegContractMultiplier valIn =
    let tmp = System.Decimal.Parse valIn
    LegContractMultiplier.LegContractMultiplier tmp


let WriteLegContractMultiplier (dest:byte []) (nextFreeIdx:int) (valIn:LegContractMultiplier) : int = 
   let tag = "614="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegCouponRate valIn =
    let tmp = System.Decimal.Parse valIn
    LegCouponRate.LegCouponRate tmp


let WriteLegCouponRate (dest:byte []) (nextFreeIdx:int) (valIn:LegCouponRate) : int = 
   let tag = "615="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecurityExchange valIn =
    let tmp =  valIn
    LegSecurityExchange.LegSecurityExchange tmp


let WriteLegSecurityExchange (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityExchange) : int = 
   let tag = "616="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegIssuer valIn =
    let tmp =  valIn
    LegIssuer.LegIssuer tmp


let WriteLegIssuer (dest:byte []) (nextFreeIdx:int) (valIn:LegIssuer) : int = 
   let tag = "617="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedLegIssuer (dest:byte []) (nextFreeIdx:int) (fld:EncodedLegIssuer) : int =
    // write the string length part of the compound msg
    let lenTag = "618="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedLegIssuer valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "619" then failwith "invalid tag reading EncodedLegIssuer"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedLegIssuer"
    EncodedLegIssuer.EncodedLegIssuer raw


let ReadLegSecurityDesc valIn =
    let tmp =  valIn
    LegSecurityDesc.LegSecurityDesc tmp


let WriteLegSecurityDesc (dest:byte []) (nextFreeIdx:int) (valIn:LegSecurityDesc) : int = 
   let tag = "620="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


// compound write, of a length field and the corresponding string field
let WriteEncodedLegSecurityDesc (dest:byte []) (nextFreeIdx:int) (fld:EncodedLegSecurityDesc) : int =
    // write the string length part of the compound msg
    let lenTag = "621="B
    Buffer.BlockCopy (lenTag, 0, dest, nextFreeIdx, lenTag.Length)
    let nextFreeIdx2 = nextFreeIdx + lenTag.Length
    let lenBs = ToBytes.Convert fld.Value.Length
    Buffer.BlockCopy (lenBs, 0, dest, nextFreeIdx2, lenBs.Length)
    let nextFreeIdx3 = nextFreeIdx2 + lenBs.Length
    dest.[nextFreeIdx3] <- 1uy // write the SOH field delimeter
    let nextFreeIdx4 = nextFreeIdx3 + 1 // +1 to include the delimeter
    // write the string part of the compound msg
    let strTag = "91="B // i.e. a tag for the string field of the compound msg
    Buffer.BlockCopy (strTag, 0, dest, nextFreeIdx4, strTag.Length)
    let nextFreeIdx5 = nextFreeIdx4 + strTag.Length
    let strBs = ToBytes.Convert fld.Value
    Buffer.BlockCopy (strBs, 0, dest, nextFreeIdx5, strBs.Length)
    let nextFreeIdx6 = nextFreeIdx5 + strTag.Length
    dest.[nextFreeIdx6] <- 1uy // write the SOH field delimeter
    nextFreeIdx6 + lenBs.Length + 1 // +1 to include the delimeter


// compound read
let ReadEncodedLegSecurityDesc valIn (strm:System.IO.Stream) =
    let strLen = System.Int32.Parse valIn
    // the len has been read, next read the string
    // the tag read-in must match the expected tag
    // todo: read in strLen bytes
    let ss = CrapReadUntilDelim strm
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    if tag <> "622" then failwith "invalid tag reading EncodedLegSecurityDesc"
    if strLen <> raw.Length then failwith "mismatched string len reading EncodedLegSecurityDesc"
    EncodedLegSecurityDesc.EncodedLegSecurityDesc raw


let ReadLegRatioQty valIn =
    let tmp = System.Decimal.Parse valIn
    LegRatioQty.LegRatioQty tmp


let WriteLegRatioQty (dest:byte []) (nextFreeIdx:int) (valIn:LegRatioQty) : int = 
   let tag = "623="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSide valIn =
    let tmp = System.Int32.Parse valIn
    LegSide.LegSide tmp


let WriteLegSide (dest:byte []) (nextFreeIdx:int) (valIn:LegSide) : int = 
   let tag = "624="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradingSessionSubID valIn =
    let tmp =  valIn
    TradingSessionSubID.TradingSessionSubID tmp


let WriteTradingSessionSubID (dest:byte []) (nextFreeIdx:int) (valIn:TradingSessionSubID) : int = 
   let tag = "625="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocType (fldValIn:string) : AllocType = 
    match fldValIn with
    |"1" -> AllocType.Calculated
    |"2" -> AllocType.Preliminary
    |"5" -> AllocType.ReadyToBookSingleOrder
    |"7" -> AllocType.WarehouseInstruction
    |"8" -> AllocType.RequestToIntermediary
    | x -> failwith (sprintf "ReadAllocType unknown fix tag: %A"  x) 


let WriteAllocType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocType) : int =
    match xxIn with
    | AllocType.Calculated ->
        let tag = "626=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.Preliminary ->
        let tag = "626=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.ReadyToBookSingleOrder ->
        let tag = "626=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.WarehouseInstruction ->
        let tag = "626=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocType.RequestToIntermediary ->
        let tag = "626=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoHops valIn =
    let tmp = System.Int32.Parse valIn
    NoHops.NoHops tmp


let WriteNoHops (dest:byte []) (nextFreeIdx:int) (valIn:NoHops) : int = 
   let tag = "627="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHopCompID valIn =
    let tmp =  valIn
    HopCompID.HopCompID tmp


let WriteHopCompID (dest:byte []) (nextFreeIdx:int) (valIn:HopCompID) : int = 
   let tag = "628="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHopSendingTime valIn =
    let tmp =  valIn
    HopSendingTime.HopSendingTime tmp


let WriteHopSendingTime (dest:byte []) (nextFreeIdx:int) (valIn:HopSendingTime) : int = 
   let tag = "629="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadHopRefID valIn =
    let tmp = System.Int32.Parse valIn
    HopRefID.HopRefID tmp


let WriteHopRefID (dest:byte []) (nextFreeIdx:int) (valIn:HopRefID) : int = 
   let tag = "630="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMidPx valIn =
    let tmp = System.Decimal.Parse valIn
    MidPx.MidPx tmp


let WriteMidPx (dest:byte []) (nextFreeIdx:int) (valIn:MidPx) : int = 
   let tag = "631="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidYield valIn =
    let tmp = System.Decimal.Parse valIn
    BidYield.BidYield tmp


let WriteBidYield (dest:byte []) (nextFreeIdx:int) (valIn:BidYield) : int = 
   let tag = "632="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMidYield valIn =
    let tmp = System.Decimal.Parse valIn
    MidYield.MidYield tmp


let WriteMidYield (dest:byte []) (nextFreeIdx:int) (valIn:MidYield) : int = 
   let tag = "633="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferYield valIn =
    let tmp = System.Decimal.Parse valIn
    OfferYield.OfferYield tmp


let WriteOfferYield (dest:byte []) (nextFreeIdx:int) (valIn:OfferYield) : int = 
   let tag = "634="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadClearingFeeIndicator (fldValIn:string) : ClearingFeeIndicator = 
    match fldValIn with
    |"B" -> ClearingFeeIndicator.CboeMember
    |"C" -> ClearingFeeIndicator.NonMemberAndCustomer
    |"E" -> ClearingFeeIndicator.EquityMemberAndClearingMember
    |"F" -> ClearingFeeIndicator.FullAndAssociateMemberTradingForOwnAccountAndAsFloorBrokers
    |"H" -> ClearingFeeIndicator.Firms106hAnd106j
    |"I" -> ClearingFeeIndicator.GimIdemAndComMembershipInterestHolders
    |"L" -> ClearingFeeIndicator.LesseeAnd106fEmployees
    |"M" -> ClearingFeeIndicator.AllOtherOwnershipTypes
    | x -> failwith (sprintf "ReadClearingFeeIndicator unknown fix tag: %A"  x) 


let WriteClearingFeeIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:ClearingFeeIndicator) : int =
    match xxIn with
    | ClearingFeeIndicator.CboeMember ->
        let tag = "635=B"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.NonMemberAndCustomer ->
        let tag = "635=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.EquityMemberAndClearingMember ->
        let tag = "635=E"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.FullAndAssociateMemberTradingForOwnAccountAndAsFloorBrokers ->
        let tag = "635=F"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.Firms106hAnd106j ->
        let tag = "635=H"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.GimIdemAndComMembershipInterestHolders ->
        let tag = "635=I"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.LesseeAnd106fEmployees ->
        let tag = "635=L"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ClearingFeeIndicator.AllOtherOwnershipTypes ->
        let tag = "635=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadWorkingIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    WorkingIndicator.WorkingIndicator tmp


let WriteWorkingIndicator (dest:byte []) (nextFreeIdx:int) (valIn:WorkingIndicator) : int = 
   let tag = "636="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegLastPx valIn =
    let tmp = System.Decimal.Parse valIn
    LegLastPx.LegLastPx tmp


let WriteLegLastPx (dest:byte []) (nextFreeIdx:int) (valIn:LegLastPx) : int = 
   let tag = "637="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPriorityIndicator (fldValIn:string) : PriorityIndicator = 
    match fldValIn with
    |"0" -> PriorityIndicator.PriorityUnchanged
    |"1" -> PriorityIndicator.LostPriorityAsResultOfOrderChange
    | x -> failwith (sprintf "ReadPriorityIndicator unknown fix tag: %A"  x) 


let WritePriorityIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:PriorityIndicator) : int =
    match xxIn with
    | PriorityIndicator.PriorityUnchanged ->
        let tag = "638=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PriorityIndicator.LostPriorityAsResultOfOrderChange ->
        let tag = "638=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPriceImprovement valIn =
    let tmp = System.Decimal.Parse valIn
    PriceImprovement.PriceImprovement tmp


let WritePriceImprovement (dest:byte []) (nextFreeIdx:int) (valIn:PriceImprovement) : int = 
   let tag = "639="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPrice2 valIn =
    let tmp = System.Decimal.Parse valIn
    Price2.Price2 tmp


let WritePrice2 (dest:byte []) (nextFreeIdx:int) (valIn:Price2) : int = 
   let tag = "640="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastForwardPoints2 valIn =
    let tmp = System.Decimal.Parse valIn
    LastForwardPoints2.LastForwardPoints2 tmp


let WriteLastForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:LastForwardPoints2) : int = 
   let tag = "641="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBidForwardPoints2 valIn =
    let tmp = System.Decimal.Parse valIn
    BidForwardPoints2.BidForwardPoints2 tmp


let WriteBidForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:BidForwardPoints2) : int = 
   let tag = "642="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOfferForwardPoints2 valIn =
    let tmp = System.Decimal.Parse valIn
    OfferForwardPoints2.OfferForwardPoints2 tmp


let WriteOfferForwardPoints2 (dest:byte []) (nextFreeIdx:int) (valIn:OfferForwardPoints2) : int = 
   let tag = "643="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRFQReqID valIn =
    let tmp =  valIn
    RFQReqID.RFQReqID tmp


let WriteRFQReqID (dest:byte []) (nextFreeIdx:int) (valIn:RFQReqID) : int = 
   let tag = "644="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMktBidPx valIn =
    let tmp = System.Decimal.Parse valIn
    MktBidPx.MktBidPx tmp


let WriteMktBidPx (dest:byte []) (nextFreeIdx:int) (valIn:MktBidPx) : int = 
   let tag = "645="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMktOfferPx valIn =
    let tmp = System.Decimal.Parse valIn
    MktOfferPx.MktOfferPx tmp


let WriteMktOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:MktOfferPx) : int = 
   let tag = "646="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMinBidSize valIn =
    let tmp = System.Decimal.Parse valIn
    MinBidSize.MinBidSize tmp


let WriteMinBidSize (dest:byte []) (nextFreeIdx:int) (valIn:MinBidSize) : int = 
   let tag = "647="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMinOfferSize valIn =
    let tmp = System.Decimal.Parse valIn
    MinOfferSize.MinOfferSize tmp


let WriteMinOfferSize (dest:byte []) (nextFreeIdx:int) (valIn:MinOfferSize) : int = 
   let tag = "648="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteStatusReqID valIn =
    let tmp =  valIn
    QuoteStatusReqID.QuoteStatusReqID tmp


let WriteQuoteStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteStatusReqID) : int = 
   let tag = "649="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegalConfirm valIn =
    let tmp = System.Boolean.Parse valIn
    LegalConfirm.LegalConfirm tmp


let WriteLegalConfirm (dest:byte []) (nextFreeIdx:int) (valIn:LegalConfirm) : int = 
   let tag = "650="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingLastPx valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingLastPx.UnderlyingLastPx tmp


let WriteUnderlyingLastPx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLastPx) : int = 
   let tag = "651="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingLastQty valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingLastQty.UnderlyingLastQty tmp


let WriteUnderlyingLastQty (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingLastQty) : int = 
   let tag = "652="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegRefID valIn =
    let tmp =  valIn
    LegRefID.LegRefID tmp


let WriteLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:LegRefID) : int = 
   let tag = "654="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadContraLegRefID valIn =
    let tmp =  valIn
    ContraLegRefID.ContraLegRefID tmp


let WriteContraLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:ContraLegRefID) : int = 
   let tag = "655="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrBidFxRate valIn =
    let tmp = System.Decimal.Parse valIn
    SettlCurrBidFxRate.SettlCurrBidFxRate tmp


let WriteSettlCurrBidFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrBidFxRate) : int = 
   let tag = "656="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlCurrOfferFxRate valIn =
    let tmp = System.Decimal.Parse valIn
    SettlCurrOfferFxRate.SettlCurrOfferFxRate tmp


let WriteSettlCurrOfferFxRate (dest:byte []) (nextFreeIdx:int) (valIn:SettlCurrOfferFxRate) : int = 
   let tag = "657="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteRequestRejectReason (fldValIn:string) : QuoteRequestRejectReason = 
    match fldValIn with
    |"1" -> QuoteRequestRejectReason.UnknownSymbol
    |"2" -> QuoteRequestRejectReason.ExchangeClosed
    |"3" -> QuoteRequestRejectReason.QuoteRequestExceedsLimit
    |"4" -> QuoteRequestRejectReason.TooLateToEnter
    |"5" -> QuoteRequestRejectReason.InvalidPrice
    |"6" -> QuoteRequestRejectReason.NotAuthorizedToRequestQuote
    |"7" -> QuoteRequestRejectReason.NoMatchForInquiry
    |"8" -> QuoteRequestRejectReason.NoMarketForInstrument
    |"9" -> QuoteRequestRejectReason.NoInventory
    |"10" -> QuoteRequestRejectReason.Pass
    |"99" -> QuoteRequestRejectReason.Other
    | x -> failwith (sprintf "ReadQuoteRequestRejectReason unknown fix tag: %A"  x) 


let WriteQuoteRequestRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRequestRejectReason) : int =
    match xxIn with
    | QuoteRequestRejectReason.UnknownSymbol ->
        let tag = "658=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.ExchangeClosed ->
        let tag = "658=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.QuoteRequestExceedsLimit ->
        let tag = "658=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.TooLateToEnter ->
        let tag = "658=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.InvalidPrice ->
        let tag = "658=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NotAuthorizedToRequestQuote ->
        let tag = "658=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoMatchForInquiry ->
        let tag = "658=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoMarketForInstrument ->
        let tag = "658=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.NoInventory ->
        let tag = "658=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.Pass ->
        let tag = "658=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRequestRejectReason.Other ->
        let tag = "658=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSideComplianceID valIn =
    let tmp =  valIn
    SideComplianceID.SideComplianceID tmp


let WriteSideComplianceID (dest:byte []) (nextFreeIdx:int) (valIn:SideComplianceID) : int = 
   let tag = "659="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAcctIDSource (fldValIn:string) : AcctIDSource = 
    match fldValIn with
    |"1" -> AcctIDSource.Bic
    |"2" -> AcctIDSource.SidCode
    |"3" -> AcctIDSource.Tfm
    |"4" -> AcctIDSource.Omgeo
    |"5" -> AcctIDSource.DtccCode
    |"99" -> AcctIDSource.Other
    | x -> failwith (sprintf "ReadAcctIDSource unknown fix tag: %A"  x) 


let WriteAcctIDSource (dest:byte array) (nextFreeIdx:int) (xxIn:AcctIDSource) : int =
    match xxIn with
    | AcctIDSource.Bic ->
        let tag = "660=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.SidCode ->
        let tag = "660=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Tfm ->
        let tag = "660=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Omgeo ->
        let tag = "660=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.DtccCode ->
        let tag = "660=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AcctIDSource.Other ->
        let tag = "660=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocAcctIDSource valIn =
    let tmp = System.Int32.Parse valIn
    AllocAcctIDSource.AllocAcctIDSource tmp


let WriteAllocAcctIDSource (dest:byte []) (nextFreeIdx:int) (valIn:AllocAcctIDSource) : int = 
   let tag = "661="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkPrice valIn =
    let tmp = System.Decimal.Parse valIn
    BenchmarkPrice.BenchmarkPrice tmp


let WriteBenchmarkPrice (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkPrice) : int = 
   let tag = "662="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkPriceType valIn =
    let tmp = System.Int32.Parse valIn
    BenchmarkPriceType.BenchmarkPriceType tmp


let WriteBenchmarkPriceType (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkPriceType) : int = 
   let tag = "663="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConfirmID valIn =
    let tmp =  valIn
    ConfirmID.ConfirmID tmp


let WriteConfirmID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmID) : int = 
   let tag = "664="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConfirmStatus (fldValIn:string) : ConfirmStatus = 
    match fldValIn with
    |"1" -> ConfirmStatus.Received
    |"2" -> ConfirmStatus.MismatchedAccount
    |"3" -> ConfirmStatus.MissingSettlementInstructions
    |"4" -> ConfirmStatus.Confirmed
    |"5" -> ConfirmStatus.RequestRejected
    | x -> failwith (sprintf "ReadConfirmStatus unknown fix tag: %A"  x) 


let WriteConfirmStatus (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmStatus) : int =
    match xxIn with
    | ConfirmStatus.Received ->
        let tag = "665=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.MismatchedAccount ->
        let tag = "665=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.MissingSettlementInstructions ->
        let tag = "665=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.Confirmed ->
        let tag = "665=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmStatus.RequestRejected ->
        let tag = "665=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadConfirmTransType (fldValIn:string) : ConfirmTransType = 
    match fldValIn with
    |"0" -> ConfirmTransType.New
    |"1" -> ConfirmTransType.Replace
    |"2" -> ConfirmTransType.Cancel
    | x -> failwith (sprintf "ReadConfirmTransType unknown fix tag: %A"  x) 


let WriteConfirmTransType (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmTransType) : int =
    match xxIn with
    | ConfirmTransType.New ->
        let tag = "666=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmTransType.Replace ->
        let tag = "666=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmTransType.Cancel ->
        let tag = "666=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContractSettlMonth valIn =
    let tmp =  valIn
    ContractSettlMonth.ContractSettlMonth tmp


let WriteContractSettlMonth (dest:byte []) (nextFreeIdx:int) (valIn:ContractSettlMonth) : int = 
   let tag = "667="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeliveryForm (fldValIn:string) : DeliveryForm = 
    match fldValIn with
    |"1" -> DeliveryForm.Bookentry
    |"2" -> DeliveryForm.Bearer
    | x -> failwith (sprintf "ReadDeliveryForm unknown fix tag: %A"  x) 


let WriteDeliveryForm (dest:byte array) (nextFreeIdx:int) (xxIn:DeliveryForm) : int =
    match xxIn with
    | DeliveryForm.Bookentry ->
        let tag = "668=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryForm.Bearer ->
        let tag = "668=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLastParPx valIn =
    let tmp = System.Decimal.Parse valIn
    LastParPx.LastParPx tmp


let WriteLastParPx (dest:byte []) (nextFreeIdx:int) (valIn:LastParPx) : int = 
   let tag = "669="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoLegAllocs valIn =
    let tmp = System.Int32.Parse valIn
    NoLegAllocs.NoLegAllocs tmp


let WriteNoLegAllocs (dest:byte []) (nextFreeIdx:int) (valIn:NoLegAllocs) : int = 
   let tag = "670="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegAllocAccount valIn =
    let tmp =  valIn
    LegAllocAccount.LegAllocAccount tmp


let WriteLegAllocAccount (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocAccount) : int = 
   let tag = "671="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegIndividualAllocID valIn =
    let tmp =  valIn
    LegIndividualAllocID.LegIndividualAllocID tmp


let WriteLegIndividualAllocID (dest:byte []) (nextFreeIdx:int) (valIn:LegIndividualAllocID) : int = 
   let tag = "672="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegAllocQty valIn =
    let tmp = System.Decimal.Parse valIn
    LegAllocQty.LegAllocQty tmp


let WriteLegAllocQty (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocQty) : int = 
   let tag = "673="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegAllocAcctIDSource valIn =
    let tmp =  valIn
    LegAllocAcctIDSource.LegAllocAcctIDSource tmp


let WriteLegAllocAcctIDSource (dest:byte []) (nextFreeIdx:int) (valIn:LegAllocAcctIDSource) : int = 
   let tag = "674="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSettlCurrency valIn =
    let tmp =  valIn
    LegSettlCurrency.LegSettlCurrency tmp


let WriteLegSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegSettlCurrency) : int = 
   let tag = "675="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurveCurrency valIn =
    let tmp =  valIn
    LegBenchmarkCurveCurrency.LegBenchmarkCurveCurrency tmp


let WriteLegBenchmarkCurveCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurveCurrency) : int = 
   let tag = "676="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurveName valIn =
    let tmp =  valIn
    LegBenchmarkCurveName.LegBenchmarkCurveName tmp


let WriteLegBenchmarkCurveName (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurveName) : int = 
   let tag = "677="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBenchmarkCurvePoint valIn =
    let tmp =  valIn
    LegBenchmarkCurvePoint.LegBenchmarkCurvePoint tmp


let WriteLegBenchmarkCurvePoint (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkCurvePoint) : int = 
   let tag = "678="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBenchmarkPrice valIn =
    let tmp = System.Decimal.Parse valIn
    LegBenchmarkPrice.LegBenchmarkPrice tmp


let WriteLegBenchmarkPrice (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkPrice) : int = 
   let tag = "679="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBenchmarkPriceType valIn =
    let tmp = System.Int32.Parse valIn
    LegBenchmarkPriceType.LegBenchmarkPriceType tmp


let WriteLegBenchmarkPriceType (dest:byte []) (nextFreeIdx:int) (valIn:LegBenchmarkPriceType) : int = 
   let tag = "680="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegBidPx valIn =
    let tmp = System.Decimal.Parse valIn
    LegBidPx.LegBidPx tmp


let WriteLegBidPx (dest:byte []) (nextFreeIdx:int) (valIn:LegBidPx) : int = 
   let tag = "681="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegIOIQty valIn =
    let tmp =  valIn
    LegIOIQty.LegIOIQty tmp


let WriteLegIOIQty (dest:byte []) (nextFreeIdx:int) (valIn:LegIOIQty) : int = 
   let tag = "682="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoLegStipulations valIn =
    let tmp = System.Int32.Parse valIn
    NoLegStipulations.NoLegStipulations tmp


let WriteNoLegStipulations (dest:byte []) (nextFreeIdx:int) (valIn:NoLegStipulations) : int = 
   let tag = "683="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegOfferPx valIn =
    let tmp = System.Decimal.Parse valIn
    LegOfferPx.LegOfferPx tmp


let WriteLegOfferPx (dest:byte []) (nextFreeIdx:int) (valIn:LegOfferPx) : int = 
   let tag = "684="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegOrderQty valIn =
    let tmp = System.Decimal.Parse valIn
    LegOrderQty.LegOrderQty tmp


let WriteLegOrderQty (dest:byte []) (nextFreeIdx:int) (valIn:LegOrderQty) : int = 
   let tag = "685="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegPriceType valIn =
    let tmp = System.Int32.Parse valIn
    LegPriceType.LegPriceType tmp


let WriteLegPriceType (dest:byte []) (nextFreeIdx:int) (valIn:LegPriceType) : int = 
   let tag = "686="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegQty valIn =
    let tmp = System.Decimal.Parse valIn
    LegQty.LegQty tmp


let WriteLegQty (dest:byte []) (nextFreeIdx:int) (valIn:LegQty) : int = 
   let tag = "687="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegStipulationType valIn =
    let tmp =  valIn
    LegStipulationType.LegStipulationType tmp


let WriteLegStipulationType (dest:byte []) (nextFreeIdx:int) (valIn:LegStipulationType) : int = 
   let tag = "688="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegStipulationValue valIn =
    let tmp =  valIn
    LegStipulationValue.LegStipulationValue tmp


let WriteLegStipulationValue (dest:byte []) (nextFreeIdx:int) (valIn:LegStipulationValue) : int = 
   let tag = "689="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSwapType (fldValIn:string) : LegSwapType = 
    match fldValIn with
    |"1" -> LegSwapType.ParForPar
    |"2" -> LegSwapType.ModifiedDuration
    |"4" -> LegSwapType.Risk
    |"5" -> LegSwapType.Proceeds
    | x -> failwith (sprintf "ReadLegSwapType unknown fix tag: %A"  x) 


let WriteLegSwapType (dest:byte array) (nextFreeIdx:int) (xxIn:LegSwapType) : int =
    match xxIn with
    | LegSwapType.ParForPar ->
        let tag = "690=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.ModifiedDuration ->
        let tag = "690=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.Risk ->
        let tag = "690=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LegSwapType.Proceeds ->
        let tag = "690=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPool valIn =
    let tmp =  valIn
    Pool.Pool tmp


let WritePool (dest:byte []) (nextFreeIdx:int) (valIn:Pool) : int = 
   let tag = "691="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuotePriceType (fldValIn:string) : QuotePriceType = 
    match fldValIn with
    |"1" -> QuotePriceType.Percent
    |"2" -> QuotePriceType.PerShare
    |"3" -> QuotePriceType.FixedAmount
    |"4" -> QuotePriceType.Discount
    |"5" -> QuotePriceType.Premium
    |"6" -> QuotePriceType.BasisPointsRelativeToBenchmark
    |"7" -> QuotePriceType.TedPrice
    |"8" -> QuotePriceType.TedYield
    |"9" -> QuotePriceType.YieldSpread
    |"10" -> QuotePriceType.Yield
    | x -> failwith (sprintf "ReadQuotePriceType unknown fix tag: %A"  x) 


let WriteQuotePriceType (dest:byte array) (nextFreeIdx:int) (xxIn:QuotePriceType) : int =
    match xxIn with
    | QuotePriceType.Percent ->
        let tag = "692=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.PerShare ->
        let tag = "692=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.FixedAmount ->
        let tag = "692=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Discount ->
        let tag = "692=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Premium ->
        let tag = "692=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.BasisPointsRelativeToBenchmark ->
        let tag = "692=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.TedPrice ->
        let tag = "692=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.TedYield ->
        let tag = "692=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.YieldSpread ->
        let tag = "692=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuotePriceType.Yield ->
        let tag = "692=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteRespID valIn =
    let tmp =  valIn
    QuoteRespID.QuoteRespID tmp


let WriteQuoteRespID (dest:byte []) (nextFreeIdx:int) (valIn:QuoteRespID) : int = 
   let tag = "693="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadQuoteRespType (fldValIn:string) : QuoteRespType = 
    match fldValIn with
    |"1" -> QuoteRespType.HitLift
    |"2" -> QuoteRespType.Counter
    |"3" -> QuoteRespType.Expired
    |"4" -> QuoteRespType.Cover
    |"5" -> QuoteRespType.DoneAway
    |"6" -> QuoteRespType.Pass
    | x -> failwith (sprintf "ReadQuoteRespType unknown fix tag: %A"  x) 


let WriteQuoteRespType (dest:byte array) (nextFreeIdx:int) (xxIn:QuoteRespType) : int =
    match xxIn with
    | QuoteRespType.HitLift ->
        let tag = "694=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Counter ->
        let tag = "694=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Expired ->
        let tag = "694=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Cover ->
        let tag = "694=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.DoneAway ->
        let tag = "694=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QuoteRespType.Pass ->
        let tag = "694=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQuoteQualifier valIn =
    let tmp = System.Int32.Parse valIn
    QuoteQualifier.QuoteQualifier tmp


let WriteQuoteQualifier (dest:byte []) (nextFreeIdx:int) (valIn:QuoteQualifier) : int = 
   let tag = "695="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadYieldRedemptionDate valIn =
    let tmp =  valIn
    YieldRedemptionDate.YieldRedemptionDate tmp


let WriteYieldRedemptionDate (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionDate) : int = 
   let tag = "696="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadYieldRedemptionPrice valIn =
    let tmp = System.Decimal.Parse valIn
    YieldRedemptionPrice.YieldRedemptionPrice tmp


let WriteYieldRedemptionPrice (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionPrice) : int = 
   let tag = "697="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadYieldRedemptionPriceType valIn =
    let tmp = System.Int32.Parse valIn
    YieldRedemptionPriceType.YieldRedemptionPriceType tmp


let WriteYieldRedemptionPriceType (dest:byte []) (nextFreeIdx:int) (valIn:YieldRedemptionPriceType) : int = 
   let tag = "698="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkSecurityID valIn =
    let tmp =  valIn
    BenchmarkSecurityID.BenchmarkSecurityID tmp


let WriteBenchmarkSecurityID (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkSecurityID) : int = 
   let tag = "699="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadReversalIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    ReversalIndicator.ReversalIndicator tmp


let WriteReversalIndicator (dest:byte []) (nextFreeIdx:int) (valIn:ReversalIndicator) : int = 
   let tag = "700="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadYieldCalcDate valIn =
    let tmp =  valIn
    YieldCalcDate.YieldCalcDate tmp


let WriteYieldCalcDate (dest:byte []) (nextFreeIdx:int) (valIn:YieldCalcDate) : int = 
   let tag = "701="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoPositions valIn =
    let tmp = System.Int32.Parse valIn
    NoPositions.NoPositions tmp


let WriteNoPositions (dest:byte []) (nextFreeIdx:int) (valIn:NoPositions) : int = 
   let tag = "702="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosType (fldValIn:string) : PosType = 
    match fldValIn with
    |"TQ" -> PosType.TransactionQuantity
    |"IAS" -> PosType.IntraSpreadQty
    |"IES" -> PosType.InterSpreadQty
    |"FIN" -> PosType.EndOfDayQty
    |"SOD" -> PosType.StartOfDayQty
    |"EX" -> PosType.OptionExerciseQty
    |"AS" -> PosType.OptionAssignment
    |"TX" -> PosType.TransactionFromExercise
    |"TA" -> PosType.TransactionFromAssignment
    |"PIT" -> PosType.PitTradeQty
    |"TRF" -> PosType.TransferTradeQty
    |"ETR" -> PosType.ElectronicTradeQty
    |"ALC" -> PosType.AllocationTradeQty
    |"PA" -> PosType.AdjustmentQty
    |"ASF" -> PosType.AsOfTradeQty
    |"DLV" -> PosType.DeliveryQty
    |"TOT" -> PosType.TotalTransactionQty
    |"XM" -> PosType.CrossMarginQty
    |"SPL" -> PosType.IntegralSplit
    | x -> failwith (sprintf "ReadPosType unknown fix tag: %A"  x) 


let WritePosType (dest:byte array) (nextFreeIdx:int) (xxIn:PosType) : int =
    match xxIn with
    | PosType.TransactionQuantity ->
        let tag = "703=TQ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.IntraSpreadQty ->
        let tag = "703=IAS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.InterSpreadQty ->
        let tag = "703=IES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.EndOfDayQty ->
        let tag = "703=FIN"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.StartOfDayQty ->
        let tag = "703=SOD"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.OptionExerciseQty ->
        let tag = "703=EX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.OptionAssignment ->
        let tag = "703=AS"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransactionFromExercise ->
        let tag = "703=TX"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransactionFromAssignment ->
        let tag = "703=TA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.PitTradeQty ->
        let tag = "703=PIT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TransferTradeQty ->
        let tag = "703=TRF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.ElectronicTradeQty ->
        let tag = "703=ETR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AllocationTradeQty ->
        let tag = "703=ALC"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AdjustmentQty ->
        let tag = "703=PA"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.AsOfTradeQty ->
        let tag = "703=ASF"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.DeliveryQty ->
        let tag = "703=DLV"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.TotalTransactionQty ->
        let tag = "703=TOT"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.CrossMarginQty ->
        let tag = "703=XM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosType.IntegralSplit ->
        let tag = "703=SPL"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadLongQty valIn =
    let tmp = System.Decimal.Parse valIn
    LongQty.LongQty tmp


let WriteLongQty (dest:byte []) (nextFreeIdx:int) (valIn:LongQty) : int = 
   let tag = "704="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadShortQty valIn =
    let tmp = System.Decimal.Parse valIn
    ShortQty.ShortQty tmp


let WriteShortQty (dest:byte []) (nextFreeIdx:int) (valIn:ShortQty) : int = 
   let tag = "705="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosQtyStatus (fldValIn:string) : PosQtyStatus = 
    match fldValIn with
    |"0" -> PosQtyStatus.Submitted
    |"1" -> PosQtyStatus.Accepted
    |"2" -> PosQtyStatus.Rejected
    | x -> failwith (sprintf "ReadPosQtyStatus unknown fix tag: %A"  x) 


let WritePosQtyStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosQtyStatus) : int =
    match xxIn with
    | PosQtyStatus.Submitted ->
        let tag = "706=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosQtyStatus.Accepted ->
        let tag = "706=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosQtyStatus.Rejected ->
        let tag = "706=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosAmtType (fldValIn:string) : PosAmtType = 
    match fldValIn with
    |"FMTM" -> PosAmtType.FinalMarkToMarketAmount
    |"IMTM" -> PosAmtType.IncrementalMarkToMarketAmount
    |"TVAR" -> PosAmtType.TradeVariationAmount
    |"SMTM" -> PosAmtType.StartOfDayMarkToMarketAmount
    |"PREM" -> PosAmtType.PremiumAmount
    |"CRES" -> PosAmtType.CashResidualAmount
    |"CASH" -> PosAmtType.CashAmount
    |"VADJ" -> PosAmtType.ValueAdjustedAmount
    | x -> failwith (sprintf "ReadPosAmtType unknown fix tag: %A"  x) 


let WritePosAmtType (dest:byte array) (nextFreeIdx:int) (xxIn:PosAmtType) : int =
    match xxIn with
    | PosAmtType.FinalMarkToMarketAmount ->
        let tag = "707=FMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.IncrementalMarkToMarketAmount ->
        let tag = "707=IMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.TradeVariationAmount ->
        let tag = "707=TVAR"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.StartOfDayMarkToMarketAmount ->
        let tag = "707=SMTM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.PremiumAmount ->
        let tag = "707=PREM"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.CashResidualAmount ->
        let tag = "707=CRES"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.CashAmount ->
        let tag = "707=CASH"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosAmtType.ValueAdjustedAmount ->
        let tag = "707=VADJ"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosAmt valIn =
    let tmp = System.Int32.Parse valIn
    PosAmt.PosAmt tmp


let WritePosAmt (dest:byte []) (nextFreeIdx:int) (valIn:PosAmt) : int = 
   let tag = "708="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosTransType (fldValIn:string) : PosTransType = 
    match fldValIn with
    |"1" -> PosTransType.Exercise
    |"2" -> PosTransType.DoNotExercise
    |"3" -> PosTransType.PositionAdjustment
    |"4" -> PosTransType.PositionChangeSubmissionMarginDisposition
    |"5" -> PosTransType.Pledge
    | x -> failwith (sprintf "ReadPosTransType unknown fix tag: %A"  x) 


let WritePosTransType (dest:byte array) (nextFreeIdx:int) (xxIn:PosTransType) : int =
    match xxIn with
    | PosTransType.Exercise ->
        let tag = "709=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.DoNotExercise ->
        let tag = "709=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.PositionAdjustment ->
        let tag = "709=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.PositionChangeSubmissionMarginDisposition ->
        let tag = "709=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosTransType.Pledge ->
        let tag = "709=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqID valIn =
    let tmp =  valIn
    PosReqID.PosReqID tmp


let WritePosReqID (dest:byte []) (nextFreeIdx:int) (valIn:PosReqID) : int = 
   let tag = "710="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoUnderlyings valIn =
    let tmp = System.Int32.Parse valIn
    NoUnderlyings.NoUnderlyings tmp


let WriteNoUnderlyings (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyings) : int = 
   let tag = "711="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosMaintAction (fldValIn:string) : PosMaintAction = 
    match fldValIn with
    |"1" -> PosMaintAction.New
    |"2" -> PosMaintAction.Replace
    |"3" -> PosMaintAction.Cancel
    | x -> failwith (sprintf "ReadPosMaintAction unknown fix tag: %A"  x) 


let WritePosMaintAction (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintAction) : int =
    match xxIn with
    | PosMaintAction.New ->
        let tag = "712=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintAction.Replace ->
        let tag = "712=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintAction.Cancel ->
        let tag = "712=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrigPosReqRefID valIn =
    let tmp =  valIn
    OrigPosReqRefID.OrigPosReqRefID tmp


let WriteOrigPosReqRefID (dest:byte []) (nextFreeIdx:int) (valIn:OrigPosReqRefID) : int = 
   let tag = "713="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosMaintRptRefID valIn =
    let tmp =  valIn
    PosMaintRptRefID.PosMaintRptRefID tmp


let WritePosMaintRptRefID (dest:byte []) (nextFreeIdx:int) (valIn:PosMaintRptRefID) : int = 
   let tag = "714="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadClearingBusinessDate valIn =
    let tmp =  valIn
    ClearingBusinessDate.ClearingBusinessDate tmp


let WriteClearingBusinessDate (dest:byte []) (nextFreeIdx:int) (valIn:ClearingBusinessDate) : int = 
   let tag = "715="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlSessID valIn =
    let tmp =  valIn
    SettlSessID.SettlSessID tmp


let WriteSettlSessID (dest:byte []) (nextFreeIdx:int) (valIn:SettlSessID) : int = 
   let tag = "716="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlSessSubID valIn =
    let tmp =  valIn
    SettlSessSubID.SettlSessSubID tmp


let WriteSettlSessSubID (dest:byte []) (nextFreeIdx:int) (valIn:SettlSessSubID) : int = 
   let tag = "717="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAdjustmentType (fldValIn:string) : AdjustmentType = 
    match fldValIn with
    |"0" -> AdjustmentType.ProcessRequestAsMarginDisposition
    |"1" -> AdjustmentType.DeltaPlus
    |"2" -> AdjustmentType.DeltaMinus
    |"3" -> AdjustmentType.Final
    | x -> failwith (sprintf "ReadAdjustmentType unknown fix tag: %A"  x) 


let WriteAdjustmentType (dest:byte array) (nextFreeIdx:int) (xxIn:AdjustmentType) : int =
    match xxIn with
    | AdjustmentType.ProcessRequestAsMarginDisposition ->
        let tag = "718=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.DeltaPlus ->
        let tag = "718=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.DeltaMinus ->
        let tag = "718=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AdjustmentType.Final ->
        let tag = "718=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadContraryInstructionIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    ContraryInstructionIndicator.ContraryInstructionIndicator tmp


let WriteContraryInstructionIndicator (dest:byte []) (nextFreeIdx:int) (valIn:ContraryInstructionIndicator) : int = 
   let tag = "719="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPriorSpreadIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    PriorSpreadIndicator.PriorSpreadIndicator tmp


let WritePriorSpreadIndicator (dest:byte []) (nextFreeIdx:int) (valIn:PriorSpreadIndicator) : int = 
   let tag = "720="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosMaintRptID valIn =
    let tmp =  valIn
    PosMaintRptID.PosMaintRptID tmp


let WritePosMaintRptID (dest:byte []) (nextFreeIdx:int) (valIn:PosMaintRptID) : int = 
   let tag = "721="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosMaintStatus (fldValIn:string) : PosMaintStatus = 
    match fldValIn with
    |"0" -> PosMaintStatus.Accepted
    |"1" -> PosMaintStatus.AcceptedWithWarnings
    |"2" -> PosMaintStatus.Rejected
    |"3" -> PosMaintStatus.Completed
    |"4" -> PosMaintStatus.CompletedWithWarnings
    | x -> failwith (sprintf "ReadPosMaintStatus unknown fix tag: %A"  x) 


let WritePosMaintStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintStatus) : int =
    match xxIn with
    | PosMaintStatus.Accepted ->
        let tag = "722=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.AcceptedWithWarnings ->
        let tag = "722=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.Rejected ->
        let tag = "722=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.Completed ->
        let tag = "722=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintStatus.CompletedWithWarnings ->
        let tag = "722=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosMaintResult (fldValIn:string) : PosMaintResult = 
    match fldValIn with
    |"0" -> PosMaintResult.SuccessfulCompletionNoWarningsOrErrors
    |"1" -> PosMaintResult.Rejected
    |"99" -> PosMaintResult.Other
    | x -> failwith (sprintf "ReadPosMaintResult unknown fix tag: %A"  x) 


let WritePosMaintResult (dest:byte array) (nextFreeIdx:int) (xxIn:PosMaintResult) : int =
    match xxIn with
    | PosMaintResult.SuccessfulCompletionNoWarningsOrErrors ->
        let tag = "723=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintResult.Rejected ->
        let tag = "723=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosMaintResult.Other ->
        let tag = "723=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqType (fldValIn:string) : PosReqType = 
    match fldValIn with
    |"0" -> PosReqType.Positions
    |"1" -> PosReqType.Trades
    |"2" -> PosReqType.Exercises
    |"3" -> PosReqType.Assignments
    | x -> failwith (sprintf "ReadPosReqType unknown fix tag: %A"  x) 


let WritePosReqType (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqType) : int =
    match xxIn with
    | PosReqType.Positions ->
        let tag = "724=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Trades ->
        let tag = "724=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Exercises ->
        let tag = "724=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqType.Assignments ->
        let tag = "724=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadResponseTransportType (fldValIn:string) : ResponseTransportType = 
    match fldValIn with
    |"0" -> ResponseTransportType.Inband
    |"1" -> ResponseTransportType.OutOfBand
    | x -> failwith (sprintf "ReadResponseTransportType unknown fix tag: %A"  x) 


let WriteResponseTransportType (dest:byte array) (nextFreeIdx:int) (xxIn:ResponseTransportType) : int =
    match xxIn with
    | ResponseTransportType.Inband ->
        let tag = "725=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ResponseTransportType.OutOfBand ->
        let tag = "725=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadResponseDestination valIn =
    let tmp =  valIn
    ResponseDestination.ResponseDestination tmp


let WriteResponseDestination (dest:byte []) (nextFreeIdx:int) (valIn:ResponseDestination) : int = 
   let tag = "726="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotalNumPosReports valIn =
    let tmp = System.Int32.Parse valIn
    TotalNumPosReports.TotalNumPosReports tmp


let WriteTotalNumPosReports (dest:byte []) (nextFreeIdx:int) (valIn:TotalNumPosReports) : int = 
   let tag = "727="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPosReqResult (fldValIn:string) : PosReqResult = 
    match fldValIn with
    |"0" -> PosReqResult.ValidRequest
    |"1" -> PosReqResult.InvalidOrUnsupportedRequest
    |"2" -> PosReqResult.NoPositionsFoundThatMatchCriteria
    |"3" -> PosReqResult.NotAuthorizedToRequestPositions
    |"4" -> PosReqResult.RequestForPositionNotSupported
    |"99" -> PosReqResult.Other
    | x -> failwith (sprintf "ReadPosReqResult unknown fix tag: %A"  x) 


let WritePosReqResult (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqResult) : int =
    match xxIn with
    | PosReqResult.ValidRequest ->
        let tag = "728=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.InvalidOrUnsupportedRequest ->
        let tag = "728=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.NoPositionsFoundThatMatchCriteria ->
        let tag = "728=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.NotAuthorizedToRequestPositions ->
        let tag = "728=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.RequestForPositionNotSupported ->
        let tag = "728=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqResult.Other ->
        let tag = "728=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPosReqStatus (fldValIn:string) : PosReqStatus = 
    match fldValIn with
    |"0" -> PosReqStatus.Completed
    |"1" -> PosReqStatus.CompletedWithWarnings
    |"2" -> PosReqStatus.Rejected
    | x -> failwith (sprintf "ReadPosReqStatus unknown fix tag: %A"  x) 


let WritePosReqStatus (dest:byte array) (nextFreeIdx:int) (xxIn:PosReqStatus) : int =
    match xxIn with
    | PosReqStatus.Completed ->
        let tag = "729=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqStatus.CompletedWithWarnings ->
        let tag = "729=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PosReqStatus.Rejected ->
        let tag = "729=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSettlPrice valIn =
    let tmp = System.Decimal.Parse valIn
    SettlPrice.SettlPrice tmp


let WriteSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:SettlPrice) : int = 
   let tag = "730="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPriceType (fldValIn:string) : SettlPriceType = 
    match fldValIn with
    |"1" -> SettlPriceType.Final
    |"2" -> SettlPriceType.Theoretical
    | x -> failwith (sprintf "ReadSettlPriceType unknown fix tag: %A"  x) 


let WriteSettlPriceType (dest:byte array) (nextFreeIdx:int) (xxIn:SettlPriceType) : int =
    match xxIn with
    | SettlPriceType.Final ->
        let tag = "731=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlPriceType.Theoretical ->
        let tag = "731=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingSettlPrice valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingSettlPrice.UnderlyingSettlPrice tmp


let WriteUnderlyingSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSettlPrice) : int = 
   let tag = "732="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSettlPriceType valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingSettlPriceType.UnderlyingSettlPriceType tmp


let WriteUnderlyingSettlPriceType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSettlPriceType) : int = 
   let tag = "733="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPriorSettlPrice valIn =
    let tmp = System.Decimal.Parse valIn
    PriorSettlPrice.PriorSettlPrice tmp


let WritePriorSettlPrice (dest:byte []) (nextFreeIdx:int) (valIn:PriorSettlPrice) : int = 
   let tag = "734="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoQuoteQualifiers valIn =
    let tmp = System.Int32.Parse valIn
    NoQuoteQualifiers.NoQuoteQualifiers tmp


let WriteNoQuoteQualifiers (dest:byte []) (nextFreeIdx:int) (valIn:NoQuoteQualifiers) : int = 
   let tag = "735="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocSettlCurrency valIn =
    let tmp =  valIn
    AllocSettlCurrency.AllocSettlCurrency tmp


let WriteAllocSettlCurrency (dest:byte []) (nextFreeIdx:int) (valIn:AllocSettlCurrency) : int = 
   let tag = "736="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocSettlCurrAmt valIn =
    let tmp = System.Int32.Parse valIn
    AllocSettlCurrAmt.AllocSettlCurrAmt tmp


let WriteAllocSettlCurrAmt (dest:byte []) (nextFreeIdx:int) (valIn:AllocSettlCurrAmt) : int = 
   let tag = "737="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadInterestAtMaturity valIn =
    let tmp = System.Int32.Parse valIn
    InterestAtMaturity.InterestAtMaturity tmp


let WriteInterestAtMaturity (dest:byte []) (nextFreeIdx:int) (valIn:InterestAtMaturity) : int = 
   let tag = "738="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegDatedDate valIn =
    let tmp =  valIn
    LegDatedDate.LegDatedDate tmp


let WriteLegDatedDate (dest:byte []) (nextFreeIdx:int) (valIn:LegDatedDate) : int = 
   let tag = "739="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegPool valIn =
    let tmp =  valIn
    LegPool.LegPool tmp


let WriteLegPool (dest:byte []) (nextFreeIdx:int) (valIn:LegPool) : int = 
   let tag = "740="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocInterestAtMaturity valIn =
    let tmp = System.Int32.Parse valIn
    AllocInterestAtMaturity.AllocInterestAtMaturity tmp


let WriteAllocInterestAtMaturity (dest:byte []) (nextFreeIdx:int) (valIn:AllocInterestAtMaturity) : int = 
   let tag = "741="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocAccruedInterestAmt valIn =
    let tmp = System.Int32.Parse valIn
    AllocAccruedInterestAmt.AllocAccruedInterestAmt tmp


let WriteAllocAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:AllocAccruedInterestAmt) : int = 
   let tag = "742="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeliveryDate valIn =
    let tmp =  valIn
    DeliveryDate.DeliveryDate tmp


let WriteDeliveryDate (dest:byte []) (nextFreeIdx:int) (valIn:DeliveryDate) : int = 
   let tag = "743="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAssignmentMethod (fldValIn:string) : AssignmentMethod = 
    match fldValIn with
    |"R" -> AssignmentMethod.Random
    |"P" -> AssignmentMethod.Prorata
    | x -> failwith (sprintf "ReadAssignmentMethod unknown fix tag: %A"  x) 


let WriteAssignmentMethod (dest:byte array) (nextFreeIdx:int) (xxIn:AssignmentMethod) : int =
    match xxIn with
    | AssignmentMethod.Random ->
        let tag = "744=R"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AssignmentMethod.Prorata ->
        let tag = "744=P"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAssignmentUnit valIn =
    let tmp = System.Decimal.Parse valIn
    AssignmentUnit.AssignmentUnit tmp


let WriteAssignmentUnit (dest:byte []) (nextFreeIdx:int) (valIn:AssignmentUnit) : int = 
   let tag = "745="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOpenInterest valIn =
    let tmp = System.Int32.Parse valIn
    OpenInterest.OpenInterest tmp


let WriteOpenInterest (dest:byte []) (nextFreeIdx:int) (valIn:OpenInterest) : int = 
   let tag = "746="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExerciseMethod (fldValIn:string) : ExerciseMethod = 
    match fldValIn with
    |"A" -> ExerciseMethod.Automatic
    |"M" -> ExerciseMethod.Manual
    | x -> failwith (sprintf "ReadExerciseMethod unknown fix tag: %A"  x) 


let WriteExerciseMethod (dest:byte array) (nextFreeIdx:int) (xxIn:ExerciseMethod) : int =
    match xxIn with
    | ExerciseMethod.Automatic ->
        let tag = "747=A"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExerciseMethod.Manual ->
        let tag = "747=M"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNumTradeReports valIn =
    let tmp = System.Int32.Parse valIn
    TotNumTradeReports.TotNumTradeReports tmp


let WriteTotNumTradeReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumTradeReports) : int = 
   let tag = "748="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeRequestResult (fldValIn:string) : TradeRequestResult = 
    match fldValIn with
    |"0" -> TradeRequestResult.Successful
    |"1" -> TradeRequestResult.InvalidOrUnknownInstrument
    |"2" -> TradeRequestResult.InvalidTypeOfTradeRequested
    |"3" -> TradeRequestResult.InvalidParties
    |"4" -> TradeRequestResult.InvalidTransportTypeRequested
    |"5" -> TradeRequestResult.InvalidDestinationRequested
    |"8" -> TradeRequestResult.TraderequesttypeNotSupported
    |"9" -> TradeRequestResult.UnauthorizedForTradeCaptureReportRequest
    |"10" -> TradeRequestResult.Yield
    | x -> failwith (sprintf "ReadTradeRequestResult unknown fix tag: %A"  x) 


let WriteTradeRequestResult (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestResult) : int =
    match xxIn with
    | TradeRequestResult.Successful ->
        let tag = "749=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidOrUnknownInstrument ->
        let tag = "749=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidTypeOfTradeRequested ->
        let tag = "749=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidParties ->
        let tag = "749=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidTransportTypeRequested ->
        let tag = "749=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.InvalidDestinationRequested ->
        let tag = "749=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.TraderequesttypeNotSupported ->
        let tag = "749=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.UnauthorizedForTradeCaptureReportRequest ->
        let tag = "749=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestResult.Yield ->
        let tag = "749=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeRequestStatus (fldValIn:string) : TradeRequestStatus = 
    match fldValIn with
    |"0" -> TradeRequestStatus.Accepted
    |"1" -> TradeRequestStatus.Completed
    |"2" -> TradeRequestStatus.Rejected
    | x -> failwith (sprintf "ReadTradeRequestStatus unknown fix tag: %A"  x) 


let WriteTradeRequestStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TradeRequestStatus) : int =
    match xxIn with
    | TradeRequestStatus.Accepted ->
        let tag = "750=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestStatus.Completed ->
        let tag = "750=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeRequestStatus.Rejected ->
        let tag = "750=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeReportRejectReason (fldValIn:string) : TradeReportRejectReason = 
    match fldValIn with
    |"0" -> TradeReportRejectReason.Successful
    |"1" -> TradeReportRejectReason.InvalidPartyInformation
    |"2" -> TradeReportRejectReason.UnknownInstrument
    |"3" -> TradeReportRejectReason.UnauthorizedToReportTrades
    |"4" -> TradeReportRejectReason.InvalidTradeType
    |"10" -> TradeReportRejectReason.Yield
    | x -> failwith (sprintf "ReadTradeReportRejectReason unknown fix tag: %A"  x) 


let WriteTradeReportRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportRejectReason) : int =
    match xxIn with
    | TradeReportRejectReason.Successful ->
        let tag = "751=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.InvalidPartyInformation ->
        let tag = "751=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.UnknownInstrument ->
        let tag = "751=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.UnauthorizedToReportTrades ->
        let tag = "751=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.InvalidTradeType ->
        let tag = "751=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportRejectReason.Yield ->
        let tag = "751=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSideMultiLegReportingType (fldValIn:string) : SideMultiLegReportingType = 
    match fldValIn with
    |"1" -> SideMultiLegReportingType.SingleSecurity
    |"2" -> SideMultiLegReportingType.IndividualLegOfAMultiLegSecurity
    |"3" -> SideMultiLegReportingType.MultiLegSecurity
    | x -> failwith (sprintf "ReadSideMultiLegReportingType unknown fix tag: %A"  x) 


let WriteSideMultiLegReportingType (dest:byte array) (nextFreeIdx:int) (xxIn:SideMultiLegReportingType) : int =
    match xxIn with
    | SideMultiLegReportingType.SingleSecurity ->
        let tag = "752=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideMultiLegReportingType.IndividualLegOfAMultiLegSecurity ->
        let tag = "752=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SideMultiLegReportingType.MultiLegSecurity ->
        let tag = "752=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoPosAmt valIn =
    let tmp = System.Int32.Parse valIn
    NoPosAmt.NoPosAmt tmp


let WriteNoPosAmt (dest:byte []) (nextFreeIdx:int) (valIn:NoPosAmt) : int = 
   let tag = "753="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAutoAcceptIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    AutoAcceptIndicator.AutoAcceptIndicator tmp


let WriteAutoAcceptIndicator (dest:byte []) (nextFreeIdx:int) (valIn:AutoAcceptIndicator) : int = 
   let tag = "754="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocReportID valIn =
    let tmp =  valIn
    AllocReportID.AllocReportID tmp


let WriteAllocReportID (dest:byte []) (nextFreeIdx:int) (valIn:AllocReportID) : int = 
   let tag = "755="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNested2PartyIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNested2PartyIDs.NoNested2PartyIDs tmp


let WriteNoNested2PartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested2PartyIDs) : int = 
   let tag = "756="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested2PartyID valIn =
    let tmp =  valIn
    Nested2PartyID.Nested2PartyID tmp


let WriteNested2PartyID (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyID) : int = 
   let tag = "757="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested2PartyIDSource valIn =
    let tmp = System.Int32.Parse valIn
    Nested2PartyIDSource.Nested2PartyIDSource tmp


let WriteNested2PartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyIDSource) : int = 
   let tag = "758="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested2PartyRole valIn =
    let tmp = System.Int32.Parse valIn
    Nested2PartyRole.Nested2PartyRole tmp


let WriteNested2PartyRole (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartyRole) : int = 
   let tag = "759="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested2PartySubID valIn =
    let tmp =  valIn
    Nested2PartySubID.Nested2PartySubID tmp


let WriteNested2PartySubID (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartySubID) : int = 
   let tag = "760="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadBenchmarkSecurityIDSource valIn =
    let tmp =  valIn
    BenchmarkSecurityIDSource.BenchmarkSecurityIDSource tmp


let WriteBenchmarkSecurityIDSource (dest:byte []) (nextFreeIdx:int) (valIn:BenchmarkSecurityIDSource) : int = 
   let tag = "761="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecuritySubType valIn =
    let tmp =  valIn
    SecuritySubType.SecuritySubType tmp


let WriteSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:SecuritySubType) : int = 
   let tag = "762="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingSecuritySubType valIn =
    let tmp =  valIn
    UnderlyingSecuritySubType.UnderlyingSecuritySubType tmp


let WriteUnderlyingSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingSecuritySubType) : int = 
   let tag = "763="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegSecuritySubType valIn =
    let tmp =  valIn
    LegSecuritySubType.LegSecuritySubType tmp


let WriteLegSecuritySubType (dest:byte []) (nextFreeIdx:int) (valIn:LegSecuritySubType) : int = 
   let tag = "764="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessPct valIn =
    let tmp = System.Decimal.Parse valIn
    AllowableOneSidednessPct.AllowableOneSidednessPct tmp


let WriteAllowableOneSidednessPct (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessPct) : int = 
   let tag = "765="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessValue valIn =
    let tmp = System.Int32.Parse valIn
    AllowableOneSidednessValue.AllowableOneSidednessValue tmp


let WriteAllowableOneSidednessValue (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessValue) : int = 
   let tag = "766="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllowableOneSidednessCurr valIn =
    let tmp =  valIn
    AllowableOneSidednessCurr.AllowableOneSidednessCurr tmp


let WriteAllowableOneSidednessCurr (dest:byte []) (nextFreeIdx:int) (valIn:AllowableOneSidednessCurr) : int = 
   let tag = "767="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoTrdRegTimestamps valIn =
    let tmp = System.Int32.Parse valIn
    NoTrdRegTimestamps.NoTrdRegTimestamps tmp


let WriteNoTrdRegTimestamps (dest:byte []) (nextFreeIdx:int) (valIn:NoTrdRegTimestamps) : int = 
   let tag = "768="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTrdRegTimestamp valIn =
    let tmp =  valIn
    TrdRegTimestamp.TrdRegTimestamp tmp


let WriteTrdRegTimestamp (dest:byte []) (nextFreeIdx:int) (valIn:TrdRegTimestamp) : int = 
   let tag = "769="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTrdRegTimestampType (fldValIn:string) : TrdRegTimestampType = 
    match fldValIn with
    |"1" -> TrdRegTimestampType.ExecutionTime
    |"2" -> TrdRegTimestampType.TimeIn
    |"3" -> TrdRegTimestampType.TimeOut
    |"4" -> TrdRegTimestampType.BrokerReceipt
    |"5" -> TrdRegTimestampType.BrokerExecution
    | x -> failwith (sprintf "ReadTrdRegTimestampType unknown fix tag: %A"  x) 


let WriteTrdRegTimestampType (dest:byte array) (nextFreeIdx:int) (xxIn:TrdRegTimestampType) : int =
    match xxIn with
    | TrdRegTimestampType.ExecutionTime ->
        let tag = "770=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.TimeIn ->
        let tag = "770=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.TimeOut ->
        let tag = "770=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.BrokerReceipt ->
        let tag = "770=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRegTimestampType.BrokerExecution ->
        let tag = "770=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdRegTimestampOrigin valIn =
    let tmp =  valIn
    TrdRegTimestampOrigin.TrdRegTimestampOrigin tmp


let WriteTrdRegTimestampOrigin (dest:byte []) (nextFreeIdx:int) (valIn:TrdRegTimestampOrigin) : int = 
   let tag = "771="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConfirmRefID valIn =
    let tmp =  valIn
    ConfirmRefID.ConfirmRefID tmp


let WriteConfirmRefID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmRefID) : int = 
   let tag = "772="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConfirmType (fldValIn:string) : ConfirmType = 
    match fldValIn with
    |"1" -> ConfirmType.Status
    |"2" -> ConfirmType.Confirmation
    |"3" -> ConfirmType.ConfirmationRequestRejected
    | x -> failwith (sprintf "ReadConfirmType unknown fix tag: %A"  x) 


let WriteConfirmType (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmType) : int =
    match xxIn with
    | ConfirmType.Status ->
        let tag = "773=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmType.Confirmation ->
        let tag = "773=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmType.ConfirmationRequestRejected ->
        let tag = "773=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadConfirmRejReason (fldValIn:string) : ConfirmRejReason = 
    match fldValIn with
    |"1" -> ConfirmRejReason.MismatchedAccount
    |"2" -> ConfirmRejReason.MissingSettlementInstructions
    |"99" -> ConfirmRejReason.Other
    | x -> failwith (sprintf "ReadConfirmRejReason unknown fix tag: %A"  x) 


let WriteConfirmRejReason (dest:byte array) (nextFreeIdx:int) (xxIn:ConfirmRejReason) : int =
    match xxIn with
    | ConfirmRejReason.MismatchedAccount ->
        let tag = "774=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmRejReason.MissingSettlementInstructions ->
        let tag = "774=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ConfirmRejReason.Other ->
        let tag = "774=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadBookingType (fldValIn:string) : BookingType = 
    match fldValIn with
    |"0" -> BookingType.RegularBooking
    |"1" -> BookingType.Cfd
    |"2" -> BookingType.TotalReturnSwap
    | x -> failwith (sprintf "ReadBookingType unknown fix tag: %A"  x) 


let WriteBookingType (dest:byte array) (nextFreeIdx:int) (xxIn:BookingType) : int =
    match xxIn with
    | BookingType.RegularBooking ->
        let tag = "775=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingType.Cfd ->
        let tag = "775=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | BookingType.TotalReturnSwap ->
        let tag = "775=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadIndividualAllocRejCode valIn =
    let tmp = System.Int32.Parse valIn
    IndividualAllocRejCode.IndividualAllocRejCode tmp


let WriteIndividualAllocRejCode (dest:byte []) (nextFreeIdx:int) (valIn:IndividualAllocRejCode) : int = 
   let tag = "776="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstMsgID valIn =
    let tmp =  valIn
    SettlInstMsgID.SettlInstMsgID tmp


let WriteSettlInstMsgID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstMsgID) : int = 
   let tag = "777="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoSettlInst valIn =
    let tmp = System.Int32.Parse valIn
    NoSettlInst.NoSettlInst tmp


let WriteNoSettlInst (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlInst) : int = 
   let tag = "778="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastUpdateTime valIn =
    let tmp =  valIn
    LastUpdateTime.LastUpdateTime tmp


let WriteLastUpdateTime (dest:byte []) (nextFreeIdx:int) (valIn:LastUpdateTime) : int = 
   let tag = "779="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocSettlInstType (fldValIn:string) : AllocSettlInstType = 
    match fldValIn with
    |"0" -> AllocSettlInstType.UseDefaultInstructions
    |"1" -> AllocSettlInstType.DeriveFromParametersProvided
    |"2" -> AllocSettlInstType.FullDetailsProvided
    |"3" -> AllocSettlInstType.SsiDbIdsProvided
    |"4" -> AllocSettlInstType.PhoneForInstructions
    | x -> failwith (sprintf "ReadAllocSettlInstType unknown fix tag: %A"  x) 


let WriteAllocSettlInstType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocSettlInstType) : int =
    match xxIn with
    | AllocSettlInstType.UseDefaultInstructions ->
        let tag = "780=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.DeriveFromParametersProvided ->
        let tag = "780=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.FullDetailsProvided ->
        let tag = "780=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.SsiDbIdsProvided ->
        let tag = "780=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocSettlInstType.PhoneForInstructions ->
        let tag = "780=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoSettlPartyIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoSettlPartyIDs.NoSettlPartyIDs tmp


let WriteNoSettlPartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlPartyIDs) : int = 
   let tag = "781="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPartyID valIn =
    let tmp =  valIn
    SettlPartyID.SettlPartyID tmp


let WriteSettlPartyID (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyID) : int = 
   let tag = "782="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPartyIDSource valIn =
    let tmp = System.Int32.Parse valIn
    SettlPartyIDSource.SettlPartyIDSource tmp


let WriteSettlPartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyIDSource) : int = 
   let tag = "783="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPartyRole valIn =
    let tmp = System.Int32.Parse valIn
    SettlPartyRole.SettlPartyRole tmp


let WriteSettlPartyRole (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartyRole) : int = 
   let tag = "784="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPartySubID valIn =
    let tmp =  valIn
    SettlPartySubID.SettlPartySubID tmp


let WriteSettlPartySubID (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartySubID) : int = 
   let tag = "785="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlPartySubIDType valIn =
    let tmp = System.Int32.Parse valIn
    SettlPartySubIDType.SettlPartySubIDType tmp


let WriteSettlPartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:SettlPartySubIDType) : int = 
   let tag = "786="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDlvyInstType (fldValIn:string) : DlvyInstType = 
    match fldValIn with
    |"S" -> DlvyInstType.Securities
    |"C" -> DlvyInstType.Cash
    | x -> failwith (sprintf "ReadDlvyInstType unknown fix tag: %A"  x) 


let WriteDlvyInstType (dest:byte array) (nextFreeIdx:int) (xxIn:DlvyInstType) : int =
    match xxIn with
    | DlvyInstType.Securities ->
        let tag = "787=S"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DlvyInstType.Cash ->
        let tag = "787=C"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTerminationType (fldValIn:string) : TerminationType = 
    match fldValIn with
    |"1" -> TerminationType.Overnight
    |"2" -> TerminationType.Term
    |"3" -> TerminationType.Flexible
    |"4" -> TerminationType.Open
    | x -> failwith (sprintf "ReadTerminationType unknown fix tag: %A"  x) 


let WriteTerminationType (dest:byte array) (nextFreeIdx:int) (xxIn:TerminationType) : int =
    match xxIn with
    | TerminationType.Overnight ->
        let tag = "788=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Term ->
        let tag = "788=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Flexible ->
        let tag = "788=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TerminationType.Open ->
        let tag = "788=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNextExpectedMsgSeqNum valIn =
    let tmp = System.Int32.Parse valIn
    NextExpectedMsgSeqNum.NextExpectedMsgSeqNum tmp


let WriteNextExpectedMsgSeqNum (dest:byte []) (nextFreeIdx:int) (valIn:NextExpectedMsgSeqNum) : int = 
   let tag = "789="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrdStatusReqID valIn =
    let tmp =  valIn
    OrdStatusReqID.OrdStatusReqID tmp


let WriteOrdStatusReqID (dest:byte []) (nextFreeIdx:int) (valIn:OrdStatusReqID) : int = 
   let tag = "790="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstReqID valIn =
    let tmp =  valIn
    SettlInstReqID.SettlInstReqID tmp


let WriteSettlInstReqID (dest:byte []) (nextFreeIdx:int) (valIn:SettlInstReqID) : int = 
   let tag = "791="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSettlInstReqRejCode (fldValIn:string) : SettlInstReqRejCode = 
    match fldValIn with
    |"0" -> SettlInstReqRejCode.UnableToProcessRequest
    |"1" -> SettlInstReqRejCode.UnknownAccount
    |"2" -> SettlInstReqRejCode.NoMatchingSettlementInstructionsFound
    |"99" -> SettlInstReqRejCode.Other
    | x -> failwith (sprintf "ReadSettlInstReqRejCode unknown fix tag: %A"  x) 


let WriteSettlInstReqRejCode (dest:byte array) (nextFreeIdx:int) (xxIn:SettlInstReqRejCode) : int =
    match xxIn with
    | SettlInstReqRejCode.UnableToProcessRequest ->
        let tag = "792=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.UnknownAccount ->
        let tag = "792=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.NoMatchingSettlementInstructionsFound ->
        let tag = "792=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | SettlInstReqRejCode.Other ->
        let tag = "792=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryAllocID valIn =
    let tmp =  valIn
    SecondaryAllocID.SecondaryAllocID tmp


let WriteSecondaryAllocID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryAllocID) : int = 
   let tag = "793="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocReportType (fldValIn:string) : AllocReportType = 
    match fldValIn with
    |"3" -> AllocReportType.SellsideCalculatedUsingPreliminary
    |"4" -> AllocReportType.SellsideCalculatedWithoutPreliminary
    |"5" -> AllocReportType.WarehouseRecap
    |"8" -> AllocReportType.RequestToIntermediary
    | x -> failwith (sprintf "ReadAllocReportType unknown fix tag: %A"  x) 


let WriteAllocReportType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocReportType) : int =
    match xxIn with
    | AllocReportType.SellsideCalculatedUsingPreliminary ->
        let tag = "794=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.SellsideCalculatedWithoutPreliminary ->
        let tag = "794=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.WarehouseRecap ->
        let tag = "794=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocReportType.RequestToIntermediary ->
        let tag = "794=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocReportRefID valIn =
    let tmp =  valIn
    AllocReportRefID.AllocReportRefID tmp


let WriteAllocReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:AllocReportRefID) : int = 
   let tag = "795="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocCancReplaceReason (fldValIn:string) : AllocCancReplaceReason = 
    match fldValIn with
    |"1" -> AllocCancReplaceReason.OriginalDetailsIncompleteIncorrect
    |"2" -> AllocCancReplaceReason.ChangeInUnderlyingOrderDetails
    | x -> failwith (sprintf "ReadAllocCancReplaceReason unknown fix tag: %A"  x) 


let WriteAllocCancReplaceReason (dest:byte array) (nextFreeIdx:int) (xxIn:AllocCancReplaceReason) : int =
    match xxIn with
    | AllocCancReplaceReason.OriginalDetailsIncompleteIncorrect ->
        let tag = "796=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocCancReplaceReason.ChangeInUnderlyingOrderDetails ->
        let tag = "796=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCopyMsgIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    CopyMsgIndicator.CopyMsgIndicator tmp


let WriteCopyMsgIndicator (dest:byte []) (nextFreeIdx:int) (valIn:CopyMsgIndicator) : int = 
   let tag = "797="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocAccountType (fldValIn:string) : AllocAccountType = 
    match fldValIn with
    |"1" -> AllocAccountType.AccountIsCarriedOnCustomerSideOfBooks
    |"2" -> AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooks
    |"3" -> AllocAccountType.HouseTrader
    |"4" -> AllocAccountType.FloorTrader
    |"6" -> AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined
    |"7" -> AllocAccountType.AccountIsHouseTraderAndIsCrossMargined
    |"8" -> AllocAccountType.JointBackofficeAccount
    | x -> failwith (sprintf "ReadAllocAccountType unknown fix tag: %A"  x) 


let WriteAllocAccountType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocAccountType) : int =
    match xxIn with
    | AllocAccountType.AccountIsCarriedOnCustomerSideOfBooks ->
        let tag = "798=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooks ->
        let tag = "798=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.HouseTrader ->
        let tag = "798=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.FloorTrader ->
        let tag = "798=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsCarriedOnNonCustomerSideOfBooksAndIsCrossMargined ->
        let tag = "798=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.AccountIsHouseTraderAndIsCrossMargined ->
        let tag = "798=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocAccountType.JointBackofficeAccount ->
        let tag = "798=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadOrderAvgPx valIn =
    let tmp = System.Decimal.Parse valIn
    OrderAvgPx.OrderAvgPx tmp


let WriteOrderAvgPx (dest:byte []) (nextFreeIdx:int) (valIn:OrderAvgPx) : int = 
   let tag = "799="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderBookingQty valIn =
    let tmp = System.Decimal.Parse valIn
    OrderBookingQty.OrderBookingQty tmp


let WriteOrderBookingQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderBookingQty) : int = 
   let tag = "800="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoSettlPartySubIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoSettlPartySubIDs.NoSettlPartySubIDs tmp


let WriteNoSettlPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoSettlPartySubIDs) : int = 
   let tag = "801="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoPartySubIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoPartySubIDs.NoPartySubIDs tmp


let WriteNoPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoPartySubIDs) : int = 
   let tag = "802="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPartySubIDType valIn =
    let tmp = System.Int32.Parse valIn
    PartySubIDType.PartySubIDType tmp


let WritePartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:PartySubIDType) : int = 
   let tag = "803="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNestedPartySubIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNestedPartySubIDs.NoNestedPartySubIDs tmp


let WriteNoNestedPartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNestedPartySubIDs) : int = 
   let tag = "804="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNestedPartySubIDType valIn =
    let tmp = System.Int32.Parse valIn
    NestedPartySubIDType.NestedPartySubIDType tmp


let WriteNestedPartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:NestedPartySubIDType) : int = 
   let tag = "805="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNested2PartySubIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNested2PartySubIDs.NoNested2PartySubIDs tmp


let WriteNoNested2PartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested2PartySubIDs) : int = 
   let tag = "806="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested2PartySubIDType valIn =
    let tmp = System.Int32.Parse valIn
    Nested2PartySubIDType.Nested2PartySubIDType tmp


let WriteNested2PartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:Nested2PartySubIDType) : int = 
   let tag = "807="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAllocIntermedReqType (fldValIn:string) : AllocIntermedReqType = 
    match fldValIn with
    |"1" -> AllocIntermedReqType.PendingAccept
    |"2" -> AllocIntermedReqType.PendingRelease
    |"3" -> AllocIntermedReqType.PendingReversal
    |"4" -> AllocIntermedReqType.Accept
    |"5" -> AllocIntermedReqType.BlockLevelReject
    |"6" -> AllocIntermedReqType.AccountLevelReject
    | x -> failwith (sprintf "ReadAllocIntermedReqType unknown fix tag: %A"  x) 


let WriteAllocIntermedReqType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocIntermedReqType) : int =
    match xxIn with
    | AllocIntermedReqType.PendingAccept ->
        let tag = "808=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.PendingRelease ->
        let tag = "808=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.PendingReversal ->
        let tag = "808=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.Accept ->
        let tag = "808=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.BlockLevelReject ->
        let tag = "808=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocIntermedReqType.AccountLevelReject ->
        let tag = "808=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingPx valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingPx.UnderlyingPx tmp


let WriteUnderlyingPx (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingPx) : int = 
   let tag = "810="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPriceDelta valIn =
    let tmp = System.Decimal.Parse valIn
    PriceDelta.PriceDelta tmp


let WritePriceDelta (dest:byte []) (nextFreeIdx:int) (valIn:PriceDelta) : int = 
   let tag = "811="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadApplQueueMax valIn =
    let tmp = System.Int32.Parse valIn
    ApplQueueMax.ApplQueueMax tmp


let WriteApplQueueMax (dest:byte []) (nextFreeIdx:int) (valIn:ApplQueueMax) : int = 
   let tag = "812="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadApplQueueDepth valIn =
    let tmp = System.Int32.Parse valIn
    ApplQueueDepth.ApplQueueDepth tmp


let WriteApplQueueDepth (dest:byte []) (nextFreeIdx:int) (valIn:ApplQueueDepth) : int = 
   let tag = "813="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadApplQueueResolution (fldValIn:string) : ApplQueueResolution = 
    match fldValIn with
    |"0" -> ApplQueueResolution.NoActionTaken
    |"1" -> ApplQueueResolution.QueueFlushed
    |"2" -> ApplQueueResolution.OverlayLast
    |"3" -> ApplQueueResolution.EndSession
    | x -> failwith (sprintf "ReadApplQueueResolution unknown fix tag: %A"  x) 


let WriteApplQueueResolution (dest:byte array) (nextFreeIdx:int) (xxIn:ApplQueueResolution) : int =
    match xxIn with
    | ApplQueueResolution.NoActionTaken ->
        let tag = "814=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.QueueFlushed ->
        let tag = "814=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.OverlayLast ->
        let tag = "814=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueResolution.EndSession ->
        let tag = "814=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadApplQueueAction (fldValIn:string) : ApplQueueAction = 
    match fldValIn with
    |"0" -> ApplQueueAction.NoActionTaken
    |"1" -> ApplQueueAction.QueueFlushed
    |"2" -> ApplQueueAction.OverlayLast
    |"3" -> ApplQueueAction.EndSession
    | x -> failwith (sprintf "ReadApplQueueAction unknown fix tag: %A"  x) 


let WriteApplQueueAction (dest:byte array) (nextFreeIdx:int) (xxIn:ApplQueueAction) : int =
    match xxIn with
    | ApplQueueAction.NoActionTaken ->
        let tag = "815=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.QueueFlushed ->
        let tag = "815=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.OverlayLast ->
        let tag = "815=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ApplQueueAction.EndSession ->
        let tag = "815=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoAltMDSource valIn =
    let tmp = System.Int32.Parse valIn
    NoAltMDSource.NoAltMDSource tmp


let WriteNoAltMDSource (dest:byte []) (nextFreeIdx:int) (valIn:NoAltMDSource) : int = 
   let tag = "816="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAltMDSourceID valIn =
    let tmp =  valIn
    AltMDSourceID.AltMDSourceID tmp


let WriteAltMDSourceID (dest:byte []) (nextFreeIdx:int) (valIn:AltMDSourceID) : int = 
   let tag = "817="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecondaryTradeReportID valIn =
    let tmp =  valIn
    SecondaryTradeReportID.SecondaryTradeReportID tmp


let WriteSecondaryTradeReportID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTradeReportID) : int = 
   let tag = "818="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAvgPxIndicator (fldValIn:string) : AvgPxIndicator = 
    match fldValIn with
    |"0" -> AvgPxIndicator.NoAveragePricing
    |"1" -> AvgPxIndicator.TradeIsPartOfAnAveragePriceGroupIdentifiedByTheTradelinkid
    |"2" -> AvgPxIndicator.LastTradeInTheAveragePriceGroupIdentifiedByTheTradelinkid
    | x -> failwith (sprintf "ReadAvgPxIndicator unknown fix tag: %A"  x) 


let WriteAvgPxIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:AvgPxIndicator) : int =
    match xxIn with
    | AvgPxIndicator.NoAveragePricing ->
        let tag = "819=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AvgPxIndicator.TradeIsPartOfAnAveragePriceGroupIdentifiedByTheTradelinkid ->
        let tag = "819=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AvgPxIndicator.LastTradeInTheAveragePriceGroupIdentifiedByTheTradelinkid ->
        let tag = "819=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTradeLinkID valIn =
    let tmp =  valIn
    TradeLinkID.TradeLinkID tmp


let WriteTradeLinkID (dest:byte []) (nextFreeIdx:int) (valIn:TradeLinkID) : int = 
   let tag = "820="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderInputDevice valIn =
    let tmp =  valIn
    OrderInputDevice.OrderInputDevice tmp


let WriteOrderInputDevice (dest:byte []) (nextFreeIdx:int) (valIn:OrderInputDevice) : int = 
   let tag = "821="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingTradingSessionID valIn =
    let tmp =  valIn
    UnderlyingTradingSessionID.UnderlyingTradingSessionID tmp


let WriteUnderlyingTradingSessionID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingTradingSessionID) : int = 
   let tag = "822="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingTradingSessionSubID valIn =
    let tmp =  valIn
    UnderlyingTradingSessionSubID.UnderlyingTradingSessionSubID tmp


let WriteUnderlyingTradingSessionSubID (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingTradingSessionSubID) : int = 
   let tag = "823="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeLegRefID valIn =
    let tmp =  valIn
    TradeLegRefID.TradeLegRefID tmp


let WriteTradeLegRefID (dest:byte []) (nextFreeIdx:int) (valIn:TradeLegRefID) : int = 
   let tag = "824="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadExchangeRule valIn =
    let tmp =  valIn
    ExchangeRule.ExchangeRule tmp


let WriteExchangeRule (dest:byte []) (nextFreeIdx:int) (valIn:ExchangeRule) : int = 
   let tag = "825="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeAllocIndicator (fldValIn:string) : TradeAllocIndicator = 
    match fldValIn with
    |"0" -> TradeAllocIndicator.AllocationNotRequired
    |"1" -> TradeAllocIndicator.AllocationRequired
    |"2" -> TradeAllocIndicator.UseAllocationProvidedWithTheTrade
    | x -> failwith (sprintf "ReadTradeAllocIndicator unknown fix tag: %A"  x) 


let WriteTradeAllocIndicator (dest:byte array) (nextFreeIdx:int) (xxIn:TradeAllocIndicator) : int =
    match xxIn with
    | TradeAllocIndicator.AllocationNotRequired ->
        let tag = "826=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeAllocIndicator.AllocationRequired ->
        let tag = "826=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeAllocIndicator.UseAllocationProvidedWithTheTrade ->
        let tag = "826=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadExpirationCycle (fldValIn:string) : ExpirationCycle = 
    match fldValIn with
    |"0" -> ExpirationCycle.ExpireOnTradingSessionClose
    |"1" -> ExpirationCycle.ExpireOnTradingSessionOpen
    | x -> failwith (sprintf "ReadExpirationCycle unknown fix tag: %A"  x) 


let WriteExpirationCycle (dest:byte array) (nextFreeIdx:int) (xxIn:ExpirationCycle) : int =
    match xxIn with
    | ExpirationCycle.ExpireOnTradingSessionClose ->
        let tag = "827=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ExpirationCycle.ExpireOnTradingSessionOpen ->
        let tag = "827=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdType (fldValIn:string) : TrdType = 
    match fldValIn with
    |"0" -> TrdType.RegularTrade
    |"1" -> TrdType.BlockTrade
    |"2" -> TrdType.Efp
    |"3" -> TrdType.Transfer
    |"4" -> TrdType.LateTrade
    |"5" -> TrdType.TTrade
    |"6" -> TrdType.WeightedAveragePriceTrade
    |"7" -> TrdType.BunchedTrade
    |"8" -> TrdType.LateBunchedTrade
    |"9" -> TrdType.PriorReferencePriceTrade
    |"10" -> TrdType.AfterHoursTrade
    | x -> failwith (sprintf "ReadTrdType unknown fix tag: %A"  x) 


let WriteTrdType (dest:byte array) (nextFreeIdx:int) (xxIn:TrdType) : int =
    match xxIn with
    | TrdType.RegularTrade ->
        let tag = "828=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.BlockTrade ->
        let tag = "828=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.Efp ->
        let tag = "828=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.Transfer ->
        let tag = "828=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.LateTrade ->
        let tag = "828=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.TTrade ->
        let tag = "828=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.WeightedAveragePriceTrade ->
        let tag = "828=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.BunchedTrade ->
        let tag = "828=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.LateBunchedTrade ->
        let tag = "828=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.PriorReferencePriceTrade ->
        let tag = "828=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdType.AfterHoursTrade ->
        let tag = "828=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTrdSubType valIn =
    let tmp = System.Int32.Parse valIn
    TrdSubType.TrdSubType tmp


let WriteTrdSubType (dest:byte []) (nextFreeIdx:int) (valIn:TrdSubType) : int = 
   let tag = "829="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTransferReason valIn =
    let tmp =  valIn
    TransferReason.TransferReason tmp


let WriteTransferReason (dest:byte []) (nextFreeIdx:int) (valIn:TransferReason) : int = 
   let tag = "830="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAsgnReqID valIn =
    let tmp =  valIn
    AsgnReqID.AsgnReqID tmp


let WriteAsgnReqID (dest:byte []) (nextFreeIdx:int) (valIn:AsgnReqID) : int = 
   let tag = "831="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotNumAssignmentReports valIn =
    let tmp = System.Int32.Parse valIn
    TotNumAssignmentReports.TotNumAssignmentReports tmp


let WriteTotNumAssignmentReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumAssignmentReports) : int = 
   let tag = "832="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAsgnRptID valIn =
    let tmp =  valIn
    AsgnRptID.AsgnRptID tmp


let WriteAsgnRptID (dest:byte []) (nextFreeIdx:int) (valIn:AsgnRptID) : int = 
   let tag = "833="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadThresholdAmount valIn =
    let tmp = System.Decimal.Parse valIn
    ThresholdAmount.ThresholdAmount tmp


let WriteThresholdAmount (dest:byte []) (nextFreeIdx:int) (valIn:ThresholdAmount) : int = 
   let tag = "834="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPegMoveType (fldValIn:string) : PegMoveType = 
    match fldValIn with
    |"0" -> PegMoveType.Floating
    |"1" -> PegMoveType.Fixed
    | x -> failwith (sprintf "ReadPegMoveType unknown fix tag: %A"  x) 


let WritePegMoveType (dest:byte array) (nextFreeIdx:int) (xxIn:PegMoveType) : int =
    match xxIn with
    | PegMoveType.Floating ->
        let tag = "835=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegMoveType.Fixed ->
        let tag = "835=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegOffsetType (fldValIn:string) : PegOffsetType = 
    match fldValIn with
    |"0" -> PegOffsetType.Price
    |"1" -> PegOffsetType.BasisPoints
    |"2" -> PegOffsetType.Ticks
    |"3" -> PegOffsetType.PriceTierLevel
    | x -> failwith (sprintf "ReadPegOffsetType unknown fix tag: %A"  x) 


let WritePegOffsetType (dest:byte array) (nextFreeIdx:int) (xxIn:PegOffsetType) : int =
    match xxIn with
    | PegOffsetType.Price ->
        let tag = "836=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.BasisPoints ->
        let tag = "836=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.Ticks ->
        let tag = "836=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegOffsetType.PriceTierLevel ->
        let tag = "836=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegLimitType (fldValIn:string) : PegLimitType = 
    match fldValIn with
    |"0" -> PegLimitType.OrBetter
    |"1" -> PegLimitType.Strict
    |"2" -> PegLimitType.OrWorse
    | x -> failwith (sprintf "ReadPegLimitType unknown fix tag: %A"  x) 


let WritePegLimitType (dest:byte array) (nextFreeIdx:int) (xxIn:PegLimitType) : int =
    match xxIn with
    | PegLimitType.OrBetter ->
        let tag = "837=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegLimitType.Strict ->
        let tag = "837=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegLimitType.OrWorse ->
        let tag = "837=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPegRoundDirection (fldValIn:string) : PegRoundDirection = 
    match fldValIn with
    |"1" -> PegRoundDirection.MoreAggressive
    |"2" -> PegRoundDirection.MorePassive
    | x -> failwith (sprintf "ReadPegRoundDirection unknown fix tag: %A"  x) 


let WritePegRoundDirection (dest:byte array) (nextFreeIdx:int) (xxIn:PegRoundDirection) : int =
    match xxIn with
    | PegRoundDirection.MoreAggressive ->
        let tag = "838=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegRoundDirection.MorePassive ->
        let tag = "838=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPeggedPrice valIn =
    let tmp = System.Decimal.Parse valIn
    PeggedPrice.PeggedPrice tmp


let WritePeggedPrice (dest:byte []) (nextFreeIdx:int) (valIn:PeggedPrice) : int = 
   let tag = "839="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPegScope (fldValIn:string) : PegScope = 
    match fldValIn with
    |"1" -> PegScope.Local
    |"2" -> PegScope.National
    |"3" -> PegScope.Global
    |"4" -> PegScope.NationalExcludingLocal
    | x -> failwith (sprintf "ReadPegScope unknown fix tag: %A"  x) 


let WritePegScope (dest:byte array) (nextFreeIdx:int) (xxIn:PegScope) : int =
    match xxIn with
    | PegScope.Local ->
        let tag = "840=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.National ->
        let tag = "840=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.Global ->
        let tag = "840=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | PegScope.NationalExcludingLocal ->
        let tag = "840=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionMoveType (fldValIn:string) : DiscretionMoveType = 
    match fldValIn with
    |"0" -> DiscretionMoveType.Floating
    |"1" -> DiscretionMoveType.Fixed
    | x -> failwith (sprintf "ReadDiscretionMoveType unknown fix tag: %A"  x) 


let WriteDiscretionMoveType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionMoveType) : int =
    match xxIn with
    | DiscretionMoveType.Floating ->
        let tag = "841=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionMoveType.Fixed ->
        let tag = "841=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionOffsetType (fldValIn:string) : DiscretionOffsetType = 
    match fldValIn with
    |"0" -> DiscretionOffsetType.Price
    |"1" -> DiscretionOffsetType.BasisPoints
    |"2" -> DiscretionOffsetType.Ticks
    |"3" -> DiscretionOffsetType.PriceTierLevel
    | x -> failwith (sprintf "ReadDiscretionOffsetType unknown fix tag: %A"  x) 


let WriteDiscretionOffsetType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionOffsetType) : int =
    match xxIn with
    | DiscretionOffsetType.Price ->
        let tag = "842=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.BasisPoints ->
        let tag = "842=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.Ticks ->
        let tag = "842=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionOffsetType.PriceTierLevel ->
        let tag = "842=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionLimitType (fldValIn:string) : DiscretionLimitType = 
    match fldValIn with
    |"0" -> DiscretionLimitType.OrBetter
    |"1" -> DiscretionLimitType.Strict
    |"2" -> DiscretionLimitType.OrWorse
    | x -> failwith (sprintf "ReadDiscretionLimitType unknown fix tag: %A"  x) 


let WriteDiscretionLimitType (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionLimitType) : int =
    match xxIn with
    | DiscretionLimitType.OrBetter ->
        let tag = "843=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionLimitType.Strict ->
        let tag = "843=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionLimitType.OrWorse ->
        let tag = "843=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionRoundDirection (fldValIn:string) : DiscretionRoundDirection = 
    match fldValIn with
    |"1" -> DiscretionRoundDirection.MoreAggressive
    |"2" -> DiscretionRoundDirection.MorePassive
    | x -> failwith (sprintf "ReadDiscretionRoundDirection unknown fix tag: %A"  x) 


let WriteDiscretionRoundDirection (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionRoundDirection) : int =
    match xxIn with
    | DiscretionRoundDirection.MoreAggressive ->
        let tag = "844=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionRoundDirection.MorePassive ->
        let tag = "844=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadDiscretionPrice valIn =
    let tmp = System.Decimal.Parse valIn
    DiscretionPrice.DiscretionPrice tmp


let WriteDiscretionPrice (dest:byte []) (nextFreeIdx:int) (valIn:DiscretionPrice) : int = 
   let tag = "845="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDiscretionScope (fldValIn:string) : DiscretionScope = 
    match fldValIn with
    |"1" -> DiscretionScope.Local
    |"2" -> DiscretionScope.National
    |"3" -> DiscretionScope.Global
    |"4" -> DiscretionScope.NationalExcludingLocal
    | x -> failwith (sprintf "ReadDiscretionScope unknown fix tag: %A"  x) 


let WriteDiscretionScope (dest:byte array) (nextFreeIdx:int) (xxIn:DiscretionScope) : int =
    match xxIn with
    | DiscretionScope.Local ->
        let tag = "846=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.National ->
        let tag = "846=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.Global ->
        let tag = "846=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DiscretionScope.NationalExcludingLocal ->
        let tag = "846=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTargetStrategy valIn =
    let tmp = System.Int32.Parse valIn
    TargetStrategy.TargetStrategy tmp


let WriteTargetStrategy (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategy) : int = 
   let tag = "847="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTargetStrategyParameters valIn =
    let tmp =  valIn
    TargetStrategyParameters.TargetStrategyParameters tmp


let WriteTargetStrategyParameters (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategyParameters) : int = 
   let tag = "848="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadParticipationRate valIn =
    let tmp = System.Decimal.Parse valIn
    ParticipationRate.ParticipationRate tmp


let WriteParticipationRate (dest:byte []) (nextFreeIdx:int) (valIn:ParticipationRate) : int = 
   let tag = "849="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTargetStrategyPerformance valIn =
    let tmp = System.Decimal.Parse valIn
    TargetStrategyPerformance.TargetStrategyPerformance tmp


let WriteTargetStrategyPerformance (dest:byte []) (nextFreeIdx:int) (valIn:TargetStrategyPerformance) : int = 
   let tag = "850="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastLiquidityInd (fldValIn:string) : LastLiquidityInd = 
    match fldValIn with
    |"1" -> LastLiquidityInd.AddedLiquidity
    |"2" -> LastLiquidityInd.RemovedLiquidity
    |"3" -> LastLiquidityInd.LiquidityRoutedOut
    | x -> failwith (sprintf "ReadLastLiquidityInd unknown fix tag: %A"  x) 


let WriteLastLiquidityInd (dest:byte array) (nextFreeIdx:int) (xxIn:LastLiquidityInd) : int =
    match xxIn with
    | LastLiquidityInd.AddedLiquidity ->
        let tag = "851=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastLiquidityInd.RemovedLiquidity ->
        let tag = "851=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | LastLiquidityInd.LiquidityRoutedOut ->
        let tag = "851=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadPublishTrdIndicator valIn =
    let tmp = System.Boolean.Parse valIn
    PublishTrdIndicator.PublishTrdIndicator tmp


let WritePublishTrdIndicator (dest:byte []) (nextFreeIdx:int) (valIn:PublishTrdIndicator) : int = 
   let tag = "852="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadShortSaleReason (fldValIn:string) : ShortSaleReason = 
    match fldValIn with
    |"0" -> ShortSaleReason.DealerSoldShort
    |"1" -> ShortSaleReason.DealerSoldShortExempt
    |"2" -> ShortSaleReason.SellingCustomerSoldShort
    |"3" -> ShortSaleReason.SellingCustomerSoldShortExempt
    |"4" -> ShortSaleReason.QualifedServiceRepresentativeOrAutomaticGiveupContraSideSoldShort
    |"5" -> ShortSaleReason.QsrOrAguContraSideSoldShortExempt
    | x -> failwith (sprintf "ReadShortSaleReason unknown fix tag: %A"  x) 


let WriteShortSaleReason (dest:byte array) (nextFreeIdx:int) (xxIn:ShortSaleReason) : int =
    match xxIn with
    | ShortSaleReason.DealerSoldShort ->
        let tag = "853=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.DealerSoldShortExempt ->
        let tag = "853=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.SellingCustomerSoldShort ->
        let tag = "853=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.SellingCustomerSoldShortExempt ->
        let tag = "853=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.QualifedServiceRepresentativeOrAutomaticGiveupContraSideSoldShort ->
        let tag = "853=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | ShortSaleReason.QsrOrAguContraSideSoldShortExempt ->
        let tag = "853=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadQtyType (fldValIn:string) : QtyType = 
    match fldValIn with
    |"0" -> QtyType.Units
    |"1" -> QtyType.Contracts
    | x -> failwith (sprintf "ReadQtyType unknown fix tag: %A"  x) 


let WriteQtyType (dest:byte array) (nextFreeIdx:int) (xxIn:QtyType) : int =
    match xxIn with
    | QtyType.Units ->
        let tag = "854=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | QtyType.Contracts ->
        let tag = "854=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSecondaryTrdType valIn =
    let tmp = System.Int32.Parse valIn
    SecondaryTrdType.SecondaryTrdType tmp


let WriteSecondaryTrdType (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTrdType) : int = 
   let tag = "855="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTradeReportType (fldValIn:string) : TradeReportType = 
    match fldValIn with
    |"0" -> TradeReportType.Submit
    |"1" -> TradeReportType.Alleged
    |"2" -> TradeReportType.Accept
    |"3" -> TradeReportType.Decline
    |"4" -> TradeReportType.Addendum
    |"5" -> TradeReportType.NoWas
    |"6" -> TradeReportType.TradeReportCancel
    |"7" -> TradeReportType.LockedInTradeBreak
    | x -> failwith (sprintf "ReadTradeReportType unknown fix tag: %A"  x) 


let WriteTradeReportType (dest:byte array) (nextFreeIdx:int) (xxIn:TradeReportType) : int =
    match xxIn with
    | TradeReportType.Submit ->
        let tag = "856=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Alleged ->
        let tag = "856=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Accept ->
        let tag = "856=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Decline ->
        let tag = "856=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.Addendum ->
        let tag = "856=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.NoWas ->
        let tag = "856=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.TradeReportCancel ->
        let tag = "856=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TradeReportType.LockedInTradeBreak ->
        let tag = "856=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAllocNoOrdersType (fldValIn:string) : AllocNoOrdersType = 
    match fldValIn with
    |"0" -> AllocNoOrdersType.NotSpecified
    |"1" -> AllocNoOrdersType.ExplicitListProvided
    | x -> failwith (sprintf "ReadAllocNoOrdersType unknown fix tag: %A"  x) 


let WriteAllocNoOrdersType (dest:byte array) (nextFreeIdx:int) (xxIn:AllocNoOrdersType) : int =
    match xxIn with
    | AllocNoOrdersType.NotSpecified ->
        let tag = "857=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AllocNoOrdersType.ExplicitListProvided ->
        let tag = "857=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadSharedCommission valIn =
    let tmp = System.Int32.Parse valIn
    SharedCommission.SharedCommission tmp


let WriteSharedCommission (dest:byte []) (nextFreeIdx:int) (valIn:SharedCommission) : int = 
   let tag = "858="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadConfirmReqID valIn =
    let tmp =  valIn
    ConfirmReqID.ConfirmReqID tmp


let WriteConfirmReqID (dest:byte []) (nextFreeIdx:int) (valIn:ConfirmReqID) : int = 
   let tag = "859="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAvgParPx valIn =
    let tmp = System.Decimal.Parse valIn
    AvgParPx.AvgParPx tmp


let WriteAvgParPx (dest:byte []) (nextFreeIdx:int) (valIn:AvgParPx) : int = 
   let tag = "860="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadReportedPx valIn =
    let tmp = System.Decimal.Parse valIn
    ReportedPx.ReportedPx tmp


let WriteReportedPx (dest:byte []) (nextFreeIdx:int) (valIn:ReportedPx) : int = 
   let tag = "861="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoCapacities valIn =
    let tmp = System.Int32.Parse valIn
    NoCapacities.NoCapacities tmp


let WriteNoCapacities (dest:byte []) (nextFreeIdx:int) (valIn:NoCapacities) : int = 
   let tag = "862="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadOrderCapacityQty valIn =
    let tmp = System.Decimal.Parse valIn
    OrderCapacityQty.OrderCapacityQty tmp


let WriteOrderCapacityQty (dest:byte []) (nextFreeIdx:int) (valIn:OrderCapacityQty) : int = 
   let tag = "863="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoEvents valIn =
    let tmp = System.Int32.Parse valIn
    NoEvents.NoEvents tmp


let WriteNoEvents (dest:byte []) (nextFreeIdx:int) (valIn:NoEvents) : int = 
   let tag = "864="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEventType (fldValIn:string) : EventType = 
    match fldValIn with
    |"1" -> EventType.Put
    |"2" -> EventType.Call
    |"3" -> EventType.Tender
    |"4" -> EventType.SinkingFundCall
    |"99" -> EventType.Other
    | x -> failwith (sprintf "ReadEventType unknown fix tag: %A"  x) 


let WriteEventType (dest:byte array) (nextFreeIdx:int) (xxIn:EventType) : int =
    match xxIn with
    | EventType.Put ->
        let tag = "865=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Call ->
        let tag = "865=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Tender ->
        let tag = "865=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.SinkingFundCall ->
        let tag = "865=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | EventType.Other ->
        let tag = "865=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEventDate valIn =
    let tmp =  valIn
    EventDate.EventDate tmp


let WriteEventDate (dest:byte []) (nextFreeIdx:int) (valIn:EventDate) : int = 
   let tag = "866="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEventPx valIn =
    let tmp = System.Decimal.Parse valIn
    EventPx.EventPx tmp


let WriteEventPx (dest:byte []) (nextFreeIdx:int) (valIn:EventPx) : int = 
   let tag = "867="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEventText valIn =
    let tmp =  valIn
    EventText.EventText tmp


let WriteEventText (dest:byte []) (nextFreeIdx:int) (valIn:EventText) : int = 
   let tag = "868="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadPctAtRisk valIn =
    let tmp = System.Decimal.Parse valIn
    PctAtRisk.PctAtRisk tmp


let WritePctAtRisk (dest:byte []) (nextFreeIdx:int) (valIn:PctAtRisk) : int = 
   let tag = "869="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoInstrAttrib valIn =
    let tmp = System.Int32.Parse valIn
    NoInstrAttrib.NoInstrAttrib tmp


let WriteNoInstrAttrib (dest:byte []) (nextFreeIdx:int) (valIn:NoInstrAttrib) : int = 
   let tag = "870="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadInstrAttribType (fldValIn:string) : InstrAttribType = 
    match fldValIn with
    |"1" -> InstrAttribType.Flat
    |"2" -> InstrAttribType.ZeroCoupon
    |"3" -> InstrAttribType.InterestBearing
    |"4" -> InstrAttribType.NoPeriodicPayments
    |"5" -> InstrAttribType.VariableRate
    |"6" -> InstrAttribType.LessFeeForPut
    |"7" -> InstrAttribType.SteppedCoupon
    |"8" -> InstrAttribType.CouponPeriod
    |"9" -> InstrAttribType.WhenAndIfIssued
    |"10" -> InstrAttribType.OriginalIssueDiscount
    |"11" -> InstrAttribType.CallablePuttable
    |"12" -> InstrAttribType.EscrowedToMaturity
    |"13" -> InstrAttribType.EscrowedToRedemptionDate
    |"14" -> InstrAttribType.PreRefunded
    |"15" -> InstrAttribType.InDefault
    |"16" -> InstrAttribType.Unrated
    |"17" -> InstrAttribType.Taxable
    |"18" -> InstrAttribType.Indexed
    |"19" -> InstrAttribType.SubjectToAlternativeMinimumTax
    |"20" -> InstrAttribType.OriginalIssueDiscountPrice
    |"21" -> InstrAttribType.CallableBelowMaturityValue
    |"22" -> InstrAttribType.CallableWithoutNoticeByMailToHolderUnlessRegistered
    |"99" -> InstrAttribType.Text
    | x -> failwith (sprintf "ReadInstrAttribType unknown fix tag: %A"  x) 


let WriteInstrAttribType (dest:byte array) (nextFreeIdx:int) (xxIn:InstrAttribType) : int =
    match xxIn with
    | InstrAttribType.Flat ->
        let tag = "871=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.ZeroCoupon ->
        let tag = "871=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.InterestBearing ->
        let tag = "871=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.NoPeriodicPayments ->
        let tag = "871=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.VariableRate ->
        let tag = "871=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.LessFeeForPut ->
        let tag = "871=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.SteppedCoupon ->
        let tag = "871=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CouponPeriod ->
        let tag = "871=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.WhenAndIfIssued ->
        let tag = "871=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.OriginalIssueDiscount ->
        let tag = "871=10"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallablePuttable ->
        let tag = "871=11"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.EscrowedToMaturity ->
        let tag = "871=12"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.EscrowedToRedemptionDate ->
        let tag = "871=13"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.PreRefunded ->
        let tag = "871=14"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.InDefault ->
        let tag = "871=15"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Unrated ->
        let tag = "871=16"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Taxable ->
        let tag = "871=17"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Indexed ->
        let tag = "871=18"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.SubjectToAlternativeMinimumTax ->
        let tag = "871=19"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.OriginalIssueDiscountPrice ->
        let tag = "871=20"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallableBelowMaturityValue ->
        let tag = "871=21"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.CallableWithoutNoticeByMailToHolderUnlessRegistered ->
        let tag = "871=22"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | InstrAttribType.Text ->
        let tag = "871=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadInstrAttribValue valIn =
    let tmp =  valIn
    InstrAttribValue.InstrAttribValue tmp


let WriteInstrAttribValue (dest:byte []) (nextFreeIdx:int) (valIn:InstrAttribValue) : int = 
   let tag = "872="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDatedDate valIn =
    let tmp =  valIn
    DatedDate.DatedDate tmp


let WriteDatedDate (dest:byte []) (nextFreeIdx:int) (valIn:DatedDate) : int = 
   let tag = "873="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadInterestAccrualDate valIn =
    let tmp =  valIn
    InterestAccrualDate.InterestAccrualDate tmp


let WriteInterestAccrualDate (dest:byte []) (nextFreeIdx:int) (valIn:InterestAccrualDate) : int = 
   let tag = "874="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCPProgram valIn =
    let tmp = System.Int32.Parse valIn
    CPProgram.CPProgram tmp


let WriteCPProgram (dest:byte []) (nextFreeIdx:int) (valIn:CPProgram) : int = 
   let tag = "875="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCPRegType valIn =
    let tmp =  valIn
    CPRegType.CPRegType tmp


let WriteCPRegType (dest:byte []) (nextFreeIdx:int) (valIn:CPRegType) : int = 
   let tag = "876="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCPProgram valIn =
    let tmp =  valIn
    UnderlyingCPProgram.UnderlyingCPProgram tmp


let WriteUnderlyingCPProgram (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCPProgram) : int = 
   let tag = "877="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCPRegType valIn =
    let tmp =  valIn
    UnderlyingCPRegType.UnderlyingCPRegType tmp


let WriteUnderlyingCPRegType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCPRegType) : int = 
   let tag = "878="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingQty valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingQty.UnderlyingQty tmp


let WriteUnderlyingQty (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingQty) : int = 
   let tag = "879="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTrdMatchID valIn =
    let tmp =  valIn
    TrdMatchID.TrdMatchID tmp


let WriteTrdMatchID (dest:byte []) (nextFreeIdx:int) (valIn:TrdMatchID) : int = 
   let tag = "880="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadSecondaryTradeReportRefID valIn =
    let tmp =  valIn
    SecondaryTradeReportRefID.SecondaryTradeReportRefID tmp


let WriteSecondaryTradeReportRefID (dest:byte []) (nextFreeIdx:int) (valIn:SecondaryTradeReportRefID) : int = 
   let tag = "881="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingDirtyPrice valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingDirtyPrice.UnderlyingDirtyPrice tmp


let WriteUnderlyingDirtyPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingDirtyPrice) : int = 
   let tag = "882="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingEndPrice valIn =
    let tmp = System.Decimal.Parse valIn
    UnderlyingEndPrice.UnderlyingEndPrice tmp


let WriteUnderlyingEndPrice (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingEndPrice) : int = 
   let tag = "883="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingStartValue valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingStartValue.UnderlyingStartValue tmp


let WriteUnderlyingStartValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStartValue) : int = 
   let tag = "884="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingCurrentValue valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingCurrentValue.UnderlyingCurrentValue tmp


let WriteUnderlyingCurrentValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingCurrentValue) : int = 
   let tag = "885="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingEndValue valIn =
    let tmp = System.Int32.Parse valIn
    UnderlyingEndValue.UnderlyingEndValue tmp


let WriteUnderlyingEndValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingEndValue) : int = 
   let tag = "886="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoUnderlyingStips valIn =
    let tmp = System.Int32.Parse valIn
    NoUnderlyingStips.NoUnderlyingStips tmp


let WriteNoUnderlyingStips (dest:byte []) (nextFreeIdx:int) (valIn:NoUnderlyingStips) : int = 
   let tag = "887="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingStipType valIn =
    let tmp =  valIn
    UnderlyingStipType.UnderlyingStipType tmp


let WriteUnderlyingStipType (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStipType) : int = 
   let tag = "888="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUnderlyingStipValue valIn =
    let tmp =  valIn
    UnderlyingStipValue.UnderlyingStipValue tmp


let WriteUnderlyingStipValue (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStipValue) : int = 
   let tag = "889="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMaturityNetMoney valIn =
    let tmp = System.Int32.Parse valIn
    MaturityNetMoney.MaturityNetMoney tmp


let WriteMaturityNetMoney (dest:byte []) (nextFreeIdx:int) (valIn:MaturityNetMoney) : int = 
   let tag = "890="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMiscFeeBasis (fldValIn:string) : MiscFeeBasis = 
    match fldValIn with
    |"0" -> MiscFeeBasis.Absolute
    |"1" -> MiscFeeBasis.PerUnit
    |"2" -> MiscFeeBasis.Percentage
    | x -> failwith (sprintf "ReadMiscFeeBasis unknown fix tag: %A"  x) 


let WriteMiscFeeBasis (dest:byte array) (nextFreeIdx:int) (xxIn:MiscFeeBasis) : int =
    match xxIn with
    | MiscFeeBasis.Absolute ->
        let tag = "891=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeBasis.PerUnit ->
        let tag = "891=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | MiscFeeBasis.Percentage ->
        let tag = "891=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNoAllocs valIn =
    let tmp = System.Int32.Parse valIn
    TotNoAllocs.TotNoAllocs tmp


let WriteTotNoAllocs (dest:byte []) (nextFreeIdx:int) (valIn:TotNoAllocs) : int = 
   let tag = "892="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastFragment valIn =
    let tmp = System.Boolean.Parse valIn
    LastFragment.LastFragment tmp


let WriteLastFragment (dest:byte []) (nextFreeIdx:int) (valIn:LastFragment) : int = 
   let tag = "893="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollReqID valIn =
    let tmp =  valIn
    CollReqID.CollReqID tmp


let WriteCollReqID (dest:byte []) (nextFreeIdx:int) (valIn:CollReqID) : int = 
   let tag = "894="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollAsgnReason (fldValIn:string) : CollAsgnReason = 
    match fldValIn with
    |"0" -> CollAsgnReason.Initial
    |"1" -> CollAsgnReason.Scheduled
    |"2" -> CollAsgnReason.TimeWarning
    |"3" -> CollAsgnReason.MarginDeficiency
    |"4" -> CollAsgnReason.MarginExcess
    |"5" -> CollAsgnReason.ForwardCollateralDemand
    |"6" -> CollAsgnReason.EventOfDefault
    |"7" -> CollAsgnReason.AdverseTaxEvent
    | x -> failwith (sprintf "ReadCollAsgnReason unknown fix tag: %A"  x) 


let WriteCollAsgnReason (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnReason) : int =
    match xxIn with
    | CollAsgnReason.Initial ->
        let tag = "895=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.Scheduled ->
        let tag = "895=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.TimeWarning ->
        let tag = "895=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.MarginDeficiency ->
        let tag = "895=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.MarginExcess ->
        let tag = "895=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.ForwardCollateralDemand ->
        let tag = "895=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.EventOfDefault ->
        let tag = "895=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnReason.AdverseTaxEvent ->
        let tag = "895=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryQualifier (fldValIn:string) : CollInquiryQualifier = 
    match fldValIn with
    |"0" -> CollInquiryQualifier.Tradedate
    |"1" -> CollInquiryQualifier.GcInstrument
    |"2" -> CollInquiryQualifier.Collateralinstrument
    |"3" -> CollInquiryQualifier.SubstitutionEligible
    |"4" -> CollInquiryQualifier.NotAssigned
    |"5" -> CollInquiryQualifier.PartiallyAssigned
    |"6" -> CollInquiryQualifier.FullyAssigned
    |"7" -> CollInquiryQualifier.OutstandingTrades
    | x -> failwith (sprintf "ReadCollInquiryQualifier unknown fix tag: %A"  x) 


let WriteCollInquiryQualifier (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryQualifier) : int =
    match xxIn with
    | CollInquiryQualifier.Tradedate ->
        let tag = "896=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.GcInstrument ->
        let tag = "896=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.Collateralinstrument ->
        let tag = "896=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.SubstitutionEligible ->
        let tag = "896=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.NotAssigned ->
        let tag = "896=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.PartiallyAssigned ->
        let tag = "896=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.FullyAssigned ->
        let tag = "896=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryQualifier.OutstandingTrades ->
        let tag = "896=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoTrades valIn =
    let tmp = System.Int32.Parse valIn
    NoTrades.NoTrades tmp


let WriteNoTrades (dest:byte []) (nextFreeIdx:int) (valIn:NoTrades) : int = 
   let tag = "897="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMarginRatio valIn =
    let tmp = System.Decimal.Parse valIn
    MarginRatio.MarginRatio tmp


let WriteMarginRatio (dest:byte []) (nextFreeIdx:int) (valIn:MarginRatio) : int = 
   let tag = "898="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadMarginExcess valIn =
    let tmp = System.Int32.Parse valIn
    MarginExcess.MarginExcess tmp


let WriteMarginExcess (dest:byte []) (nextFreeIdx:int) (valIn:MarginExcess) : int = 
   let tag = "899="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTotalNetValue valIn =
    let tmp = System.Int32.Parse valIn
    TotalNetValue.TotalNetValue tmp


let WriteTotalNetValue (dest:byte []) (nextFreeIdx:int) (valIn:TotalNetValue) : int = 
   let tag = "900="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCashOutstanding valIn =
    let tmp = System.Int32.Parse valIn
    CashOutstanding.CashOutstanding tmp


let WriteCashOutstanding (dest:byte []) (nextFreeIdx:int) (valIn:CashOutstanding) : int = 
   let tag = "901="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollAsgnID valIn =
    let tmp =  valIn
    CollAsgnID.CollAsgnID tmp


let WriteCollAsgnID (dest:byte []) (nextFreeIdx:int) (valIn:CollAsgnID) : int = 
   let tag = "902="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollAsgnTransType (fldValIn:string) : CollAsgnTransType = 
    match fldValIn with
    |"0" -> CollAsgnTransType.New
    |"1" -> CollAsgnTransType.Replace
    |"2" -> CollAsgnTransType.Cancel
    |"3" -> CollAsgnTransType.Release
    |"4" -> CollAsgnTransType.Reverse
    | x -> failwith (sprintf "ReadCollAsgnTransType unknown fix tag: %A"  x) 


let WriteCollAsgnTransType (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnTransType) : int =
    match xxIn with
    | CollAsgnTransType.New ->
        let tag = "903=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Replace ->
        let tag = "903=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Cancel ->
        let tag = "903=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Release ->
        let tag = "903=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnTransType.Reverse ->
        let tag = "903=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollRespID valIn =
    let tmp =  valIn
    CollRespID.CollRespID tmp


let WriteCollRespID (dest:byte []) (nextFreeIdx:int) (valIn:CollRespID) : int = 
   let tag = "904="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollAsgnRespType (fldValIn:string) : CollAsgnRespType = 
    match fldValIn with
    |"0" -> CollAsgnRespType.Received
    |"1" -> CollAsgnRespType.Accepted
    |"2" -> CollAsgnRespType.Declined
    |"3" -> CollAsgnRespType.Rejected
    | x -> failwith (sprintf "ReadCollAsgnRespType unknown fix tag: %A"  x) 


let WriteCollAsgnRespType (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnRespType) : int =
    match xxIn with
    | CollAsgnRespType.Received ->
        let tag = "905=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Accepted ->
        let tag = "905=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Declined ->
        let tag = "905=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRespType.Rejected ->
        let tag = "905=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollAsgnRejectReason (fldValIn:string) : CollAsgnRejectReason = 
    match fldValIn with
    |"0" -> CollAsgnRejectReason.UnknownDeal
    |"1" -> CollAsgnRejectReason.UnknownOrInvalidInstrument
    |"2" -> CollAsgnRejectReason.UnauthorizedTransaction
    |"3" -> CollAsgnRejectReason.InsufficientCollateral
    |"4" -> CollAsgnRejectReason.InvalidTypeOfCollateral
    |"5" -> CollAsgnRejectReason.ExcessiveSubstitution
    |"99" -> CollAsgnRejectReason.Other
    | x -> failwith (sprintf "ReadCollAsgnRejectReason unknown fix tag: %A"  x) 


let WriteCollAsgnRejectReason (dest:byte array) (nextFreeIdx:int) (xxIn:CollAsgnRejectReason) : int =
    match xxIn with
    | CollAsgnRejectReason.UnknownDeal ->
        let tag = "906=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.UnknownOrInvalidInstrument ->
        let tag = "906=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.UnauthorizedTransaction ->
        let tag = "906=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.InsufficientCollateral ->
        let tag = "906=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.InvalidTypeOfCollateral ->
        let tag = "906=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.ExcessiveSubstitution ->
        let tag = "906=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAsgnRejectReason.Other ->
        let tag = "906=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollAsgnRefID valIn =
    let tmp =  valIn
    CollAsgnRefID.CollAsgnRefID tmp


let WriteCollAsgnRefID (dest:byte []) (nextFreeIdx:int) (valIn:CollAsgnRefID) : int = 
   let tag = "907="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollRptID valIn =
    let tmp =  valIn
    CollRptID.CollRptID tmp


let WriteCollRptID (dest:byte []) (nextFreeIdx:int) (valIn:CollRptID) : int = 
   let tag = "908="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollInquiryID valIn =
    let tmp =  valIn
    CollInquiryID.CollInquiryID tmp


let WriteCollInquiryID (dest:byte []) (nextFreeIdx:int) (valIn:CollInquiryID) : int = 
   let tag = "909="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollStatus (fldValIn:string) : CollStatus = 
    match fldValIn with
    |"0" -> CollStatus.Unassigned
    |"1" -> CollStatus.PartiallyAssigned
    |"2" -> CollStatus.AssignmentProposed
    |"3" -> CollStatus.Assigned
    |"4" -> CollStatus.Challenged
    | x -> failwith (sprintf "ReadCollStatus unknown fix tag: %A"  x) 


let WriteCollStatus (dest:byte array) (nextFreeIdx:int) (xxIn:CollStatus) : int =
    match xxIn with
    | CollStatus.Unassigned ->
        let tag = "910=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.PartiallyAssigned ->
        let tag = "910=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.AssignmentProposed ->
        let tag = "910=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.Assigned ->
        let tag = "910=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollStatus.Challenged ->
        let tag = "910=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadTotNumReports valIn =
    let tmp = System.Int32.Parse valIn
    TotNumReports.TotNumReports tmp


let WriteTotNumReports (dest:byte []) (nextFreeIdx:int) (valIn:TotNumReports) : int = 
   let tag = "911="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastRptRequested valIn =
    let tmp = System.Boolean.Parse valIn
    LastRptRequested.LastRptRequested tmp


let WriteLastRptRequested (dest:byte []) (nextFreeIdx:int) (valIn:LastRptRequested) : int = 
   let tag = "912="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAgreementDesc valIn =
    let tmp =  valIn
    AgreementDesc.AgreementDesc tmp


let WriteAgreementDesc (dest:byte []) (nextFreeIdx:int) (valIn:AgreementDesc) : int = 
   let tag = "913="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAgreementID valIn =
    let tmp =  valIn
    AgreementID.AgreementID tmp


let WriteAgreementID (dest:byte []) (nextFreeIdx:int) (valIn:AgreementID) : int = 
   let tag = "914="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAgreementDate valIn =
    let tmp =  valIn
    AgreementDate.AgreementDate tmp


let WriteAgreementDate (dest:byte []) (nextFreeIdx:int) (valIn:AgreementDate) : int = 
   let tag = "915="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStartDate valIn =
    let tmp =  valIn
    StartDate.StartDate tmp


let WriteStartDate (dest:byte []) (nextFreeIdx:int) (valIn:StartDate) : int = 
   let tag = "916="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEndDate valIn =
    let tmp =  valIn
    EndDate.EndDate tmp


let WriteEndDate (dest:byte []) (nextFreeIdx:int) (valIn:EndDate) : int = 
   let tag = "917="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadAgreementCurrency valIn =
    let tmp =  valIn
    AgreementCurrency.AgreementCurrency tmp


let WriteAgreementCurrency (dest:byte []) (nextFreeIdx:int) (valIn:AgreementCurrency) : int = 
   let tag = "918="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadDeliveryType (fldValIn:string) : DeliveryType = 
    match fldValIn with
    |"0" -> DeliveryType.VersusPayment
    |"1" -> DeliveryType.Free
    |"2" -> DeliveryType.TriParty
    |"3" -> DeliveryType.HoldInCustody
    | x -> failwith (sprintf "ReadDeliveryType unknown fix tag: %A"  x) 


let WriteDeliveryType (dest:byte array) (nextFreeIdx:int) (xxIn:DeliveryType) : int =
    match xxIn with
    | DeliveryType.VersusPayment ->
        let tag = "919=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.Free ->
        let tag = "919=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.TriParty ->
        let tag = "919=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | DeliveryType.HoldInCustody ->
        let tag = "919=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadEndAccruedInterestAmt valIn =
    let tmp = System.Int32.Parse valIn
    EndAccruedInterestAmt.EndAccruedInterestAmt tmp


let WriteEndAccruedInterestAmt (dest:byte []) (nextFreeIdx:int) (valIn:EndAccruedInterestAmt) : int = 
   let tag = "920="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStartCash valIn =
    let tmp = System.Int32.Parse valIn
    StartCash.StartCash tmp


let WriteStartCash (dest:byte []) (nextFreeIdx:int) (valIn:StartCash) : int = 
   let tag = "921="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadEndCash valIn =
    let tmp = System.Int32.Parse valIn
    EndCash.EndCash tmp


let WriteEndCash (dest:byte []) (nextFreeIdx:int) (valIn:EndCash) : int = 
   let tag = "922="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUserRequestID valIn =
    let tmp =  valIn
    UserRequestID.UserRequestID tmp


let WriteUserRequestID (dest:byte []) (nextFreeIdx:int) (valIn:UserRequestID) : int = 
   let tag = "923="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUserRequestType (fldValIn:string) : UserRequestType = 
    match fldValIn with
    |"1" -> UserRequestType.Logonuser
    |"2" -> UserRequestType.Logoffuser
    |"3" -> UserRequestType.Changepasswordforuser
    |"4" -> UserRequestType.RequestIndividualUserStatus
    | x -> failwith (sprintf "ReadUserRequestType unknown fix tag: %A"  x) 


let WriteUserRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:UserRequestType) : int =
    match xxIn with
    | UserRequestType.Logonuser ->
        let tag = "924=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.Logoffuser ->
        let tag = "924=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.Changepasswordforuser ->
        let tag = "924=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserRequestType.RequestIndividualUserStatus ->
        let tag = "924=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNewPassword valIn =
    let tmp =  valIn
    NewPassword.NewPassword tmp


let WriteNewPassword (dest:byte []) (nextFreeIdx:int) (valIn:NewPassword) : int = 
   let tag = "925="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadUserStatus (fldValIn:string) : UserStatus = 
    match fldValIn with
    |"1" -> UserStatus.LoggedIn
    |"2" -> UserStatus.NotLoggedIn
    |"3" -> UserStatus.UserNotRecognised
    |"4" -> UserStatus.PasswordIncorrect
    |"5" -> UserStatus.PasswordChanged
    |"6" -> UserStatus.Other
    | x -> failwith (sprintf "ReadUserStatus unknown fix tag: %A"  x) 


let WriteUserStatus (dest:byte array) (nextFreeIdx:int) (xxIn:UserStatus) : int =
    match xxIn with
    | UserStatus.LoggedIn ->
        let tag = "926=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.NotLoggedIn ->
        let tag = "926=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.UserNotRecognised ->
        let tag = "926=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.PasswordIncorrect ->
        let tag = "926=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.PasswordChanged ->
        let tag = "926=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | UserStatus.Other ->
        let tag = "926=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUserStatusText valIn =
    let tmp =  valIn
    UserStatusText.UserStatusText tmp


let WriteUserStatusText (dest:byte []) (nextFreeIdx:int) (valIn:UserStatusText) : int = 
   let tag = "927="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadStatusValue (fldValIn:string) : StatusValue = 
    match fldValIn with
    |"1" -> StatusValue.Connected
    |"2" -> StatusValue.NotConnectedDownExpectedUp
    |"3" -> StatusValue.NotConnectedDownExpectedDown
    |"4" -> StatusValue.InProcess
    | x -> failwith (sprintf "ReadStatusValue unknown fix tag: %A"  x) 


let WriteStatusValue (dest:byte array) (nextFreeIdx:int) (xxIn:StatusValue) : int =
    match xxIn with
    | StatusValue.Connected ->
        let tag = "928=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.NotConnectedDownExpectedUp ->
        let tag = "928=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.NotConnectedDownExpectedDown ->
        let tag = "928=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | StatusValue.InProcess ->
        let tag = "928=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStatusText valIn =
    let tmp =  valIn
    StatusText.StatusText tmp


let WriteStatusText (dest:byte []) (nextFreeIdx:int) (valIn:StatusText) : int = 
   let tag = "929="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRefCompID valIn =
    let tmp =  valIn
    RefCompID.RefCompID tmp


let WriteRefCompID (dest:byte []) (nextFreeIdx:int) (valIn:RefCompID) : int = 
   let tag = "930="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadRefSubID valIn =
    let tmp =  valIn
    RefSubID.RefSubID tmp


let WriteRefSubID (dest:byte []) (nextFreeIdx:int) (valIn:RefSubID) : int = 
   let tag = "931="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetworkResponseID valIn =
    let tmp =  valIn
    NetworkResponseID.NetworkResponseID tmp


let WriteNetworkResponseID (dest:byte []) (nextFreeIdx:int) (valIn:NetworkResponseID) : int = 
   let tag = "932="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetworkRequestID valIn =
    let tmp =  valIn
    NetworkRequestID.NetworkRequestID tmp


let WriteNetworkRequestID (dest:byte []) (nextFreeIdx:int) (valIn:NetworkRequestID) : int = 
   let tag = "933="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLastNetworkResponseID valIn =
    let tmp =  valIn
    LastNetworkResponseID.LastNetworkResponseID tmp


let WriteLastNetworkResponseID (dest:byte []) (nextFreeIdx:int) (valIn:LastNetworkResponseID) : int = 
   let tag = "934="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetworkRequestType (fldValIn:string) : NetworkRequestType = 
    match fldValIn with
    |"1" -> NetworkRequestType.Snapshot
    |"2" -> NetworkRequestType.Subscribe
    |"4" -> NetworkRequestType.StopSubscribing
    |"8" -> NetworkRequestType.LevelOfDetail
    | x -> failwith (sprintf "ReadNetworkRequestType unknown fix tag: %A"  x) 


let WriteNetworkRequestType (dest:byte array) (nextFreeIdx:int) (xxIn:NetworkRequestType) : int =
    match xxIn with
    | NetworkRequestType.Snapshot ->
        let tag = "935=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.Subscribe ->
        let tag = "935=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.StopSubscribing ->
        let tag = "935=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkRequestType.LevelOfDetail ->
        let tag = "935=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoCompIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoCompIDs.NoCompIDs tmp


let WriteNoCompIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoCompIDs) : int = 
   let tag = "936="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNetworkStatusResponseType (fldValIn:string) : NetworkStatusResponseType = 
    match fldValIn with
    |"1" -> NetworkStatusResponseType.Full
    |"2" -> NetworkStatusResponseType.IncrementalUpdate
    | x -> failwith (sprintf "ReadNetworkStatusResponseType unknown fix tag: %A"  x) 


let WriteNetworkStatusResponseType (dest:byte array) (nextFreeIdx:int) (xxIn:NetworkStatusResponseType) : int =
    match xxIn with
    | NetworkStatusResponseType.Full ->
        let tag = "937=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | NetworkStatusResponseType.IncrementalUpdate ->
        let tag = "937=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadNoCollInquiryQualifier valIn =
    let tmp = System.Int32.Parse valIn
    NoCollInquiryQualifier.NoCollInquiryQualifier tmp


let WriteNoCollInquiryQualifier (dest:byte []) (nextFreeIdx:int) (valIn:NoCollInquiryQualifier) : int = 
   let tag = "938="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTrdRptStatus (fldValIn:string) : TrdRptStatus = 
    match fldValIn with
    |"0" -> TrdRptStatus.Accepted
    |"1" -> TrdRptStatus.Rejected
    | x -> failwith (sprintf "ReadTrdRptStatus unknown fix tag: %A"  x) 


let WriteTrdRptStatus (dest:byte array) (nextFreeIdx:int) (xxIn:TrdRptStatus) : int =
    match xxIn with
    | TrdRptStatus.Accepted ->
        let tag = "939=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | TrdRptStatus.Rejected ->
        let tag = "939=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadAffirmStatus (fldValIn:string) : AffirmStatus = 
    match fldValIn with
    |"1" -> AffirmStatus.Received
    |"2" -> AffirmStatus.ConfirmRejected
    |"3" -> AffirmStatus.Affirmed
    | x -> failwith (sprintf "ReadAffirmStatus unknown fix tag: %A"  x) 


let WriteAffirmStatus (dest:byte array) (nextFreeIdx:int) (xxIn:AffirmStatus) : int =
    match xxIn with
    | AffirmStatus.Received ->
        let tag = "940=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AffirmStatus.ConfirmRejected ->
        let tag = "940=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | AffirmStatus.Affirmed ->
        let tag = "940=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadUnderlyingStrikeCurrency valIn =
    let tmp =  valIn
    UnderlyingStrikeCurrency.UnderlyingStrikeCurrency tmp


let WriteUnderlyingStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:UnderlyingStrikeCurrency) : int = 
   let tag = "941="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegStrikeCurrency valIn =
    let tmp =  valIn
    LegStrikeCurrency.LegStrikeCurrency tmp


let WriteLegStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:LegStrikeCurrency) : int = 
   let tag = "942="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadTimeBracket valIn =
    let tmp =  valIn
    TimeBracket.TimeBracket tmp


let WriteTimeBracket (dest:byte []) (nextFreeIdx:int) (valIn:TimeBracket) : int = 
   let tag = "943="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadCollAction (fldValIn:string) : CollAction = 
    match fldValIn with
    |"0" -> CollAction.Retain
    |"1" -> CollAction.Add
    |"2" -> CollAction.Remove
    | x -> failwith (sprintf "ReadCollAction unknown fix tag: %A"  x) 


let WriteCollAction (dest:byte array) (nextFreeIdx:int) (xxIn:CollAction) : int =
    match xxIn with
    | CollAction.Retain ->
        let tag = "944=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAction.Add ->
        let tag = "944=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollAction.Remove ->
        let tag = "944=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryStatus (fldValIn:string) : CollInquiryStatus = 
    match fldValIn with
    |"0" -> CollInquiryStatus.Accepted
    |"1" -> CollInquiryStatus.AcceptedWithWarnings
    |"2" -> CollInquiryStatus.Completed
    |"3" -> CollInquiryStatus.CompletedWithWarnings
    |"4" -> CollInquiryStatus.Rejected
    | x -> failwith (sprintf "ReadCollInquiryStatus unknown fix tag: %A"  x) 


let WriteCollInquiryStatus (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryStatus) : int =
    match xxIn with
    | CollInquiryStatus.Accepted ->
        let tag = "945=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.AcceptedWithWarnings ->
        let tag = "945=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.Completed ->
        let tag = "945=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.CompletedWithWarnings ->
        let tag = "945=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryStatus.Rejected ->
        let tag = "945=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadCollInquiryResult (fldValIn:string) : CollInquiryResult = 
    match fldValIn with
    |"0" -> CollInquiryResult.Successful
    |"1" -> CollInquiryResult.InvalidOrUnknownInstrument
    |"2" -> CollInquiryResult.InvalidOrUnknownCollateralType
    |"3" -> CollInquiryResult.InvalidParties
    |"4" -> CollInquiryResult.InvalidTransportTypeRequested
    |"5" -> CollInquiryResult.InvalidDestinationRequested
    |"6" -> CollInquiryResult.NoCollateralFoundForTheTradeSpecified
    |"7" -> CollInquiryResult.NoCollateralFoundForTheOrderSpecified
    |"8" -> CollInquiryResult.CollateralInquiryTypeNotSupported
    |"9" -> CollInquiryResult.UnauthorizedForCollateralInquiry
    |"99" -> CollInquiryResult.Other
    | x -> failwith (sprintf "ReadCollInquiryResult unknown fix tag: %A"  x) 


let WriteCollInquiryResult (dest:byte array) (nextFreeIdx:int) (xxIn:CollInquiryResult) : int =
    match xxIn with
    | CollInquiryResult.Successful ->
        let tag = "946=0"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidOrUnknownInstrument ->
        let tag = "946=1"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidOrUnknownCollateralType ->
        let tag = "946=2"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidParties ->
        let tag = "946=3"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidTransportTypeRequested ->
        let tag = "946=4"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.InvalidDestinationRequested ->
        let tag = "946=5"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.NoCollateralFoundForTheTradeSpecified ->
        let tag = "946=6"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.NoCollateralFoundForTheOrderSpecified ->
        let tag = "946=7"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.CollateralInquiryTypeNotSupported ->
        let tag = "946=8"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.UnauthorizedForCollateralInquiry ->
        let tag = "946=9"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter
    | CollInquiryResult.Other ->
        let tag = "946=99"B
        Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
        let nextFreeIdx2 = nextFreeIdx + tag.Length
        dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
        nextFreeIdx2 + 1 // +1 to include the delimeter


let ReadStrikeCurrency valIn =
    let tmp =  valIn
    StrikeCurrency.StrikeCurrency tmp


let WriteStrikeCurrency (dest:byte []) (nextFreeIdx:int) (valIn:StrikeCurrency) : int = 
   let tag = "947="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNested3PartyIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNested3PartyIDs.NoNested3PartyIDs tmp


let WriteNoNested3PartyIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested3PartyIDs) : int = 
   let tag = "948="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested3PartyID valIn =
    let tmp =  valIn
    Nested3PartyID.Nested3PartyID tmp


let WriteNested3PartyID (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyID) : int = 
   let tag = "949="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested3PartyIDSource valIn =
    let tmp = System.Int32.Parse valIn
    Nested3PartyIDSource.Nested3PartyIDSource tmp


let WriteNested3PartyIDSource (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyIDSource) : int = 
   let tag = "950="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested3PartyRole valIn =
    let tmp = System.Int32.Parse valIn
    Nested3PartyRole.Nested3PartyRole tmp


let WriteNested3PartyRole (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartyRole) : int = 
   let tag = "951="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNoNested3PartySubIDs valIn =
    let tmp = System.Int32.Parse valIn
    NoNested3PartySubIDs.NoNested3PartySubIDs tmp


let WriteNoNested3PartySubIDs (dest:byte []) (nextFreeIdx:int) (valIn:NoNested3PartySubIDs) : int = 
   let tag = "952="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested3PartySubID valIn =
    let tmp =  valIn
    Nested3PartySubID.Nested3PartySubID tmp


let WriteNested3PartySubID (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartySubID) : int = 
   let tag = "953="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadNested3PartySubIDType valIn =
    let tmp = System.Int32.Parse valIn
    Nested3PartySubIDType.Nested3PartySubIDType tmp


let WriteNested3PartySubIDType (dest:byte []) (nextFreeIdx:int) (valIn:Nested3PartySubIDType) : int = 
   let tag = "954="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegContractSettlMonth valIn =
    let tmp =  valIn
    LegContractSettlMonth.LegContractSettlMonth tmp


let WriteLegContractSettlMonth (dest:byte []) (nextFreeIdx:int) (valIn:LegContractSettlMonth) : int = 
   let tag = "955="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter


let ReadLegInterestAccrualDate valIn =
    let tmp =  valIn
    LegInterestAccrualDate.LegInterestAccrualDate tmp


let WriteLegInterestAccrualDate (dest:byte []) (nextFreeIdx:int) (valIn:LegInterestAccrualDate) : int = 
   let tag = "956="B
   Buffer.BlockCopy (tag, 0, dest, nextFreeIdx, tag.Length)
   let nextFreeIdx2 = nextFreeIdx + tag.Length
   let bs = ToBytes.Convert(valIn.Value)
   Buffer.BlockCopy (bs, 0, dest, nextFreeIdx2, bs.Length)
   dest.[nextFreeIdx2] <- 1uy // write the SOH field delimeter
   nextFreeIdx2 + bs.Length + 1 // +1 to include the delimeter




let WriteField nextFreeIdx dest fixField =
    match fixField with
    | Account fixField -> WriteAccount nextFreeIdx dest fixField
    | AdvId fixField -> WriteAdvId nextFreeIdx dest fixField
    | AdvRefID fixField -> WriteAdvRefID nextFreeIdx dest fixField
    | AdvSide fixField -> WriteAdvSide nextFreeIdx dest fixField
    | AdvTransType fixField -> WriteAdvTransType nextFreeIdx dest fixField
    | AvgPx fixField -> WriteAvgPx nextFreeIdx dest fixField
    | BeginSeqNo fixField -> WriteBeginSeqNo nextFreeIdx dest fixField
    | BeginString fixField -> WriteBeginString nextFreeIdx dest fixField
    | BodyLength fixField -> WriteBodyLength nextFreeIdx dest fixField
    | CheckSum fixField -> WriteCheckSum nextFreeIdx dest fixField
    | ClOrdID fixField -> WriteClOrdID nextFreeIdx dest fixField
    | Commission fixField -> WriteCommission nextFreeIdx dest fixField
    | CommType fixField -> WriteCommType nextFreeIdx dest fixField
    | CumQty fixField -> WriteCumQty nextFreeIdx dest fixField
    | Currency fixField -> WriteCurrency nextFreeIdx dest fixField
    | EndSeqNo fixField -> WriteEndSeqNo nextFreeIdx dest fixField
    | ExecID fixField -> WriteExecID nextFreeIdx dest fixField
    | ExecInst fixField -> WriteExecInst nextFreeIdx dest fixField
    | ExecRefID fixField -> WriteExecRefID nextFreeIdx dest fixField
    | HandlInst fixField -> WriteHandlInst nextFreeIdx dest fixField
    | SecurityIDSource fixField -> WriteSecurityIDSource nextFreeIdx dest fixField
    | IOIid fixField -> WriteIOIid nextFreeIdx dest fixField
    | IOIQltyInd fixField -> WriteIOIQltyInd nextFreeIdx dest fixField
    | IOIRefID fixField -> WriteIOIRefID nextFreeIdx dest fixField
    | IOIQty fixField -> WriteIOIQty nextFreeIdx dest fixField
    | IOITransType fixField -> WriteIOITransType nextFreeIdx dest fixField
    | LastCapacity fixField -> WriteLastCapacity nextFreeIdx dest fixField
    | LastMkt fixField -> WriteLastMkt nextFreeIdx dest fixField
    | LastPx fixField -> WriteLastPx nextFreeIdx dest fixField
    | LastQty fixField -> WriteLastQty nextFreeIdx dest fixField
    | LinesOfText fixField -> WriteLinesOfText nextFreeIdx dest fixField
    | MsgSeqNum fixField -> WriteMsgSeqNum nextFreeIdx dest fixField
    | MsgType fixField -> WriteMsgType nextFreeIdx dest fixField
    | NewSeqNo fixField -> WriteNewSeqNo nextFreeIdx dest fixField
    | OrderID fixField -> WriteOrderID nextFreeIdx dest fixField
    | OrderQty fixField -> WriteOrderQty nextFreeIdx dest fixField
    | OrdStatus fixField -> WriteOrdStatus nextFreeIdx dest fixField
    | OrdType fixField -> WriteOrdType nextFreeIdx dest fixField
    | OrigClOrdID fixField -> WriteOrigClOrdID nextFreeIdx dest fixField
    | OrigTime fixField -> WriteOrigTime nextFreeIdx dest fixField
    | PossDupFlag fixField -> WritePossDupFlag nextFreeIdx dest fixField
    | Price fixField -> WritePrice nextFreeIdx dest fixField
    | RefSeqNum fixField -> WriteRefSeqNum nextFreeIdx dest fixField
    | SecurityID fixField -> WriteSecurityID nextFreeIdx dest fixField
    | SenderCompID fixField -> WriteSenderCompID nextFreeIdx dest fixField
    | SenderSubID fixField -> WriteSenderSubID nextFreeIdx dest fixField
    | SendingTime fixField -> WriteSendingTime nextFreeIdx dest fixField
    | Quantity fixField -> WriteQuantity nextFreeIdx dest fixField
    | Side fixField -> WriteSide nextFreeIdx dest fixField
    | Symbol fixField -> WriteSymbol nextFreeIdx dest fixField
    | TargetCompID fixField -> WriteTargetCompID nextFreeIdx dest fixField
    | TargetSubID fixField -> WriteTargetSubID nextFreeIdx dest fixField
    | Text fixField -> WriteText nextFreeIdx dest fixField
    | TimeInForce fixField -> WriteTimeInForce nextFreeIdx dest fixField
    | TransactTime fixField -> WriteTransactTime nextFreeIdx dest fixField
    | Urgency fixField -> WriteUrgency nextFreeIdx dest fixField
    | ValidUntilTime fixField -> WriteValidUntilTime nextFreeIdx dest fixField
    | SettlType fixField -> WriteSettlType nextFreeIdx dest fixField
    | SettlDate fixField -> WriteSettlDate nextFreeIdx dest fixField
    | SymbolSfx fixField -> WriteSymbolSfx nextFreeIdx dest fixField
    | ListID fixField -> WriteListID nextFreeIdx dest fixField
    | ListSeqNo fixField -> WriteListSeqNo nextFreeIdx dest fixField
    | TotNoOrders fixField -> WriteTotNoOrders nextFreeIdx dest fixField
    | ListExecInst fixField -> WriteListExecInst nextFreeIdx dest fixField
    | AllocID fixField -> WriteAllocID nextFreeIdx dest fixField
    | AllocTransType fixField -> WriteAllocTransType nextFreeIdx dest fixField
    | RefAllocID fixField -> WriteRefAllocID nextFreeIdx dest fixField
    | NoOrders fixField -> WriteNoOrders nextFreeIdx dest fixField
    | AvgPxPrecision fixField -> WriteAvgPxPrecision nextFreeIdx dest fixField
    | TradeDate fixField -> WriteTradeDate nextFreeIdx dest fixField
    | PositionEffect fixField -> WritePositionEffect nextFreeIdx dest fixField
    | NoAllocs fixField -> WriteNoAllocs nextFreeIdx dest fixField
    | AllocAccount fixField -> WriteAllocAccount nextFreeIdx dest fixField
    | AllocQty fixField -> WriteAllocQty nextFreeIdx dest fixField
    | ProcessCode fixField -> WriteProcessCode nextFreeIdx dest fixField
    | NoRpts fixField -> WriteNoRpts nextFreeIdx dest fixField
    | RptSeq fixField -> WriteRptSeq nextFreeIdx dest fixField
    | CxlQty fixField -> WriteCxlQty nextFreeIdx dest fixField
    | NoDlvyInst fixField -> WriteNoDlvyInst nextFreeIdx dest fixField
    | AllocStatus fixField -> WriteAllocStatus nextFreeIdx dest fixField
    | AllocRejCode fixField -> WriteAllocRejCode nextFreeIdx dest fixField
    | Signature fixField -> WriteSignature nextFreeIdx dest fixField
    | SecureData fixField -> WriteSecureData nextFreeIdx dest fixField // compound field
    | SignatureLength fixField -> WriteSignatureLength nextFreeIdx dest fixField
    | EmailType fixField -> WriteEmailType nextFreeIdx dest fixField
    | RawDataLength fixField -> WriteRawDataLength nextFreeIdx dest fixField
    | RawData fixField -> WriteRawData nextFreeIdx dest fixField
    | PossResend fixField -> WritePossResend nextFreeIdx dest fixField
    | EncryptMethod fixField -> WriteEncryptMethod nextFreeIdx dest fixField
    | StopPx fixField -> WriteStopPx nextFreeIdx dest fixField
    | ExDestination fixField -> WriteExDestination nextFreeIdx dest fixField
    | CxlRejReason fixField -> WriteCxlRejReason nextFreeIdx dest fixField
    | OrdRejReason fixField -> WriteOrdRejReason nextFreeIdx dest fixField
    | IOIQualifier fixField -> WriteIOIQualifier nextFreeIdx dest fixField
    | WaveNo fixField -> WriteWaveNo nextFreeIdx dest fixField
    | Issuer fixField -> WriteIssuer nextFreeIdx dest fixField
    | SecurityDesc fixField -> WriteSecurityDesc nextFreeIdx dest fixField
    | HeartBtInt fixField -> WriteHeartBtInt nextFreeIdx dest fixField
    | MinQty fixField -> WriteMinQty nextFreeIdx dest fixField
    | MaxFloor fixField -> WriteMaxFloor nextFreeIdx dest fixField
    | TestReqID fixField -> WriteTestReqID nextFreeIdx dest fixField
    | ReportToExch fixField -> WriteReportToExch nextFreeIdx dest fixField
    | LocateReqd fixField -> WriteLocateReqd nextFreeIdx dest fixField
    | OnBehalfOfCompID fixField -> WriteOnBehalfOfCompID nextFreeIdx dest fixField
    | OnBehalfOfSubID fixField -> WriteOnBehalfOfSubID nextFreeIdx dest fixField
    | QuoteID fixField -> WriteQuoteID nextFreeIdx dest fixField
    | NetMoney fixField -> WriteNetMoney nextFreeIdx dest fixField
    | SettlCurrAmt fixField -> WriteSettlCurrAmt nextFreeIdx dest fixField
    | SettlCurrency fixField -> WriteSettlCurrency nextFreeIdx dest fixField
    | ForexReq fixField -> WriteForexReq nextFreeIdx dest fixField
    | OrigSendingTime fixField -> WriteOrigSendingTime nextFreeIdx dest fixField
    | GapFillFlag fixField -> WriteGapFillFlag nextFreeIdx dest fixField
    | NoExecs fixField -> WriteNoExecs nextFreeIdx dest fixField
    | ExpireTime fixField -> WriteExpireTime nextFreeIdx dest fixField
    | DKReason fixField -> WriteDKReason nextFreeIdx dest fixField
    | DeliverToCompID fixField -> WriteDeliverToCompID nextFreeIdx dest fixField
    | DeliverToSubID fixField -> WriteDeliverToSubID nextFreeIdx dest fixField
    | IOINaturalFlag fixField -> WriteIOINaturalFlag nextFreeIdx dest fixField
    | QuoteReqID fixField -> WriteQuoteReqID nextFreeIdx dest fixField
    | BidPx fixField -> WriteBidPx nextFreeIdx dest fixField
    | OfferPx fixField -> WriteOfferPx nextFreeIdx dest fixField
    | BidSize fixField -> WriteBidSize nextFreeIdx dest fixField
    | OfferSize fixField -> WriteOfferSize nextFreeIdx dest fixField
    | NoMiscFees fixField -> WriteNoMiscFees nextFreeIdx dest fixField
    | MiscFeeAmt fixField -> WriteMiscFeeAmt nextFreeIdx dest fixField
    | MiscFeeCurr fixField -> WriteMiscFeeCurr nextFreeIdx dest fixField
    | MiscFeeType fixField -> WriteMiscFeeType nextFreeIdx dest fixField
    | PrevClosePx fixField -> WritePrevClosePx nextFreeIdx dest fixField
    | ResetSeqNumFlag fixField -> WriteResetSeqNumFlag nextFreeIdx dest fixField
    | SenderLocationID fixField -> WriteSenderLocationID nextFreeIdx dest fixField
    | TargetLocationID fixField -> WriteTargetLocationID nextFreeIdx dest fixField
    | OnBehalfOfLocationID fixField -> WriteOnBehalfOfLocationID nextFreeIdx dest fixField
    | DeliverToLocationID fixField -> WriteDeliverToLocationID nextFreeIdx dest fixField
    | NoRelatedSym fixField -> WriteNoRelatedSym nextFreeIdx dest fixField
    | Subject fixField -> WriteSubject nextFreeIdx dest fixField
    | Headline fixField -> WriteHeadline nextFreeIdx dest fixField
    | URLLink fixField -> WriteURLLink nextFreeIdx dest fixField
    | ExecType fixField -> WriteExecType nextFreeIdx dest fixField
    | LeavesQty fixField -> WriteLeavesQty nextFreeIdx dest fixField
    | CashOrderQty fixField -> WriteCashOrderQty nextFreeIdx dest fixField
    | AllocAvgPx fixField -> WriteAllocAvgPx nextFreeIdx dest fixField
    | AllocNetMoney fixField -> WriteAllocNetMoney nextFreeIdx dest fixField
    | SettlCurrFxRate fixField -> WriteSettlCurrFxRate nextFreeIdx dest fixField
    | SettlCurrFxRateCalc fixField -> WriteSettlCurrFxRateCalc nextFreeIdx dest fixField
    | NumDaysInterest fixField -> WriteNumDaysInterest nextFreeIdx dest fixField
    | AccruedInterestRate fixField -> WriteAccruedInterestRate nextFreeIdx dest fixField
    | AccruedInterestAmt fixField -> WriteAccruedInterestAmt nextFreeIdx dest fixField
    | SettlInstMode fixField -> WriteSettlInstMode nextFreeIdx dest fixField
    | AllocText fixField -> WriteAllocText nextFreeIdx dest fixField
    | SettlInstID fixField -> WriteSettlInstID nextFreeIdx dest fixField
    | SettlInstTransType fixField -> WriteSettlInstTransType nextFreeIdx dest fixField
    | EmailThreadID fixField -> WriteEmailThreadID nextFreeIdx dest fixField
    | SettlInstSource fixField -> WriteSettlInstSource nextFreeIdx dest fixField
    | SecurityType fixField -> WriteSecurityType nextFreeIdx dest fixField
    | EffectiveTime fixField -> WriteEffectiveTime nextFreeIdx dest fixField
    | StandInstDbType fixField -> WriteStandInstDbType nextFreeIdx dest fixField
    | StandInstDbName fixField -> WriteStandInstDbName nextFreeIdx dest fixField
    | StandInstDbID fixField -> WriteStandInstDbID nextFreeIdx dest fixField
    | SettlDeliveryType fixField -> WriteSettlDeliveryType nextFreeIdx dest fixField
    | BidSpotRate fixField -> WriteBidSpotRate nextFreeIdx dest fixField
    | BidForwardPoints fixField -> WriteBidForwardPoints nextFreeIdx dest fixField
    | OfferSpotRate fixField -> WriteOfferSpotRate nextFreeIdx dest fixField
    | OfferForwardPoints fixField -> WriteOfferForwardPoints nextFreeIdx dest fixField
    | OrderQty2 fixField -> WriteOrderQty2 nextFreeIdx dest fixField
    | SettlDate2 fixField -> WriteSettlDate2 nextFreeIdx dest fixField
    | LastSpotRate fixField -> WriteLastSpotRate nextFreeIdx dest fixField
    | LastForwardPoints fixField -> WriteLastForwardPoints nextFreeIdx dest fixField
    | AllocLinkID fixField -> WriteAllocLinkID nextFreeIdx dest fixField
    | AllocLinkType fixField -> WriteAllocLinkType nextFreeIdx dest fixField
    | SecondaryOrderID fixField -> WriteSecondaryOrderID nextFreeIdx dest fixField
    | NoIOIQualifiers fixField -> WriteNoIOIQualifiers nextFreeIdx dest fixField
    | MaturityMonthYear fixField -> WriteMaturityMonthYear nextFreeIdx dest fixField
    | PutOrCall fixField -> WritePutOrCall nextFreeIdx dest fixField
    | StrikePrice fixField -> WriteStrikePrice nextFreeIdx dest fixField
    | CoveredOrUncovered fixField -> WriteCoveredOrUncovered nextFreeIdx dest fixField
    | OptAttribute fixField -> WriteOptAttribute nextFreeIdx dest fixField
    | SecurityExchange fixField -> WriteSecurityExchange nextFreeIdx dest fixField
    | NotifyBrokerOfCredit fixField -> WriteNotifyBrokerOfCredit nextFreeIdx dest fixField
    | AllocHandlInst fixField -> WriteAllocHandlInst nextFreeIdx dest fixField
    | MaxShow fixField -> WriteMaxShow nextFreeIdx dest fixField
    | PegOffsetValue fixField -> WritePegOffsetValue nextFreeIdx dest fixField
    | XmlData fixField -> WriteXmlData nextFreeIdx dest fixField // compound field
    | SettlInstRefID fixField -> WriteSettlInstRefID nextFreeIdx dest fixField
    | NoRoutingIDs fixField -> WriteNoRoutingIDs nextFreeIdx dest fixField
    | RoutingType fixField -> WriteRoutingType nextFreeIdx dest fixField
    | RoutingID fixField -> WriteRoutingID nextFreeIdx dest fixField
    | Spread fixField -> WriteSpread nextFreeIdx dest fixField
    | BenchmarkCurveCurrency fixField -> WriteBenchmarkCurveCurrency nextFreeIdx dest fixField
    | BenchmarkCurveName fixField -> WriteBenchmarkCurveName nextFreeIdx dest fixField
    | BenchmarkCurvePoint fixField -> WriteBenchmarkCurvePoint nextFreeIdx dest fixField
    | CouponRate fixField -> WriteCouponRate nextFreeIdx dest fixField
    | CouponPaymentDate fixField -> WriteCouponPaymentDate nextFreeIdx dest fixField
    | IssueDate fixField -> WriteIssueDate nextFreeIdx dest fixField
    | RepurchaseTerm fixField -> WriteRepurchaseTerm nextFreeIdx dest fixField
    | RepurchaseRate fixField -> WriteRepurchaseRate nextFreeIdx dest fixField
    | Factor fixField -> WriteFactor nextFreeIdx dest fixField
    | TradeOriginationDate fixField -> WriteTradeOriginationDate nextFreeIdx dest fixField
    | ExDate fixField -> WriteExDate nextFreeIdx dest fixField
    | ContractMultiplier fixField -> WriteContractMultiplier nextFreeIdx dest fixField
    | NoStipulations fixField -> WriteNoStipulations nextFreeIdx dest fixField
    | StipulationType fixField -> WriteStipulationType nextFreeIdx dest fixField
    | StipulationValue fixField -> WriteStipulationValue nextFreeIdx dest fixField
    | YieldType fixField -> WriteYieldType nextFreeIdx dest fixField
    | Yield fixField -> WriteYield nextFreeIdx dest fixField
    | TotalTakedown fixField -> WriteTotalTakedown nextFreeIdx dest fixField
    | Concession fixField -> WriteConcession nextFreeIdx dest fixField
    | RepoCollateralSecurityType fixField -> WriteRepoCollateralSecurityType nextFreeIdx dest fixField
    | RedemptionDate fixField -> WriteRedemptionDate nextFreeIdx dest fixField
    | UnderlyingCouponPaymentDate fixField -> WriteUnderlyingCouponPaymentDate nextFreeIdx dest fixField
    | UnderlyingIssueDate fixField -> WriteUnderlyingIssueDate nextFreeIdx dest fixField
    | UnderlyingRepoCollateralSecurityType fixField -> WriteUnderlyingRepoCollateralSecurityType nextFreeIdx dest fixField
    | UnderlyingRepurchaseTerm fixField -> WriteUnderlyingRepurchaseTerm nextFreeIdx dest fixField
    | UnderlyingRepurchaseRate fixField -> WriteUnderlyingRepurchaseRate nextFreeIdx dest fixField
    | UnderlyingFactor fixField -> WriteUnderlyingFactor nextFreeIdx dest fixField
    | UnderlyingRedemptionDate fixField -> WriteUnderlyingRedemptionDate nextFreeIdx dest fixField
    | LegCouponPaymentDate fixField -> WriteLegCouponPaymentDate nextFreeIdx dest fixField
    | LegIssueDate fixField -> WriteLegIssueDate nextFreeIdx dest fixField
    | LegRepoCollateralSecurityType fixField -> WriteLegRepoCollateralSecurityType nextFreeIdx dest fixField
    | LegRepurchaseTerm fixField -> WriteLegRepurchaseTerm nextFreeIdx dest fixField
    | LegRepurchaseRate fixField -> WriteLegRepurchaseRate nextFreeIdx dest fixField
    | LegFactor fixField -> WriteLegFactor nextFreeIdx dest fixField
    | LegRedemptionDate fixField -> WriteLegRedemptionDate nextFreeIdx dest fixField
    | CreditRating fixField -> WriteCreditRating nextFreeIdx dest fixField
    | UnderlyingCreditRating fixField -> WriteUnderlyingCreditRating nextFreeIdx dest fixField
    | LegCreditRating fixField -> WriteLegCreditRating nextFreeIdx dest fixField
    | TradedFlatSwitch fixField -> WriteTradedFlatSwitch nextFreeIdx dest fixField
    | BasisFeatureDate fixField -> WriteBasisFeatureDate nextFreeIdx dest fixField
    | BasisFeaturePrice fixField -> WriteBasisFeaturePrice nextFreeIdx dest fixField
    | MDReqID fixField -> WriteMDReqID nextFreeIdx dest fixField
    | SubscriptionRequestType fixField -> WriteSubscriptionRequestType nextFreeIdx dest fixField
    | MarketDepth fixField -> WriteMarketDepth nextFreeIdx dest fixField
    | MDUpdateType fixField -> WriteMDUpdateType nextFreeIdx dest fixField
    | AggregatedBook fixField -> WriteAggregatedBook nextFreeIdx dest fixField
    | NoMDEntryTypes fixField -> WriteNoMDEntryTypes nextFreeIdx dest fixField
    | NoMDEntries fixField -> WriteNoMDEntries nextFreeIdx dest fixField
    | MDEntryType fixField -> WriteMDEntryType nextFreeIdx dest fixField
    | MDEntryPx fixField -> WriteMDEntryPx nextFreeIdx dest fixField
    | MDEntrySize fixField -> WriteMDEntrySize nextFreeIdx dest fixField
    | MDEntryDate fixField -> WriteMDEntryDate nextFreeIdx dest fixField
    | MDEntryTime fixField -> WriteMDEntryTime nextFreeIdx dest fixField
    | TickDirection fixField -> WriteTickDirection nextFreeIdx dest fixField
    | MDMkt fixField -> WriteMDMkt nextFreeIdx dest fixField
    | QuoteCondition fixField -> WriteQuoteCondition nextFreeIdx dest fixField
    | TradeCondition fixField -> WriteTradeCondition nextFreeIdx dest fixField
    | MDEntryID fixField -> WriteMDEntryID nextFreeIdx dest fixField
    | MDUpdateAction fixField -> WriteMDUpdateAction nextFreeIdx dest fixField
    | MDEntryRefID fixField -> WriteMDEntryRefID nextFreeIdx dest fixField
    | MDReqRejReason fixField -> WriteMDReqRejReason nextFreeIdx dest fixField
    | MDEntryOriginator fixField -> WriteMDEntryOriginator nextFreeIdx dest fixField
    | LocationID fixField -> WriteLocationID nextFreeIdx dest fixField
    | DeskID fixField -> WriteDeskID nextFreeIdx dest fixField
    | DeleteReason fixField -> WriteDeleteReason nextFreeIdx dest fixField
    | OpenCloseSettlFlag fixField -> WriteOpenCloseSettlFlag nextFreeIdx dest fixField
    | SellerDays fixField -> WriteSellerDays nextFreeIdx dest fixField
    | MDEntryBuyer fixField -> WriteMDEntryBuyer nextFreeIdx dest fixField
    | MDEntrySeller fixField -> WriteMDEntrySeller nextFreeIdx dest fixField
    | MDEntryPositionNo fixField -> WriteMDEntryPositionNo nextFreeIdx dest fixField
    | FinancialStatus fixField -> WriteFinancialStatus nextFreeIdx dest fixField
    | CorporateAction fixField -> WriteCorporateAction nextFreeIdx dest fixField
    | DefBidSize fixField -> WriteDefBidSize nextFreeIdx dest fixField
    | DefOfferSize fixField -> WriteDefOfferSize nextFreeIdx dest fixField
    | NoQuoteEntries fixField -> WriteNoQuoteEntries nextFreeIdx dest fixField
    | NoQuoteSets fixField -> WriteNoQuoteSets nextFreeIdx dest fixField
    | QuoteStatus fixField -> WriteQuoteStatus nextFreeIdx dest fixField
    | QuoteCancelType fixField -> WriteQuoteCancelType nextFreeIdx dest fixField
    | QuoteEntryID fixField -> WriteQuoteEntryID nextFreeIdx dest fixField
    | QuoteRejectReason fixField -> WriteQuoteRejectReason nextFreeIdx dest fixField
    | QuoteResponseLevel fixField -> WriteQuoteResponseLevel nextFreeIdx dest fixField
    | QuoteSetID fixField -> WriteQuoteSetID nextFreeIdx dest fixField
    | QuoteRequestType fixField -> WriteQuoteRequestType nextFreeIdx dest fixField
    | TotNoQuoteEntries fixField -> WriteTotNoQuoteEntries nextFreeIdx dest fixField
    | UnderlyingSecurityIDSource fixField -> WriteUnderlyingSecurityIDSource nextFreeIdx dest fixField
    | UnderlyingIssuer fixField -> WriteUnderlyingIssuer nextFreeIdx dest fixField
    | UnderlyingSecurityDesc fixField -> WriteUnderlyingSecurityDesc nextFreeIdx dest fixField
    | UnderlyingSecurityExchange fixField -> WriteUnderlyingSecurityExchange nextFreeIdx dest fixField
    | UnderlyingSecurityID fixField -> WriteUnderlyingSecurityID nextFreeIdx dest fixField
    | UnderlyingSecurityType fixField -> WriteUnderlyingSecurityType nextFreeIdx dest fixField
    | UnderlyingSymbol fixField -> WriteUnderlyingSymbol nextFreeIdx dest fixField
    | UnderlyingSymbolSfx fixField -> WriteUnderlyingSymbolSfx nextFreeIdx dest fixField
    | UnderlyingMaturityMonthYear fixField -> WriteUnderlyingMaturityMonthYear nextFreeIdx dest fixField
    | UnderlyingPutOrCall fixField -> WriteUnderlyingPutOrCall nextFreeIdx dest fixField
    | UnderlyingStrikePrice fixField -> WriteUnderlyingStrikePrice nextFreeIdx dest fixField
    | UnderlyingOptAttribute fixField -> WriteUnderlyingOptAttribute nextFreeIdx dest fixField
    | UnderlyingCurrency fixField -> WriteUnderlyingCurrency nextFreeIdx dest fixField
    | SecurityReqID fixField -> WriteSecurityReqID nextFreeIdx dest fixField
    | SecurityRequestType fixField -> WriteSecurityRequestType nextFreeIdx dest fixField
    | SecurityResponseID fixField -> WriteSecurityResponseID nextFreeIdx dest fixField
    | SecurityResponseType fixField -> WriteSecurityResponseType nextFreeIdx dest fixField
    | SecurityStatusReqID fixField -> WriteSecurityStatusReqID nextFreeIdx dest fixField
    | UnsolicitedIndicator fixField -> WriteUnsolicitedIndicator nextFreeIdx dest fixField
    | SecurityTradingStatus fixField -> WriteSecurityTradingStatus nextFreeIdx dest fixField
    | HaltReason fixField -> WriteHaltReason nextFreeIdx dest fixField
    | InViewOfCommon fixField -> WriteInViewOfCommon nextFreeIdx dest fixField
    | DueToRelated fixField -> WriteDueToRelated nextFreeIdx dest fixField
    | BuyVolume fixField -> WriteBuyVolume nextFreeIdx dest fixField
    | SellVolume fixField -> WriteSellVolume nextFreeIdx dest fixField
    | HighPx fixField -> WriteHighPx nextFreeIdx dest fixField
    | LowPx fixField -> WriteLowPx nextFreeIdx dest fixField
    | Adjustment fixField -> WriteAdjustment nextFreeIdx dest fixField
    | TradSesReqID fixField -> WriteTradSesReqID nextFreeIdx dest fixField
    | TradingSessionID fixField -> WriteTradingSessionID nextFreeIdx dest fixField
    | ContraTrader fixField -> WriteContraTrader nextFreeIdx dest fixField
    | TradSesMethod fixField -> WriteTradSesMethod nextFreeIdx dest fixField
    | TradSesMode fixField -> WriteTradSesMode nextFreeIdx dest fixField
    | TradSesStatus fixField -> WriteTradSesStatus nextFreeIdx dest fixField
    | TradSesStartTime fixField -> WriteTradSesStartTime nextFreeIdx dest fixField
    | TradSesOpenTime fixField -> WriteTradSesOpenTime nextFreeIdx dest fixField
    | TradSesPreCloseTime fixField -> WriteTradSesPreCloseTime nextFreeIdx dest fixField
    | TradSesCloseTime fixField -> WriteTradSesCloseTime nextFreeIdx dest fixField
    | TradSesEndTime fixField -> WriteTradSesEndTime nextFreeIdx dest fixField
    | NumberOfOrders fixField -> WriteNumberOfOrders nextFreeIdx dest fixField
    | MessageEncoding fixField -> WriteMessageEncoding nextFreeIdx dest fixField
    | EncodedIssuer fixField -> WriteEncodedIssuer nextFreeIdx dest fixField // compound field
    | EncodedSecurityDesc fixField -> WriteEncodedSecurityDesc nextFreeIdx dest fixField // compound field
    | EncodedListExecInst fixField -> WriteEncodedListExecInst nextFreeIdx dest fixField // compound field
    | EncodedText fixField -> WriteEncodedText nextFreeIdx dest fixField // compound field
    | EncodedSubject fixField -> WriteEncodedSubject nextFreeIdx dest fixField // compound field
    | EncodedHeadline fixField -> WriteEncodedHeadline nextFreeIdx dest fixField // compound field
    | EncodedAllocText fixField -> WriteEncodedAllocText nextFreeIdx dest fixField // compound field
    | EncodedUnderlyingIssuer fixField -> WriteEncodedUnderlyingIssuer nextFreeIdx dest fixField // compound field
    | EncodedUnderlyingSecurityDesc fixField -> WriteEncodedUnderlyingSecurityDesc nextFreeIdx dest fixField // compound field
    | AllocPrice fixField -> WriteAllocPrice nextFreeIdx dest fixField
    | QuoteSetValidUntilTime fixField -> WriteQuoteSetValidUntilTime nextFreeIdx dest fixField
    | QuoteEntryRejectReason fixField -> WriteQuoteEntryRejectReason nextFreeIdx dest fixField
    | LastMsgSeqNumProcessed fixField -> WriteLastMsgSeqNumProcessed nextFreeIdx dest fixField
    | RefTagID fixField -> WriteRefTagID nextFreeIdx dest fixField
    | RefMsgType fixField -> WriteRefMsgType nextFreeIdx dest fixField
    | SessionRejectReason fixField -> WriteSessionRejectReason nextFreeIdx dest fixField
    | BidRequestTransType fixField -> WriteBidRequestTransType nextFreeIdx dest fixField
    | ContraBroker fixField -> WriteContraBroker nextFreeIdx dest fixField
    | ComplianceID fixField -> WriteComplianceID nextFreeIdx dest fixField
    | SolicitedFlag fixField -> WriteSolicitedFlag nextFreeIdx dest fixField
    | ExecRestatementReason fixField -> WriteExecRestatementReason nextFreeIdx dest fixField
    | BusinessRejectRefID fixField -> WriteBusinessRejectRefID nextFreeIdx dest fixField
    | BusinessRejectReason fixField -> WriteBusinessRejectReason nextFreeIdx dest fixField
    | GrossTradeAmt fixField -> WriteGrossTradeAmt nextFreeIdx dest fixField
    | NoContraBrokers fixField -> WriteNoContraBrokers nextFreeIdx dest fixField
    | MaxMessageSize fixField -> WriteMaxMessageSize nextFreeIdx dest fixField
    | NoMsgTypes fixField -> WriteNoMsgTypes nextFreeIdx dest fixField
    | MsgDirection fixField -> WriteMsgDirection nextFreeIdx dest fixField
    | NoTradingSessions fixField -> WriteNoTradingSessions nextFreeIdx dest fixField
    | TotalVolumeTraded fixField -> WriteTotalVolumeTraded nextFreeIdx dest fixField
    | DiscretionInst fixField -> WriteDiscretionInst nextFreeIdx dest fixField
    | DiscretionOffsetValue fixField -> WriteDiscretionOffsetValue nextFreeIdx dest fixField
    | BidID fixField -> WriteBidID nextFreeIdx dest fixField
    | ClientBidID fixField -> WriteClientBidID nextFreeIdx dest fixField
    | ListName fixField -> WriteListName nextFreeIdx dest fixField
    | TotNoRelatedSym fixField -> WriteTotNoRelatedSym nextFreeIdx dest fixField
    | BidType fixField -> WriteBidType nextFreeIdx dest fixField
    | NumTickets fixField -> WriteNumTickets nextFreeIdx dest fixField
    | SideValue1 fixField -> WriteSideValue1 nextFreeIdx dest fixField
    | SideValue2 fixField -> WriteSideValue2 nextFreeIdx dest fixField
    | NoBidDescriptors fixField -> WriteNoBidDescriptors nextFreeIdx dest fixField
    | BidDescriptorType fixField -> WriteBidDescriptorType nextFreeIdx dest fixField
    | BidDescriptor fixField -> WriteBidDescriptor nextFreeIdx dest fixField
    | SideValueInd fixField -> WriteSideValueInd nextFreeIdx dest fixField
    | LiquidityPctLow fixField -> WriteLiquidityPctLow nextFreeIdx dest fixField
    | LiquidityPctHigh fixField -> WriteLiquidityPctHigh nextFreeIdx dest fixField
    | LiquidityValue fixField -> WriteLiquidityValue nextFreeIdx dest fixField
    | EFPTrackingError fixField -> WriteEFPTrackingError nextFreeIdx dest fixField
    | FairValue fixField -> WriteFairValue nextFreeIdx dest fixField
    | OutsideIndexPct fixField -> WriteOutsideIndexPct nextFreeIdx dest fixField
    | ValueOfFutures fixField -> WriteValueOfFutures nextFreeIdx dest fixField
    | LiquidityIndType fixField -> WriteLiquidityIndType nextFreeIdx dest fixField
    | WtAverageLiquidity fixField -> WriteWtAverageLiquidity nextFreeIdx dest fixField
    | ExchangeForPhysical fixField -> WriteExchangeForPhysical nextFreeIdx dest fixField
    | OutMainCntryUIndex fixField -> WriteOutMainCntryUIndex nextFreeIdx dest fixField
    | CrossPercent fixField -> WriteCrossPercent nextFreeIdx dest fixField
    | ProgRptReqs fixField -> WriteProgRptReqs nextFreeIdx dest fixField
    | ProgPeriodInterval fixField -> WriteProgPeriodInterval nextFreeIdx dest fixField
    | IncTaxInd fixField -> WriteIncTaxInd nextFreeIdx dest fixField
    | NumBidders fixField -> WriteNumBidders nextFreeIdx dest fixField
    | BidTradeType fixField -> WriteBidTradeType nextFreeIdx dest fixField
    | BasisPxType fixField -> WriteBasisPxType nextFreeIdx dest fixField
    | NoBidComponents fixField -> WriteNoBidComponents nextFreeIdx dest fixField
    | Country fixField -> WriteCountry nextFreeIdx dest fixField
    | TotNoStrikes fixField -> WriteTotNoStrikes nextFreeIdx dest fixField
    | PriceType fixField -> WritePriceType nextFreeIdx dest fixField
    | DayOrderQty fixField -> WriteDayOrderQty nextFreeIdx dest fixField
    | DayCumQty fixField -> WriteDayCumQty nextFreeIdx dest fixField
    | DayAvgPx fixField -> WriteDayAvgPx nextFreeIdx dest fixField
    | GTBookingInst fixField -> WriteGTBookingInst nextFreeIdx dest fixField
    | NoStrikes fixField -> WriteNoStrikes nextFreeIdx dest fixField
    | ListStatusType fixField -> WriteListStatusType nextFreeIdx dest fixField
    | NetGrossInd fixField -> WriteNetGrossInd nextFreeIdx dest fixField
    | ListOrderStatus fixField -> WriteListOrderStatus nextFreeIdx dest fixField
    | ExpireDate fixField -> WriteExpireDate nextFreeIdx dest fixField
    | ListExecInstType fixField -> WriteListExecInstType nextFreeIdx dest fixField
    | CxlRejResponseTo fixField -> WriteCxlRejResponseTo nextFreeIdx dest fixField
    | UnderlyingCouponRate fixField -> WriteUnderlyingCouponRate nextFreeIdx dest fixField
    | UnderlyingContractMultiplier fixField -> WriteUnderlyingContractMultiplier nextFreeIdx dest fixField
    | ContraTradeQty fixField -> WriteContraTradeQty nextFreeIdx dest fixField
    | ContraTradeTime fixField -> WriteContraTradeTime nextFreeIdx dest fixField
    | LiquidityNumSecurities fixField -> WriteLiquidityNumSecurities nextFreeIdx dest fixField
    | MultiLegReportingType fixField -> WriteMultiLegReportingType nextFreeIdx dest fixField
    | StrikeTime fixField -> WriteStrikeTime nextFreeIdx dest fixField
    | ListStatusText fixField -> WriteListStatusText nextFreeIdx dest fixField
    | EncodedListStatusText fixField -> WriteEncodedListStatusText nextFreeIdx dest fixField // compound field
    | PartyIDSource fixField -> WritePartyIDSource nextFreeIdx dest fixField
    | PartyID fixField -> WritePartyID nextFreeIdx dest fixField
    | NetChgPrevDay fixField -> WriteNetChgPrevDay nextFreeIdx dest fixField
    | PartyRole fixField -> WritePartyRole nextFreeIdx dest fixField
    | NoPartyIDs fixField -> WriteNoPartyIDs nextFreeIdx dest fixField
    | NoSecurityAltID fixField -> WriteNoSecurityAltID nextFreeIdx dest fixField
    | SecurityAltID fixField -> WriteSecurityAltID nextFreeIdx dest fixField
    | SecurityAltIDSource fixField -> WriteSecurityAltIDSource nextFreeIdx dest fixField
    | NoUnderlyingSecurityAltID fixField -> WriteNoUnderlyingSecurityAltID nextFreeIdx dest fixField
    | UnderlyingSecurityAltID fixField -> WriteUnderlyingSecurityAltID nextFreeIdx dest fixField
    | UnderlyingSecurityAltIDSource fixField -> WriteUnderlyingSecurityAltIDSource nextFreeIdx dest fixField
    | Product fixField -> WriteProduct nextFreeIdx dest fixField
    | CFICode fixField -> WriteCFICode nextFreeIdx dest fixField
    | UnderlyingProduct fixField -> WriteUnderlyingProduct nextFreeIdx dest fixField
    | UnderlyingCFICode fixField -> WriteUnderlyingCFICode nextFreeIdx dest fixField
    | TestMessageIndicator fixField -> WriteTestMessageIndicator nextFreeIdx dest fixField
    | QuantityType fixField -> WriteQuantityType nextFreeIdx dest fixField
    | BookingRefID fixField -> WriteBookingRefID nextFreeIdx dest fixField
    | IndividualAllocID fixField -> WriteIndividualAllocID nextFreeIdx dest fixField
    | RoundingDirection fixField -> WriteRoundingDirection nextFreeIdx dest fixField
    | RoundingModulus fixField -> WriteRoundingModulus nextFreeIdx dest fixField
    | CountryOfIssue fixField -> WriteCountryOfIssue nextFreeIdx dest fixField
    | StateOrProvinceOfIssue fixField -> WriteStateOrProvinceOfIssue nextFreeIdx dest fixField
    | LocaleOfIssue fixField -> WriteLocaleOfIssue nextFreeIdx dest fixField
    | NoRegistDtls fixField -> WriteNoRegistDtls nextFreeIdx dest fixField
    | MailingDtls fixField -> WriteMailingDtls nextFreeIdx dest fixField
    | InvestorCountryOfResidence fixField -> WriteInvestorCountryOfResidence nextFreeIdx dest fixField
    | PaymentRef fixField -> WritePaymentRef nextFreeIdx dest fixField
    | DistribPaymentMethod fixField -> WriteDistribPaymentMethod nextFreeIdx dest fixField
    | CashDistribCurr fixField -> WriteCashDistribCurr nextFreeIdx dest fixField
    | CommCurrency fixField -> WriteCommCurrency nextFreeIdx dest fixField
    | CancellationRights fixField -> WriteCancellationRights nextFreeIdx dest fixField
    | MoneyLaunderingStatus fixField -> WriteMoneyLaunderingStatus nextFreeIdx dest fixField
    | MailingInst fixField -> WriteMailingInst nextFreeIdx dest fixField
    | TransBkdTime fixField -> WriteTransBkdTime nextFreeIdx dest fixField
    | ExecPriceType fixField -> WriteExecPriceType nextFreeIdx dest fixField
    | ExecPriceAdjustment fixField -> WriteExecPriceAdjustment nextFreeIdx dest fixField
    | DateOfBirth fixField -> WriteDateOfBirth nextFreeIdx dest fixField
    | TradeReportTransType fixField -> WriteTradeReportTransType nextFreeIdx dest fixField
    | CardHolderName fixField -> WriteCardHolderName nextFreeIdx dest fixField
    | CardNumber fixField -> WriteCardNumber nextFreeIdx dest fixField
    | CardExpDate fixField -> WriteCardExpDate nextFreeIdx dest fixField
    | CardIssNum fixField -> WriteCardIssNum nextFreeIdx dest fixField
    | PaymentMethod fixField -> WritePaymentMethod nextFreeIdx dest fixField
    | RegistAcctType fixField -> WriteRegistAcctType nextFreeIdx dest fixField
    | Designation fixField -> WriteDesignation nextFreeIdx dest fixField
    | TaxAdvantageType fixField -> WriteTaxAdvantageType nextFreeIdx dest fixField
    | RegistRejReasonText fixField -> WriteRegistRejReasonText nextFreeIdx dest fixField
    | FundRenewWaiv fixField -> WriteFundRenewWaiv nextFreeIdx dest fixField
    | CashDistribAgentName fixField -> WriteCashDistribAgentName nextFreeIdx dest fixField
    | CashDistribAgentCode fixField -> WriteCashDistribAgentCode nextFreeIdx dest fixField
    | CashDistribAgentAcctNumber fixField -> WriteCashDistribAgentAcctNumber nextFreeIdx dest fixField
    | CashDistribPayRef fixField -> WriteCashDistribPayRef nextFreeIdx dest fixField
    | CashDistribAgentAcctName fixField -> WriteCashDistribAgentAcctName nextFreeIdx dest fixField
    | CardStartDate fixField -> WriteCardStartDate nextFreeIdx dest fixField
    | PaymentDate fixField -> WritePaymentDate nextFreeIdx dest fixField
    | PaymentRemitterID fixField -> WritePaymentRemitterID nextFreeIdx dest fixField
    | RegistStatus fixField -> WriteRegistStatus nextFreeIdx dest fixField
    | RegistRejReasonCode fixField -> WriteRegistRejReasonCode nextFreeIdx dest fixField
    | RegistRefID fixField -> WriteRegistRefID nextFreeIdx dest fixField
    | RegistDtls fixField -> WriteRegistDtls nextFreeIdx dest fixField
    | NoDistribInsts fixField -> WriteNoDistribInsts nextFreeIdx dest fixField
    | RegistEmail fixField -> WriteRegistEmail nextFreeIdx dest fixField
    | DistribPercentage fixField -> WriteDistribPercentage nextFreeIdx dest fixField
    | RegistID fixField -> WriteRegistID nextFreeIdx dest fixField
    | RegistTransType fixField -> WriteRegistTransType nextFreeIdx dest fixField
    | ExecValuationPoint fixField -> WriteExecValuationPoint nextFreeIdx dest fixField
    | OrderPercent fixField -> WriteOrderPercent nextFreeIdx dest fixField
    | OwnershipType fixField -> WriteOwnershipType nextFreeIdx dest fixField
    | NoContAmts fixField -> WriteNoContAmts nextFreeIdx dest fixField
    | ContAmtType fixField -> WriteContAmtType nextFreeIdx dest fixField
    | ContAmtValue fixField -> WriteContAmtValue nextFreeIdx dest fixField
    | ContAmtCurr fixField -> WriteContAmtCurr nextFreeIdx dest fixField
    | OwnerType fixField -> WriteOwnerType nextFreeIdx dest fixField
    | PartySubID fixField -> WritePartySubID nextFreeIdx dest fixField
    | NestedPartyID fixField -> WriteNestedPartyID nextFreeIdx dest fixField
    | NestedPartyIDSource fixField -> WriteNestedPartyIDSource nextFreeIdx dest fixField
    | SecondaryClOrdID fixField -> WriteSecondaryClOrdID nextFreeIdx dest fixField
    | SecondaryExecID fixField -> WriteSecondaryExecID nextFreeIdx dest fixField
    | OrderCapacity fixField -> WriteOrderCapacity nextFreeIdx dest fixField
    | OrderRestrictions fixField -> WriteOrderRestrictions nextFreeIdx dest fixField
    | MassCancelRequestType fixField -> WriteMassCancelRequestType nextFreeIdx dest fixField
    | MassCancelResponse fixField -> WriteMassCancelResponse nextFreeIdx dest fixField
    | MassCancelRejectReason fixField -> WriteMassCancelRejectReason nextFreeIdx dest fixField
    | TotalAffectedOrders fixField -> WriteTotalAffectedOrders nextFreeIdx dest fixField
    | NoAffectedOrders fixField -> WriteNoAffectedOrders nextFreeIdx dest fixField
    | AffectedOrderID fixField -> WriteAffectedOrderID nextFreeIdx dest fixField
    | AffectedSecondaryOrderID fixField -> WriteAffectedSecondaryOrderID nextFreeIdx dest fixField
    | QuoteType fixField -> WriteQuoteType nextFreeIdx dest fixField
    | NestedPartyRole fixField -> WriteNestedPartyRole nextFreeIdx dest fixField
    | NoNestedPartyIDs fixField -> WriteNoNestedPartyIDs nextFreeIdx dest fixField
    | TotalAccruedInterestAmt fixField -> WriteTotalAccruedInterestAmt nextFreeIdx dest fixField
    | MaturityDate fixField -> WriteMaturityDate nextFreeIdx dest fixField
    | UnderlyingMaturityDate fixField -> WriteUnderlyingMaturityDate nextFreeIdx dest fixField
    | InstrRegistry fixField -> WriteInstrRegistry nextFreeIdx dest fixField
    | CashMargin fixField -> WriteCashMargin nextFreeIdx dest fixField
    | NestedPartySubID fixField -> WriteNestedPartySubID nextFreeIdx dest fixField
    | Scope fixField -> WriteScope nextFreeIdx dest fixField
    | MDImplicitDelete fixField -> WriteMDImplicitDelete nextFreeIdx dest fixField
    | CrossID fixField -> WriteCrossID nextFreeIdx dest fixField
    | CrossType fixField -> WriteCrossType nextFreeIdx dest fixField
    | CrossPrioritization fixField -> WriteCrossPrioritization nextFreeIdx dest fixField
    | OrigCrossID fixField -> WriteOrigCrossID nextFreeIdx dest fixField
    | NoSides fixField -> WriteNoSides nextFreeIdx dest fixField
    | Username fixField -> WriteUsername nextFreeIdx dest fixField
    | Password fixField -> WritePassword nextFreeIdx dest fixField
    | NoLegs fixField -> WriteNoLegs nextFreeIdx dest fixField
    | LegCurrency fixField -> WriteLegCurrency nextFreeIdx dest fixField
    | TotNoSecurityTypes fixField -> WriteTotNoSecurityTypes nextFreeIdx dest fixField
    | NoSecurityTypes fixField -> WriteNoSecurityTypes nextFreeIdx dest fixField
    | SecurityListRequestType fixField -> WriteSecurityListRequestType nextFreeIdx dest fixField
    | SecurityRequestResult fixField -> WriteSecurityRequestResult nextFreeIdx dest fixField
    | RoundLot fixField -> WriteRoundLot nextFreeIdx dest fixField
    | MinTradeVol fixField -> WriteMinTradeVol nextFreeIdx dest fixField
    | MultiLegRptTypeReq fixField -> WriteMultiLegRptTypeReq nextFreeIdx dest fixField
    | LegPositionEffect fixField -> WriteLegPositionEffect nextFreeIdx dest fixField
    | LegCoveredOrUncovered fixField -> WriteLegCoveredOrUncovered nextFreeIdx dest fixField
    | LegPrice fixField -> WriteLegPrice nextFreeIdx dest fixField
    | TradSesStatusRejReason fixField -> WriteTradSesStatusRejReason nextFreeIdx dest fixField
    | TradeRequestID fixField -> WriteTradeRequestID nextFreeIdx dest fixField
    | TradeRequestType fixField -> WriteTradeRequestType nextFreeIdx dest fixField
    | PreviouslyReported fixField -> WritePreviouslyReported nextFreeIdx dest fixField
    | TradeReportID fixField -> WriteTradeReportID nextFreeIdx dest fixField
    | TradeReportRefID fixField -> WriteTradeReportRefID nextFreeIdx dest fixField
    | MatchStatus fixField -> WriteMatchStatus nextFreeIdx dest fixField
    | MatchType fixField -> WriteMatchType nextFreeIdx dest fixField
    | OddLot fixField -> WriteOddLot nextFreeIdx dest fixField
    | NoClearingInstructions fixField -> WriteNoClearingInstructions nextFreeIdx dest fixField
    | ClearingInstruction fixField -> WriteClearingInstruction nextFreeIdx dest fixField
    | TradeInputSource fixField -> WriteTradeInputSource nextFreeIdx dest fixField
    | TradeInputDevice fixField -> WriteTradeInputDevice nextFreeIdx dest fixField
    | NoDates fixField -> WriteNoDates nextFreeIdx dest fixField
    | AccountType fixField -> WriteAccountType nextFreeIdx dest fixField
    | CustOrderCapacity fixField -> WriteCustOrderCapacity nextFreeIdx dest fixField
    | ClOrdLinkID fixField -> WriteClOrdLinkID nextFreeIdx dest fixField
    | MassStatusReqID fixField -> WriteMassStatusReqID nextFreeIdx dest fixField
    | MassStatusReqType fixField -> WriteMassStatusReqType nextFreeIdx dest fixField
    | OrigOrdModTime fixField -> WriteOrigOrdModTime nextFreeIdx dest fixField
    | LegSettlType fixField -> WriteLegSettlType nextFreeIdx dest fixField
    | LegSettlDate fixField -> WriteLegSettlDate nextFreeIdx dest fixField
    | DayBookingInst fixField -> WriteDayBookingInst nextFreeIdx dest fixField
    | BookingUnit fixField -> WriteBookingUnit nextFreeIdx dest fixField
    | PreallocMethod fixField -> WritePreallocMethod nextFreeIdx dest fixField
    | UnderlyingCountryOfIssue fixField -> WriteUnderlyingCountryOfIssue nextFreeIdx dest fixField
    | UnderlyingStateOrProvinceOfIssue fixField -> WriteUnderlyingStateOrProvinceOfIssue nextFreeIdx dest fixField
    | UnderlyingLocaleOfIssue fixField -> WriteUnderlyingLocaleOfIssue nextFreeIdx dest fixField
    | UnderlyingInstrRegistry fixField -> WriteUnderlyingInstrRegistry nextFreeIdx dest fixField
    | LegCountryOfIssue fixField -> WriteLegCountryOfIssue nextFreeIdx dest fixField
    | LegStateOrProvinceOfIssue fixField -> WriteLegStateOrProvinceOfIssue nextFreeIdx dest fixField
    | LegLocaleOfIssue fixField -> WriteLegLocaleOfIssue nextFreeIdx dest fixField
    | LegInstrRegistry fixField -> WriteLegInstrRegistry nextFreeIdx dest fixField
    | LegSymbol fixField -> WriteLegSymbol nextFreeIdx dest fixField
    | LegSymbolSfx fixField -> WriteLegSymbolSfx nextFreeIdx dest fixField
    | LegSecurityID fixField -> WriteLegSecurityID nextFreeIdx dest fixField
    | LegSecurityIDSource fixField -> WriteLegSecurityIDSource nextFreeIdx dest fixField
    | NoLegSecurityAltID fixField -> WriteNoLegSecurityAltID nextFreeIdx dest fixField
    | LegSecurityAltID fixField -> WriteLegSecurityAltID nextFreeIdx dest fixField
    | LegSecurityAltIDSource fixField -> WriteLegSecurityAltIDSource nextFreeIdx dest fixField
    | LegProduct fixField -> WriteLegProduct nextFreeIdx dest fixField
    | LegCFICode fixField -> WriteLegCFICode nextFreeIdx dest fixField
    | LegSecurityType fixField -> WriteLegSecurityType nextFreeIdx dest fixField
    | LegMaturityMonthYear fixField -> WriteLegMaturityMonthYear nextFreeIdx dest fixField
    | LegMaturityDate fixField -> WriteLegMaturityDate nextFreeIdx dest fixField
    | LegStrikePrice fixField -> WriteLegStrikePrice nextFreeIdx dest fixField
    | LegOptAttribute fixField -> WriteLegOptAttribute nextFreeIdx dest fixField
    | LegContractMultiplier fixField -> WriteLegContractMultiplier nextFreeIdx dest fixField
    | LegCouponRate fixField -> WriteLegCouponRate nextFreeIdx dest fixField
    | LegSecurityExchange fixField -> WriteLegSecurityExchange nextFreeIdx dest fixField
    | LegIssuer fixField -> WriteLegIssuer nextFreeIdx dest fixField
    | EncodedLegIssuer fixField -> WriteEncodedLegIssuer nextFreeIdx dest fixField // compound field
    | LegSecurityDesc fixField -> WriteLegSecurityDesc nextFreeIdx dest fixField
    | EncodedLegSecurityDesc fixField -> WriteEncodedLegSecurityDesc nextFreeIdx dest fixField // compound field
    | LegRatioQty fixField -> WriteLegRatioQty nextFreeIdx dest fixField
    | LegSide fixField -> WriteLegSide nextFreeIdx dest fixField
    | TradingSessionSubID fixField -> WriteTradingSessionSubID nextFreeIdx dest fixField
    | AllocType fixField -> WriteAllocType nextFreeIdx dest fixField
    | NoHops fixField -> WriteNoHops nextFreeIdx dest fixField
    | HopCompID fixField -> WriteHopCompID nextFreeIdx dest fixField
    | HopSendingTime fixField -> WriteHopSendingTime nextFreeIdx dest fixField
    | HopRefID fixField -> WriteHopRefID nextFreeIdx dest fixField
    | MidPx fixField -> WriteMidPx nextFreeIdx dest fixField
    | BidYield fixField -> WriteBidYield nextFreeIdx dest fixField
    | MidYield fixField -> WriteMidYield nextFreeIdx dest fixField
    | OfferYield fixField -> WriteOfferYield nextFreeIdx dest fixField
    | ClearingFeeIndicator fixField -> WriteClearingFeeIndicator nextFreeIdx dest fixField
    | WorkingIndicator fixField -> WriteWorkingIndicator nextFreeIdx dest fixField
    | LegLastPx fixField -> WriteLegLastPx nextFreeIdx dest fixField
    | PriorityIndicator fixField -> WritePriorityIndicator nextFreeIdx dest fixField
    | PriceImprovement fixField -> WritePriceImprovement nextFreeIdx dest fixField
    | Price2 fixField -> WritePrice2 nextFreeIdx dest fixField
    | LastForwardPoints2 fixField -> WriteLastForwardPoints2 nextFreeIdx dest fixField
    | BidForwardPoints2 fixField -> WriteBidForwardPoints2 nextFreeIdx dest fixField
    | OfferForwardPoints2 fixField -> WriteOfferForwardPoints2 nextFreeIdx dest fixField
    | RFQReqID fixField -> WriteRFQReqID nextFreeIdx dest fixField
    | MktBidPx fixField -> WriteMktBidPx nextFreeIdx dest fixField
    | MktOfferPx fixField -> WriteMktOfferPx nextFreeIdx dest fixField
    | MinBidSize fixField -> WriteMinBidSize nextFreeIdx dest fixField
    | MinOfferSize fixField -> WriteMinOfferSize nextFreeIdx dest fixField
    | QuoteStatusReqID fixField -> WriteQuoteStatusReqID nextFreeIdx dest fixField
    | LegalConfirm fixField -> WriteLegalConfirm nextFreeIdx dest fixField
    | UnderlyingLastPx fixField -> WriteUnderlyingLastPx nextFreeIdx dest fixField
    | UnderlyingLastQty fixField -> WriteUnderlyingLastQty nextFreeIdx dest fixField
    | LegRefID fixField -> WriteLegRefID nextFreeIdx dest fixField
    | ContraLegRefID fixField -> WriteContraLegRefID nextFreeIdx dest fixField
    | SettlCurrBidFxRate fixField -> WriteSettlCurrBidFxRate nextFreeIdx dest fixField
    | SettlCurrOfferFxRate fixField -> WriteSettlCurrOfferFxRate nextFreeIdx dest fixField
    | QuoteRequestRejectReason fixField -> WriteQuoteRequestRejectReason nextFreeIdx dest fixField
    | SideComplianceID fixField -> WriteSideComplianceID nextFreeIdx dest fixField
    | AcctIDSource fixField -> WriteAcctIDSource nextFreeIdx dest fixField
    | AllocAcctIDSource fixField -> WriteAllocAcctIDSource nextFreeIdx dest fixField
    | BenchmarkPrice fixField -> WriteBenchmarkPrice nextFreeIdx dest fixField
    | BenchmarkPriceType fixField -> WriteBenchmarkPriceType nextFreeIdx dest fixField
    | ConfirmID fixField -> WriteConfirmID nextFreeIdx dest fixField
    | ConfirmStatus fixField -> WriteConfirmStatus nextFreeIdx dest fixField
    | ConfirmTransType fixField -> WriteConfirmTransType nextFreeIdx dest fixField
    | ContractSettlMonth fixField -> WriteContractSettlMonth nextFreeIdx dest fixField
    | DeliveryForm fixField -> WriteDeliveryForm nextFreeIdx dest fixField
    | LastParPx fixField -> WriteLastParPx nextFreeIdx dest fixField
    | NoLegAllocs fixField -> WriteNoLegAllocs nextFreeIdx dest fixField
    | LegAllocAccount fixField -> WriteLegAllocAccount nextFreeIdx dest fixField
    | LegIndividualAllocID fixField -> WriteLegIndividualAllocID nextFreeIdx dest fixField
    | LegAllocQty fixField -> WriteLegAllocQty nextFreeIdx dest fixField
    | LegAllocAcctIDSource fixField -> WriteLegAllocAcctIDSource nextFreeIdx dest fixField
    | LegSettlCurrency fixField -> WriteLegSettlCurrency nextFreeIdx dest fixField
    | LegBenchmarkCurveCurrency fixField -> WriteLegBenchmarkCurveCurrency nextFreeIdx dest fixField
    | LegBenchmarkCurveName fixField -> WriteLegBenchmarkCurveName nextFreeIdx dest fixField
    | LegBenchmarkCurvePoint fixField -> WriteLegBenchmarkCurvePoint nextFreeIdx dest fixField
    | LegBenchmarkPrice fixField -> WriteLegBenchmarkPrice nextFreeIdx dest fixField
    | LegBenchmarkPriceType fixField -> WriteLegBenchmarkPriceType nextFreeIdx dest fixField
    | LegBidPx fixField -> WriteLegBidPx nextFreeIdx dest fixField
    | LegIOIQty fixField -> WriteLegIOIQty nextFreeIdx dest fixField
    | NoLegStipulations fixField -> WriteNoLegStipulations nextFreeIdx dest fixField
    | LegOfferPx fixField -> WriteLegOfferPx nextFreeIdx dest fixField
    | LegOrderQty fixField -> WriteLegOrderQty nextFreeIdx dest fixField
    | LegPriceType fixField -> WriteLegPriceType nextFreeIdx dest fixField
    | LegQty fixField -> WriteLegQty nextFreeIdx dest fixField
    | LegStipulationType fixField -> WriteLegStipulationType nextFreeIdx dest fixField
    | LegStipulationValue fixField -> WriteLegStipulationValue nextFreeIdx dest fixField
    | LegSwapType fixField -> WriteLegSwapType nextFreeIdx dest fixField
    | Pool fixField -> WritePool nextFreeIdx dest fixField
    | QuotePriceType fixField -> WriteQuotePriceType nextFreeIdx dest fixField
    | QuoteRespID fixField -> WriteQuoteRespID nextFreeIdx dest fixField
    | QuoteRespType fixField -> WriteQuoteRespType nextFreeIdx dest fixField
    | QuoteQualifier fixField -> WriteQuoteQualifier nextFreeIdx dest fixField
    | YieldRedemptionDate fixField -> WriteYieldRedemptionDate nextFreeIdx dest fixField
    | YieldRedemptionPrice fixField -> WriteYieldRedemptionPrice nextFreeIdx dest fixField
    | YieldRedemptionPriceType fixField -> WriteYieldRedemptionPriceType nextFreeIdx dest fixField
    | BenchmarkSecurityID fixField -> WriteBenchmarkSecurityID nextFreeIdx dest fixField
    | ReversalIndicator fixField -> WriteReversalIndicator nextFreeIdx dest fixField
    | YieldCalcDate fixField -> WriteYieldCalcDate nextFreeIdx dest fixField
    | NoPositions fixField -> WriteNoPositions nextFreeIdx dest fixField
    | PosType fixField -> WritePosType nextFreeIdx dest fixField
    | LongQty fixField -> WriteLongQty nextFreeIdx dest fixField
    | ShortQty fixField -> WriteShortQty nextFreeIdx dest fixField
    | PosQtyStatus fixField -> WritePosQtyStatus nextFreeIdx dest fixField
    | PosAmtType fixField -> WritePosAmtType nextFreeIdx dest fixField
    | PosAmt fixField -> WritePosAmt nextFreeIdx dest fixField
    | PosTransType fixField -> WritePosTransType nextFreeIdx dest fixField
    | PosReqID fixField -> WritePosReqID nextFreeIdx dest fixField
    | NoUnderlyings fixField -> WriteNoUnderlyings nextFreeIdx dest fixField
    | PosMaintAction fixField -> WritePosMaintAction nextFreeIdx dest fixField
    | OrigPosReqRefID fixField -> WriteOrigPosReqRefID nextFreeIdx dest fixField
    | PosMaintRptRefID fixField -> WritePosMaintRptRefID nextFreeIdx dest fixField
    | ClearingBusinessDate fixField -> WriteClearingBusinessDate nextFreeIdx dest fixField
    | SettlSessID fixField -> WriteSettlSessID nextFreeIdx dest fixField
    | SettlSessSubID fixField -> WriteSettlSessSubID nextFreeIdx dest fixField
    | AdjustmentType fixField -> WriteAdjustmentType nextFreeIdx dest fixField
    | ContraryInstructionIndicator fixField -> WriteContraryInstructionIndicator nextFreeIdx dest fixField
    | PriorSpreadIndicator fixField -> WritePriorSpreadIndicator nextFreeIdx dest fixField
    | PosMaintRptID fixField -> WritePosMaintRptID nextFreeIdx dest fixField
    | PosMaintStatus fixField -> WritePosMaintStatus nextFreeIdx dest fixField
    | PosMaintResult fixField -> WritePosMaintResult nextFreeIdx dest fixField
    | PosReqType fixField -> WritePosReqType nextFreeIdx dest fixField
    | ResponseTransportType fixField -> WriteResponseTransportType nextFreeIdx dest fixField
    | ResponseDestination fixField -> WriteResponseDestination nextFreeIdx dest fixField
    | TotalNumPosReports fixField -> WriteTotalNumPosReports nextFreeIdx dest fixField
    | PosReqResult fixField -> WritePosReqResult nextFreeIdx dest fixField
    | PosReqStatus fixField -> WritePosReqStatus nextFreeIdx dest fixField
    | SettlPrice fixField -> WriteSettlPrice nextFreeIdx dest fixField
    | SettlPriceType fixField -> WriteSettlPriceType nextFreeIdx dest fixField
    | UnderlyingSettlPrice fixField -> WriteUnderlyingSettlPrice nextFreeIdx dest fixField
    | UnderlyingSettlPriceType fixField -> WriteUnderlyingSettlPriceType nextFreeIdx dest fixField
    | PriorSettlPrice fixField -> WritePriorSettlPrice nextFreeIdx dest fixField
    | NoQuoteQualifiers fixField -> WriteNoQuoteQualifiers nextFreeIdx dest fixField
    | AllocSettlCurrency fixField -> WriteAllocSettlCurrency nextFreeIdx dest fixField
    | AllocSettlCurrAmt fixField -> WriteAllocSettlCurrAmt nextFreeIdx dest fixField
    | InterestAtMaturity fixField -> WriteInterestAtMaturity nextFreeIdx dest fixField
    | LegDatedDate fixField -> WriteLegDatedDate nextFreeIdx dest fixField
    | LegPool fixField -> WriteLegPool nextFreeIdx dest fixField
    | AllocInterestAtMaturity fixField -> WriteAllocInterestAtMaturity nextFreeIdx dest fixField
    | AllocAccruedInterestAmt fixField -> WriteAllocAccruedInterestAmt nextFreeIdx dest fixField
    | DeliveryDate fixField -> WriteDeliveryDate nextFreeIdx dest fixField
    | AssignmentMethod fixField -> WriteAssignmentMethod nextFreeIdx dest fixField
    | AssignmentUnit fixField -> WriteAssignmentUnit nextFreeIdx dest fixField
    | OpenInterest fixField -> WriteOpenInterest nextFreeIdx dest fixField
    | ExerciseMethod fixField -> WriteExerciseMethod nextFreeIdx dest fixField
    | TotNumTradeReports fixField -> WriteTotNumTradeReports nextFreeIdx dest fixField
    | TradeRequestResult fixField -> WriteTradeRequestResult nextFreeIdx dest fixField
    | TradeRequestStatus fixField -> WriteTradeRequestStatus nextFreeIdx dest fixField
    | TradeReportRejectReason fixField -> WriteTradeReportRejectReason nextFreeIdx dest fixField
    | SideMultiLegReportingType fixField -> WriteSideMultiLegReportingType nextFreeIdx dest fixField
    | NoPosAmt fixField -> WriteNoPosAmt nextFreeIdx dest fixField
    | AutoAcceptIndicator fixField -> WriteAutoAcceptIndicator nextFreeIdx dest fixField
    | AllocReportID fixField -> WriteAllocReportID nextFreeIdx dest fixField
    | NoNested2PartyIDs fixField -> WriteNoNested2PartyIDs nextFreeIdx dest fixField
    | Nested2PartyID fixField -> WriteNested2PartyID nextFreeIdx dest fixField
    | Nested2PartyIDSource fixField -> WriteNested2PartyIDSource nextFreeIdx dest fixField
    | Nested2PartyRole fixField -> WriteNested2PartyRole nextFreeIdx dest fixField
    | Nested2PartySubID fixField -> WriteNested2PartySubID nextFreeIdx dest fixField
    | BenchmarkSecurityIDSource fixField -> WriteBenchmarkSecurityIDSource nextFreeIdx dest fixField
    | SecuritySubType fixField -> WriteSecuritySubType nextFreeIdx dest fixField
    | UnderlyingSecuritySubType fixField -> WriteUnderlyingSecuritySubType nextFreeIdx dest fixField
    | LegSecuritySubType fixField -> WriteLegSecuritySubType nextFreeIdx dest fixField
    | AllowableOneSidednessPct fixField -> WriteAllowableOneSidednessPct nextFreeIdx dest fixField
    | AllowableOneSidednessValue fixField -> WriteAllowableOneSidednessValue nextFreeIdx dest fixField
    | AllowableOneSidednessCurr fixField -> WriteAllowableOneSidednessCurr nextFreeIdx dest fixField
    | NoTrdRegTimestamps fixField -> WriteNoTrdRegTimestamps nextFreeIdx dest fixField
    | TrdRegTimestamp fixField -> WriteTrdRegTimestamp nextFreeIdx dest fixField
    | TrdRegTimestampType fixField -> WriteTrdRegTimestampType nextFreeIdx dest fixField
    | TrdRegTimestampOrigin fixField -> WriteTrdRegTimestampOrigin nextFreeIdx dest fixField
    | ConfirmRefID fixField -> WriteConfirmRefID nextFreeIdx dest fixField
    | ConfirmType fixField -> WriteConfirmType nextFreeIdx dest fixField
    | ConfirmRejReason fixField -> WriteConfirmRejReason nextFreeIdx dest fixField
    | BookingType fixField -> WriteBookingType nextFreeIdx dest fixField
    | IndividualAllocRejCode fixField -> WriteIndividualAllocRejCode nextFreeIdx dest fixField
    | SettlInstMsgID fixField -> WriteSettlInstMsgID nextFreeIdx dest fixField
    | NoSettlInst fixField -> WriteNoSettlInst nextFreeIdx dest fixField
    | LastUpdateTime fixField -> WriteLastUpdateTime nextFreeIdx dest fixField
    | AllocSettlInstType fixField -> WriteAllocSettlInstType nextFreeIdx dest fixField
    | NoSettlPartyIDs fixField -> WriteNoSettlPartyIDs nextFreeIdx dest fixField
    | SettlPartyID fixField -> WriteSettlPartyID nextFreeIdx dest fixField
    | SettlPartyIDSource fixField -> WriteSettlPartyIDSource nextFreeIdx dest fixField
    | SettlPartyRole fixField -> WriteSettlPartyRole nextFreeIdx dest fixField
    | SettlPartySubID fixField -> WriteSettlPartySubID nextFreeIdx dest fixField
    | SettlPartySubIDType fixField -> WriteSettlPartySubIDType nextFreeIdx dest fixField
    | DlvyInstType fixField -> WriteDlvyInstType nextFreeIdx dest fixField
    | TerminationType fixField -> WriteTerminationType nextFreeIdx dest fixField
    | NextExpectedMsgSeqNum fixField -> WriteNextExpectedMsgSeqNum nextFreeIdx dest fixField
    | OrdStatusReqID fixField -> WriteOrdStatusReqID nextFreeIdx dest fixField
    | SettlInstReqID fixField -> WriteSettlInstReqID nextFreeIdx dest fixField
    | SettlInstReqRejCode fixField -> WriteSettlInstReqRejCode nextFreeIdx dest fixField
    | SecondaryAllocID fixField -> WriteSecondaryAllocID nextFreeIdx dest fixField
    | AllocReportType fixField -> WriteAllocReportType nextFreeIdx dest fixField
    | AllocReportRefID fixField -> WriteAllocReportRefID nextFreeIdx dest fixField
    | AllocCancReplaceReason fixField -> WriteAllocCancReplaceReason nextFreeIdx dest fixField
    | CopyMsgIndicator fixField -> WriteCopyMsgIndicator nextFreeIdx dest fixField
    | AllocAccountType fixField -> WriteAllocAccountType nextFreeIdx dest fixField
    | OrderAvgPx fixField -> WriteOrderAvgPx nextFreeIdx dest fixField
    | OrderBookingQty fixField -> WriteOrderBookingQty nextFreeIdx dest fixField
    | NoSettlPartySubIDs fixField -> WriteNoSettlPartySubIDs nextFreeIdx dest fixField
    | NoPartySubIDs fixField -> WriteNoPartySubIDs nextFreeIdx dest fixField
    | PartySubIDType fixField -> WritePartySubIDType nextFreeIdx dest fixField
    | NoNestedPartySubIDs fixField -> WriteNoNestedPartySubIDs nextFreeIdx dest fixField
    | NestedPartySubIDType fixField -> WriteNestedPartySubIDType nextFreeIdx dest fixField
    | NoNested2PartySubIDs fixField -> WriteNoNested2PartySubIDs nextFreeIdx dest fixField
    | Nested2PartySubIDType fixField -> WriteNested2PartySubIDType nextFreeIdx dest fixField
    | AllocIntermedReqType fixField -> WriteAllocIntermedReqType nextFreeIdx dest fixField
    | UnderlyingPx fixField -> WriteUnderlyingPx nextFreeIdx dest fixField
    | PriceDelta fixField -> WritePriceDelta nextFreeIdx dest fixField
    | ApplQueueMax fixField -> WriteApplQueueMax nextFreeIdx dest fixField
    | ApplQueueDepth fixField -> WriteApplQueueDepth nextFreeIdx dest fixField
    | ApplQueueResolution fixField -> WriteApplQueueResolution nextFreeIdx dest fixField
    | ApplQueueAction fixField -> WriteApplQueueAction nextFreeIdx dest fixField
    | NoAltMDSource fixField -> WriteNoAltMDSource nextFreeIdx dest fixField
    | AltMDSourceID fixField -> WriteAltMDSourceID nextFreeIdx dest fixField
    | SecondaryTradeReportID fixField -> WriteSecondaryTradeReportID nextFreeIdx dest fixField
    | AvgPxIndicator fixField -> WriteAvgPxIndicator nextFreeIdx dest fixField
    | TradeLinkID fixField -> WriteTradeLinkID nextFreeIdx dest fixField
    | OrderInputDevice fixField -> WriteOrderInputDevice nextFreeIdx dest fixField
    | UnderlyingTradingSessionID fixField -> WriteUnderlyingTradingSessionID nextFreeIdx dest fixField
    | UnderlyingTradingSessionSubID fixField -> WriteUnderlyingTradingSessionSubID nextFreeIdx dest fixField
    | TradeLegRefID fixField -> WriteTradeLegRefID nextFreeIdx dest fixField
    | ExchangeRule fixField -> WriteExchangeRule nextFreeIdx dest fixField
    | TradeAllocIndicator fixField -> WriteTradeAllocIndicator nextFreeIdx dest fixField
    | ExpirationCycle fixField -> WriteExpirationCycle nextFreeIdx dest fixField
    | TrdType fixField -> WriteTrdType nextFreeIdx dest fixField
    | TrdSubType fixField -> WriteTrdSubType nextFreeIdx dest fixField
    | TransferReason fixField -> WriteTransferReason nextFreeIdx dest fixField
    | AsgnReqID fixField -> WriteAsgnReqID nextFreeIdx dest fixField
    | TotNumAssignmentReports fixField -> WriteTotNumAssignmentReports nextFreeIdx dest fixField
    | AsgnRptID fixField -> WriteAsgnRptID nextFreeIdx dest fixField
    | ThresholdAmount fixField -> WriteThresholdAmount nextFreeIdx dest fixField
    | PegMoveType fixField -> WritePegMoveType nextFreeIdx dest fixField
    | PegOffsetType fixField -> WritePegOffsetType nextFreeIdx dest fixField
    | PegLimitType fixField -> WritePegLimitType nextFreeIdx dest fixField
    | PegRoundDirection fixField -> WritePegRoundDirection nextFreeIdx dest fixField
    | PeggedPrice fixField -> WritePeggedPrice nextFreeIdx dest fixField
    | PegScope fixField -> WritePegScope nextFreeIdx dest fixField
    | DiscretionMoveType fixField -> WriteDiscretionMoveType nextFreeIdx dest fixField
    | DiscretionOffsetType fixField -> WriteDiscretionOffsetType nextFreeIdx dest fixField
    | DiscretionLimitType fixField -> WriteDiscretionLimitType nextFreeIdx dest fixField
    | DiscretionRoundDirection fixField -> WriteDiscretionRoundDirection nextFreeIdx dest fixField
    | DiscretionPrice fixField -> WriteDiscretionPrice nextFreeIdx dest fixField
    | DiscretionScope fixField -> WriteDiscretionScope nextFreeIdx dest fixField
    | TargetStrategy fixField -> WriteTargetStrategy nextFreeIdx dest fixField
    | TargetStrategyParameters fixField -> WriteTargetStrategyParameters nextFreeIdx dest fixField
    | ParticipationRate fixField -> WriteParticipationRate nextFreeIdx dest fixField
    | TargetStrategyPerformance fixField -> WriteTargetStrategyPerformance nextFreeIdx dest fixField
    | LastLiquidityInd fixField -> WriteLastLiquidityInd nextFreeIdx dest fixField
    | PublishTrdIndicator fixField -> WritePublishTrdIndicator nextFreeIdx dest fixField
    | ShortSaleReason fixField -> WriteShortSaleReason nextFreeIdx dest fixField
    | QtyType fixField -> WriteQtyType nextFreeIdx dest fixField
    | SecondaryTrdType fixField -> WriteSecondaryTrdType nextFreeIdx dest fixField
    | TradeReportType fixField -> WriteTradeReportType nextFreeIdx dest fixField
    | AllocNoOrdersType fixField -> WriteAllocNoOrdersType nextFreeIdx dest fixField
    | SharedCommission fixField -> WriteSharedCommission nextFreeIdx dest fixField
    | ConfirmReqID fixField -> WriteConfirmReqID nextFreeIdx dest fixField
    | AvgParPx fixField -> WriteAvgParPx nextFreeIdx dest fixField
    | ReportedPx fixField -> WriteReportedPx nextFreeIdx dest fixField
    | NoCapacities fixField -> WriteNoCapacities nextFreeIdx dest fixField
    | OrderCapacityQty fixField -> WriteOrderCapacityQty nextFreeIdx dest fixField
    | NoEvents fixField -> WriteNoEvents nextFreeIdx dest fixField
    | EventType fixField -> WriteEventType nextFreeIdx dest fixField
    | EventDate fixField -> WriteEventDate nextFreeIdx dest fixField
    | EventPx fixField -> WriteEventPx nextFreeIdx dest fixField
    | EventText fixField -> WriteEventText nextFreeIdx dest fixField
    | PctAtRisk fixField -> WritePctAtRisk nextFreeIdx dest fixField
    | NoInstrAttrib fixField -> WriteNoInstrAttrib nextFreeIdx dest fixField
    | InstrAttribType fixField -> WriteInstrAttribType nextFreeIdx dest fixField
    | InstrAttribValue fixField -> WriteInstrAttribValue nextFreeIdx dest fixField
    | DatedDate fixField -> WriteDatedDate nextFreeIdx dest fixField
    | InterestAccrualDate fixField -> WriteInterestAccrualDate nextFreeIdx dest fixField
    | CPProgram fixField -> WriteCPProgram nextFreeIdx dest fixField
    | CPRegType fixField -> WriteCPRegType nextFreeIdx dest fixField
    | UnderlyingCPProgram fixField -> WriteUnderlyingCPProgram nextFreeIdx dest fixField
    | UnderlyingCPRegType fixField -> WriteUnderlyingCPRegType nextFreeIdx dest fixField
    | UnderlyingQty fixField -> WriteUnderlyingQty nextFreeIdx dest fixField
    | TrdMatchID fixField -> WriteTrdMatchID nextFreeIdx dest fixField
    | SecondaryTradeReportRefID fixField -> WriteSecondaryTradeReportRefID nextFreeIdx dest fixField
    | UnderlyingDirtyPrice fixField -> WriteUnderlyingDirtyPrice nextFreeIdx dest fixField
    | UnderlyingEndPrice fixField -> WriteUnderlyingEndPrice nextFreeIdx dest fixField
    | UnderlyingStartValue fixField -> WriteUnderlyingStartValue nextFreeIdx dest fixField
    | UnderlyingCurrentValue fixField -> WriteUnderlyingCurrentValue nextFreeIdx dest fixField
    | UnderlyingEndValue fixField -> WriteUnderlyingEndValue nextFreeIdx dest fixField
    | NoUnderlyingStips fixField -> WriteNoUnderlyingStips nextFreeIdx dest fixField
    | UnderlyingStipType fixField -> WriteUnderlyingStipType nextFreeIdx dest fixField
    | UnderlyingStipValue fixField -> WriteUnderlyingStipValue nextFreeIdx dest fixField
    | MaturityNetMoney fixField -> WriteMaturityNetMoney nextFreeIdx dest fixField
    | MiscFeeBasis fixField -> WriteMiscFeeBasis nextFreeIdx dest fixField
    | TotNoAllocs fixField -> WriteTotNoAllocs nextFreeIdx dest fixField
    | LastFragment fixField -> WriteLastFragment nextFreeIdx dest fixField
    | CollReqID fixField -> WriteCollReqID nextFreeIdx dest fixField
    | CollAsgnReason fixField -> WriteCollAsgnReason nextFreeIdx dest fixField
    | CollInquiryQualifier fixField -> WriteCollInquiryQualifier nextFreeIdx dest fixField
    | NoTrades fixField -> WriteNoTrades nextFreeIdx dest fixField
    | MarginRatio fixField -> WriteMarginRatio nextFreeIdx dest fixField
    | MarginExcess fixField -> WriteMarginExcess nextFreeIdx dest fixField
    | TotalNetValue fixField -> WriteTotalNetValue nextFreeIdx dest fixField
    | CashOutstanding fixField -> WriteCashOutstanding nextFreeIdx dest fixField
    | CollAsgnID fixField -> WriteCollAsgnID nextFreeIdx dest fixField
    | CollAsgnTransType fixField -> WriteCollAsgnTransType nextFreeIdx dest fixField
    | CollRespID fixField -> WriteCollRespID nextFreeIdx dest fixField
    | CollAsgnRespType fixField -> WriteCollAsgnRespType nextFreeIdx dest fixField
    | CollAsgnRejectReason fixField -> WriteCollAsgnRejectReason nextFreeIdx dest fixField
    | CollAsgnRefID fixField -> WriteCollAsgnRefID nextFreeIdx dest fixField
    | CollRptID fixField -> WriteCollRptID nextFreeIdx dest fixField
    | CollInquiryID fixField -> WriteCollInquiryID nextFreeIdx dest fixField
    | CollStatus fixField -> WriteCollStatus nextFreeIdx dest fixField
    | TotNumReports fixField -> WriteTotNumReports nextFreeIdx dest fixField
    | LastRptRequested fixField -> WriteLastRptRequested nextFreeIdx dest fixField
    | AgreementDesc fixField -> WriteAgreementDesc nextFreeIdx dest fixField
    | AgreementID fixField -> WriteAgreementID nextFreeIdx dest fixField
    | AgreementDate fixField -> WriteAgreementDate nextFreeIdx dest fixField
    | StartDate fixField -> WriteStartDate nextFreeIdx dest fixField
    | EndDate fixField -> WriteEndDate nextFreeIdx dest fixField
    | AgreementCurrency fixField -> WriteAgreementCurrency nextFreeIdx dest fixField
    | DeliveryType fixField -> WriteDeliveryType nextFreeIdx dest fixField
    | EndAccruedInterestAmt fixField -> WriteEndAccruedInterestAmt nextFreeIdx dest fixField
    | StartCash fixField -> WriteStartCash nextFreeIdx dest fixField
    | EndCash fixField -> WriteEndCash nextFreeIdx dest fixField
    | UserRequestID fixField -> WriteUserRequestID nextFreeIdx dest fixField
    | UserRequestType fixField -> WriteUserRequestType nextFreeIdx dest fixField
    | NewPassword fixField -> WriteNewPassword nextFreeIdx dest fixField
    | UserStatus fixField -> WriteUserStatus nextFreeIdx dest fixField
    | UserStatusText fixField -> WriteUserStatusText nextFreeIdx dest fixField
    | StatusValue fixField -> WriteStatusValue nextFreeIdx dest fixField
    | StatusText fixField -> WriteStatusText nextFreeIdx dest fixField
    | RefCompID fixField -> WriteRefCompID nextFreeIdx dest fixField
    | RefSubID fixField -> WriteRefSubID nextFreeIdx dest fixField
    | NetworkResponseID fixField -> WriteNetworkResponseID nextFreeIdx dest fixField
    | NetworkRequestID fixField -> WriteNetworkRequestID nextFreeIdx dest fixField
    | LastNetworkResponseID fixField -> WriteLastNetworkResponseID nextFreeIdx dest fixField
    | NetworkRequestType fixField -> WriteNetworkRequestType nextFreeIdx dest fixField
    | NoCompIDs fixField -> WriteNoCompIDs nextFreeIdx dest fixField
    | NetworkStatusResponseType fixField -> WriteNetworkStatusResponseType nextFreeIdx dest fixField
    | NoCollInquiryQualifier fixField -> WriteNoCollInquiryQualifier nextFreeIdx dest fixField
    | TrdRptStatus fixField -> WriteTrdRptStatus nextFreeIdx dest fixField
    | AffirmStatus fixField -> WriteAffirmStatus nextFreeIdx dest fixField
    | UnderlyingStrikeCurrency fixField -> WriteUnderlyingStrikeCurrency nextFreeIdx dest fixField
    | LegStrikeCurrency fixField -> WriteLegStrikeCurrency nextFreeIdx dest fixField
    | TimeBracket fixField -> WriteTimeBracket nextFreeIdx dest fixField
    | CollAction fixField -> WriteCollAction nextFreeIdx dest fixField
    | CollInquiryStatus fixField -> WriteCollInquiryStatus nextFreeIdx dest fixField
    | CollInquiryResult fixField -> WriteCollInquiryResult nextFreeIdx dest fixField
    | StrikeCurrency fixField -> WriteStrikeCurrency nextFreeIdx dest fixField
    | NoNested3PartyIDs fixField -> WriteNoNested3PartyIDs nextFreeIdx dest fixField
    | Nested3PartyID fixField -> WriteNested3PartyID nextFreeIdx dest fixField
    | Nested3PartyIDSource fixField -> WriteNested3PartyIDSource nextFreeIdx dest fixField
    | Nested3PartyRole fixField -> WriteNested3PartyRole nextFreeIdx dest fixField
    | NoNested3PartySubIDs fixField -> WriteNoNested3PartySubIDs nextFreeIdx dest fixField
    | Nested3PartySubID fixField -> WriteNested3PartySubID nextFreeIdx dest fixField
    | Nested3PartySubIDType fixField -> WriteNested3PartySubIDType nextFreeIdx dest fixField
    | LegContractSettlMonth fixField -> WriteLegContractSettlMonth nextFreeIdx dest fixField
    | LegInterestAccrualDate fixField -> WriteLegInterestAccrualDate nextFreeIdx dest fixField


// todo consider replacing ReadFields match statement with lookup in a map
let ReadField (strm:Stream) =
    let ss = CrapReadUntilDelim strm // todo: replace with something efficient
    let subStrs = ss.Split([|'='|])
    let tag = subStrs.[0]
    let raw = subStrs.[1]
    let fld =    
        match tag with
        | "1" -> ReadAccount raw |> FIXField.Account
        | "2" -> ReadAdvId raw |> FIXField.AdvId
        | "3" -> ReadAdvRefID raw |> FIXField.AdvRefID
        | "4" -> ReadAdvSide raw |> FIXField.AdvSide
        | "5" -> ReadAdvTransType raw |> FIXField.AdvTransType
        | "6" -> ReadAvgPx raw |> FIXField.AvgPx
        | "7" -> ReadBeginSeqNo raw |> FIXField.BeginSeqNo
        | "8" -> ReadBeginString raw |> FIXField.BeginString
        | "9" -> ReadBodyLength raw |> FIXField.BodyLength
        | "10" -> ReadCheckSum raw |> FIXField.CheckSum
        | "11" -> ReadClOrdID raw |> FIXField.ClOrdID
        | "12" -> ReadCommission raw |> FIXField.Commission
        | "13" -> ReadCommType raw |> FIXField.CommType
        | "14" -> ReadCumQty raw |> FIXField.CumQty
        | "15" -> ReadCurrency raw |> FIXField.Currency
        | "16" -> ReadEndSeqNo raw |> FIXField.EndSeqNo
        | "17" -> ReadExecID raw |> FIXField.ExecID
        | "18" -> ReadExecInst raw |> FIXField.ExecInst
        | "19" -> ReadExecRefID raw |> FIXField.ExecRefID
        | "21" -> ReadHandlInst raw |> FIXField.HandlInst
        | "22" -> ReadSecurityIDSource raw |> FIXField.SecurityIDSource
        | "23" -> ReadIOIid raw |> FIXField.IOIid
        | "25" -> ReadIOIQltyInd raw |> FIXField.IOIQltyInd
        | "26" -> ReadIOIRefID raw |> FIXField.IOIRefID
        | "27" -> ReadIOIQty raw |> FIXField.IOIQty
        | "28" -> ReadIOITransType raw |> FIXField.IOITransType
        | "29" -> ReadLastCapacity raw |> FIXField.LastCapacity
        | "30" -> ReadLastMkt raw |> FIXField.LastMkt
        | "31" -> ReadLastPx raw |> FIXField.LastPx
        | "32" -> ReadLastQty raw |> FIXField.LastQty
        | "33" -> ReadLinesOfText raw |> FIXField.LinesOfText
        | "34" -> ReadMsgSeqNum raw |> FIXField.MsgSeqNum
        | "35" -> ReadMsgType raw |> FIXField.MsgType
        | "36" -> ReadNewSeqNo raw |> FIXField.NewSeqNo
        | "37" -> ReadOrderID raw |> FIXField.OrderID
        | "38" -> ReadOrderQty raw |> FIXField.OrderQty
        | "39" -> ReadOrdStatus raw |> FIXField.OrdStatus
        | "40" -> ReadOrdType raw |> FIXField.OrdType
        | "41" -> ReadOrigClOrdID raw |> FIXField.OrigClOrdID
        | "42" -> ReadOrigTime raw |> FIXField.OrigTime
        | "43" -> ReadPossDupFlag raw |> FIXField.PossDupFlag
        | "44" -> ReadPrice raw |> FIXField.Price
        | "45" -> ReadRefSeqNum raw |> FIXField.RefSeqNum
        | "48" -> ReadSecurityID raw |> FIXField.SecurityID
        | "49" -> ReadSenderCompID raw |> FIXField.SenderCompID
        | "50" -> ReadSenderSubID raw |> FIXField.SenderSubID
        | "52" -> ReadSendingTime raw |> FIXField.SendingTime
        | "53" -> ReadQuantity raw |> FIXField.Quantity
        | "54" -> ReadSide raw |> FIXField.Side
        | "55" -> ReadSymbol raw |> FIXField.Symbol
        | "56" -> ReadTargetCompID raw |> FIXField.TargetCompID
        | "57" -> ReadTargetSubID raw |> FIXField.TargetSubID
        | "58" -> ReadText raw |> FIXField.Text
        | "59" -> ReadTimeInForce raw |> FIXField.TimeInForce
        | "60" -> ReadTransactTime raw |> FIXField.TransactTime
        | "61" -> ReadUrgency raw |> FIXField.Urgency
        | "62" -> ReadValidUntilTime raw |> FIXField.ValidUntilTime
        | "63" -> ReadSettlType raw |> FIXField.SettlType
        | "64" -> ReadSettlDate raw |> FIXField.SettlDate
        | "65" -> ReadSymbolSfx raw |> FIXField.SymbolSfx
        | "66" -> ReadListID raw |> FIXField.ListID
        | "67" -> ReadListSeqNo raw |> FIXField.ListSeqNo
        | "68" -> ReadTotNoOrders raw |> FIXField.TotNoOrders
        | "69" -> ReadListExecInst raw |> FIXField.ListExecInst
        | "70" -> ReadAllocID raw |> FIXField.AllocID
        | "71" -> ReadAllocTransType raw |> FIXField.AllocTransType
        | "72" -> ReadRefAllocID raw |> FIXField.RefAllocID
        | "73" -> ReadNoOrders raw |> FIXField.NoOrders
        | "74" -> ReadAvgPxPrecision raw |> FIXField.AvgPxPrecision
        | "75" -> ReadTradeDate raw |> FIXField.TradeDate
        | "77" -> ReadPositionEffect raw |> FIXField.PositionEffect
        | "78" -> ReadNoAllocs raw |> FIXField.NoAllocs
        | "79" -> ReadAllocAccount raw |> FIXField.AllocAccount
        | "80" -> ReadAllocQty raw |> FIXField.AllocQty
        | "81" -> ReadProcessCode raw |> FIXField.ProcessCode
        | "82" -> ReadNoRpts raw |> FIXField.NoRpts
        | "83" -> ReadRptSeq raw |> FIXField.RptSeq
        | "84" -> ReadCxlQty raw |> FIXField.CxlQty
        | "85" -> ReadNoDlvyInst raw |> FIXField.NoDlvyInst
        | "87" -> ReadAllocStatus raw |> FIXField.AllocStatus
        | "88" -> ReadAllocRejCode raw |> FIXField.AllocRejCode
        | "89" -> ReadSignature raw |> FIXField.Signature
        | "90" -> ReadSecureData raw strm|> FIXField.SecureData // len->string compound field
        | "93" -> ReadSignatureLength raw |> FIXField.SignatureLength
        | "94" -> ReadEmailType raw |> FIXField.EmailType
        | "95" -> ReadRawDataLength raw |> FIXField.RawDataLength
        | "96" -> ReadRawData raw |> FIXField.RawData
        | "97" -> ReadPossResend raw |> FIXField.PossResend
        | "98" -> ReadEncryptMethod raw |> FIXField.EncryptMethod
        | "99" -> ReadStopPx raw |> FIXField.StopPx
        | "100" -> ReadExDestination raw |> FIXField.ExDestination
        | "102" -> ReadCxlRejReason raw |> FIXField.CxlRejReason
        | "103" -> ReadOrdRejReason raw |> FIXField.OrdRejReason
        | "104" -> ReadIOIQualifier raw |> FIXField.IOIQualifier
        | "105" -> ReadWaveNo raw |> FIXField.WaveNo
        | "106" -> ReadIssuer raw |> FIXField.Issuer
        | "107" -> ReadSecurityDesc raw |> FIXField.SecurityDesc
        | "108" -> ReadHeartBtInt raw |> FIXField.HeartBtInt
        | "110" -> ReadMinQty raw |> FIXField.MinQty
        | "111" -> ReadMaxFloor raw |> FIXField.MaxFloor
        | "112" -> ReadTestReqID raw |> FIXField.TestReqID
        | "113" -> ReadReportToExch raw |> FIXField.ReportToExch
        | "114" -> ReadLocateReqd raw |> FIXField.LocateReqd
        | "115" -> ReadOnBehalfOfCompID raw |> FIXField.OnBehalfOfCompID
        | "116" -> ReadOnBehalfOfSubID raw |> FIXField.OnBehalfOfSubID
        | "117" -> ReadQuoteID raw |> FIXField.QuoteID
        | "118" -> ReadNetMoney raw |> FIXField.NetMoney
        | "119" -> ReadSettlCurrAmt raw |> FIXField.SettlCurrAmt
        | "120" -> ReadSettlCurrency raw |> FIXField.SettlCurrency
        | "121" -> ReadForexReq raw |> FIXField.ForexReq
        | "122" -> ReadOrigSendingTime raw |> FIXField.OrigSendingTime
        | "123" -> ReadGapFillFlag raw |> FIXField.GapFillFlag
        | "124" -> ReadNoExecs raw |> FIXField.NoExecs
        | "126" -> ReadExpireTime raw |> FIXField.ExpireTime
        | "127" -> ReadDKReason raw |> FIXField.DKReason
        | "128" -> ReadDeliverToCompID raw |> FIXField.DeliverToCompID
        | "129" -> ReadDeliverToSubID raw |> FIXField.DeliverToSubID
        | "130" -> ReadIOINaturalFlag raw |> FIXField.IOINaturalFlag
        | "131" -> ReadQuoteReqID raw |> FIXField.QuoteReqID
        | "132" -> ReadBidPx raw |> FIXField.BidPx
        | "133" -> ReadOfferPx raw |> FIXField.OfferPx
        | "134" -> ReadBidSize raw |> FIXField.BidSize
        | "135" -> ReadOfferSize raw |> FIXField.OfferSize
        | "136" -> ReadNoMiscFees raw |> FIXField.NoMiscFees
        | "137" -> ReadMiscFeeAmt raw |> FIXField.MiscFeeAmt
        | "138" -> ReadMiscFeeCurr raw |> FIXField.MiscFeeCurr
        | "139" -> ReadMiscFeeType raw |> FIXField.MiscFeeType
        | "140" -> ReadPrevClosePx raw |> FIXField.PrevClosePx
        | "141" -> ReadResetSeqNumFlag raw |> FIXField.ResetSeqNumFlag
        | "142" -> ReadSenderLocationID raw |> FIXField.SenderLocationID
        | "143" -> ReadTargetLocationID raw |> FIXField.TargetLocationID
        | "144" -> ReadOnBehalfOfLocationID raw |> FIXField.OnBehalfOfLocationID
        | "145" -> ReadDeliverToLocationID raw |> FIXField.DeliverToLocationID
        | "146" -> ReadNoRelatedSym raw |> FIXField.NoRelatedSym
        | "147" -> ReadSubject raw |> FIXField.Subject
        | "148" -> ReadHeadline raw |> FIXField.Headline
        | "149" -> ReadURLLink raw |> FIXField.URLLink
        | "150" -> ReadExecType raw |> FIXField.ExecType
        | "151" -> ReadLeavesQty raw |> FIXField.LeavesQty
        | "152" -> ReadCashOrderQty raw |> FIXField.CashOrderQty
        | "153" -> ReadAllocAvgPx raw |> FIXField.AllocAvgPx
        | "154" -> ReadAllocNetMoney raw |> FIXField.AllocNetMoney
        | "155" -> ReadSettlCurrFxRate raw |> FIXField.SettlCurrFxRate
        | "156" -> ReadSettlCurrFxRateCalc raw |> FIXField.SettlCurrFxRateCalc
        | "157" -> ReadNumDaysInterest raw |> FIXField.NumDaysInterest
        | "158" -> ReadAccruedInterestRate raw |> FIXField.AccruedInterestRate
        | "159" -> ReadAccruedInterestAmt raw |> FIXField.AccruedInterestAmt
        | "160" -> ReadSettlInstMode raw |> FIXField.SettlInstMode
        | "161" -> ReadAllocText raw |> FIXField.AllocText
        | "162" -> ReadSettlInstID raw |> FIXField.SettlInstID
        | "163" -> ReadSettlInstTransType raw |> FIXField.SettlInstTransType
        | "164" -> ReadEmailThreadID raw |> FIXField.EmailThreadID
        | "165" -> ReadSettlInstSource raw |> FIXField.SettlInstSource
        | "167" -> ReadSecurityType raw |> FIXField.SecurityType
        | "168" -> ReadEffectiveTime raw |> FIXField.EffectiveTime
        | "169" -> ReadStandInstDbType raw |> FIXField.StandInstDbType
        | "170" -> ReadStandInstDbName raw |> FIXField.StandInstDbName
        | "171" -> ReadStandInstDbID raw |> FIXField.StandInstDbID
        | "172" -> ReadSettlDeliveryType raw |> FIXField.SettlDeliveryType
        | "188" -> ReadBidSpotRate raw |> FIXField.BidSpotRate
        | "189" -> ReadBidForwardPoints raw |> FIXField.BidForwardPoints
        | "190" -> ReadOfferSpotRate raw |> FIXField.OfferSpotRate
        | "191" -> ReadOfferForwardPoints raw |> FIXField.OfferForwardPoints
        | "192" -> ReadOrderQty2 raw |> FIXField.OrderQty2
        | "193" -> ReadSettlDate2 raw |> FIXField.SettlDate2
        | "194" -> ReadLastSpotRate raw |> FIXField.LastSpotRate
        | "195" -> ReadLastForwardPoints raw |> FIXField.LastForwardPoints
        | "196" -> ReadAllocLinkID raw |> FIXField.AllocLinkID
        | "197" -> ReadAllocLinkType raw |> FIXField.AllocLinkType
        | "198" -> ReadSecondaryOrderID raw |> FIXField.SecondaryOrderID
        | "199" -> ReadNoIOIQualifiers raw |> FIXField.NoIOIQualifiers
        | "200" -> ReadMaturityMonthYear raw |> FIXField.MaturityMonthYear
        | "201" -> ReadPutOrCall raw |> FIXField.PutOrCall
        | "202" -> ReadStrikePrice raw |> FIXField.StrikePrice
        | "203" -> ReadCoveredOrUncovered raw |> FIXField.CoveredOrUncovered
        | "206" -> ReadOptAttribute raw |> FIXField.OptAttribute
        | "207" -> ReadSecurityExchange raw |> FIXField.SecurityExchange
        | "208" -> ReadNotifyBrokerOfCredit raw |> FIXField.NotifyBrokerOfCredit
        | "209" -> ReadAllocHandlInst raw |> FIXField.AllocHandlInst
        | "210" -> ReadMaxShow raw |> FIXField.MaxShow
        | "211" -> ReadPegOffsetValue raw |> FIXField.PegOffsetValue
        | "212" -> ReadXmlData raw strm|> FIXField.XmlData // len->string compound field
        | "214" -> ReadSettlInstRefID raw |> FIXField.SettlInstRefID
        | "215" -> ReadNoRoutingIDs raw |> FIXField.NoRoutingIDs
        | "216" -> ReadRoutingType raw |> FIXField.RoutingType
        | "217" -> ReadRoutingID raw |> FIXField.RoutingID
        | "218" -> ReadSpread raw |> FIXField.Spread
        | "220" -> ReadBenchmarkCurveCurrency raw |> FIXField.BenchmarkCurveCurrency
        | "221" -> ReadBenchmarkCurveName raw |> FIXField.BenchmarkCurveName
        | "222" -> ReadBenchmarkCurvePoint raw |> FIXField.BenchmarkCurvePoint
        | "223" -> ReadCouponRate raw |> FIXField.CouponRate
        | "224" -> ReadCouponPaymentDate raw |> FIXField.CouponPaymentDate
        | "225" -> ReadIssueDate raw |> FIXField.IssueDate
        | "226" -> ReadRepurchaseTerm raw |> FIXField.RepurchaseTerm
        | "227" -> ReadRepurchaseRate raw |> FIXField.RepurchaseRate
        | "228" -> ReadFactor raw |> FIXField.Factor
        | "229" -> ReadTradeOriginationDate raw |> FIXField.TradeOriginationDate
        | "230" -> ReadExDate raw |> FIXField.ExDate
        | "231" -> ReadContractMultiplier raw |> FIXField.ContractMultiplier
        | "232" -> ReadNoStipulations raw |> FIXField.NoStipulations
        | "233" -> ReadStipulationType raw |> FIXField.StipulationType
        | "234" -> ReadStipulationValue raw |> FIXField.StipulationValue
        | "235" -> ReadYieldType raw |> FIXField.YieldType
        | "236" -> ReadYield raw |> FIXField.Yield
        | "237" -> ReadTotalTakedown raw |> FIXField.TotalTakedown
        | "238" -> ReadConcession raw |> FIXField.Concession
        | "239" -> ReadRepoCollateralSecurityType raw |> FIXField.RepoCollateralSecurityType
        | "240" -> ReadRedemptionDate raw |> FIXField.RedemptionDate
        | "241" -> ReadUnderlyingCouponPaymentDate raw |> FIXField.UnderlyingCouponPaymentDate
        | "242" -> ReadUnderlyingIssueDate raw |> FIXField.UnderlyingIssueDate
        | "243" -> ReadUnderlyingRepoCollateralSecurityType raw |> FIXField.UnderlyingRepoCollateralSecurityType
        | "244" -> ReadUnderlyingRepurchaseTerm raw |> FIXField.UnderlyingRepurchaseTerm
        | "245" -> ReadUnderlyingRepurchaseRate raw |> FIXField.UnderlyingRepurchaseRate
        | "246" -> ReadUnderlyingFactor raw |> FIXField.UnderlyingFactor
        | "247" -> ReadUnderlyingRedemptionDate raw |> FIXField.UnderlyingRedemptionDate
        | "248" -> ReadLegCouponPaymentDate raw |> FIXField.LegCouponPaymentDate
        | "249" -> ReadLegIssueDate raw |> FIXField.LegIssueDate
        | "250" -> ReadLegRepoCollateralSecurityType raw |> FIXField.LegRepoCollateralSecurityType
        | "251" -> ReadLegRepurchaseTerm raw |> FIXField.LegRepurchaseTerm
        | "252" -> ReadLegRepurchaseRate raw |> FIXField.LegRepurchaseRate
        | "253" -> ReadLegFactor raw |> FIXField.LegFactor
        | "254" -> ReadLegRedemptionDate raw |> FIXField.LegRedemptionDate
        | "255" -> ReadCreditRating raw |> FIXField.CreditRating
        | "256" -> ReadUnderlyingCreditRating raw |> FIXField.UnderlyingCreditRating
        | "257" -> ReadLegCreditRating raw |> FIXField.LegCreditRating
        | "258" -> ReadTradedFlatSwitch raw |> FIXField.TradedFlatSwitch
        | "259" -> ReadBasisFeatureDate raw |> FIXField.BasisFeatureDate
        | "260" -> ReadBasisFeaturePrice raw |> FIXField.BasisFeaturePrice
        | "262" -> ReadMDReqID raw |> FIXField.MDReqID
        | "263" -> ReadSubscriptionRequestType raw |> FIXField.SubscriptionRequestType
        | "264" -> ReadMarketDepth raw |> FIXField.MarketDepth
        | "265" -> ReadMDUpdateType raw |> FIXField.MDUpdateType
        | "266" -> ReadAggregatedBook raw |> FIXField.AggregatedBook
        | "267" -> ReadNoMDEntryTypes raw |> FIXField.NoMDEntryTypes
        | "268" -> ReadNoMDEntries raw |> FIXField.NoMDEntries
        | "269" -> ReadMDEntryType raw |> FIXField.MDEntryType
        | "270" -> ReadMDEntryPx raw |> FIXField.MDEntryPx
        | "271" -> ReadMDEntrySize raw |> FIXField.MDEntrySize
        | "272" -> ReadMDEntryDate raw |> FIXField.MDEntryDate
        | "273" -> ReadMDEntryTime raw |> FIXField.MDEntryTime
        | "274" -> ReadTickDirection raw |> FIXField.TickDirection
        | "275" -> ReadMDMkt raw |> FIXField.MDMkt
        | "276" -> ReadQuoteCondition raw |> FIXField.QuoteCondition
        | "277" -> ReadTradeCondition raw |> FIXField.TradeCondition
        | "278" -> ReadMDEntryID raw |> FIXField.MDEntryID
        | "279" -> ReadMDUpdateAction raw |> FIXField.MDUpdateAction
        | "280" -> ReadMDEntryRefID raw |> FIXField.MDEntryRefID
        | "281" -> ReadMDReqRejReason raw |> FIXField.MDReqRejReason
        | "282" -> ReadMDEntryOriginator raw |> FIXField.MDEntryOriginator
        | "283" -> ReadLocationID raw |> FIXField.LocationID
        | "284" -> ReadDeskID raw |> FIXField.DeskID
        | "285" -> ReadDeleteReason raw |> FIXField.DeleteReason
        | "286" -> ReadOpenCloseSettlFlag raw |> FIXField.OpenCloseSettlFlag
        | "287" -> ReadSellerDays raw |> FIXField.SellerDays
        | "288" -> ReadMDEntryBuyer raw |> FIXField.MDEntryBuyer
        | "289" -> ReadMDEntrySeller raw |> FIXField.MDEntrySeller
        | "290" -> ReadMDEntryPositionNo raw |> FIXField.MDEntryPositionNo
        | "291" -> ReadFinancialStatus raw |> FIXField.FinancialStatus
        | "292" -> ReadCorporateAction raw |> FIXField.CorporateAction
        | "293" -> ReadDefBidSize raw |> FIXField.DefBidSize
        | "294" -> ReadDefOfferSize raw |> FIXField.DefOfferSize
        | "295" -> ReadNoQuoteEntries raw |> FIXField.NoQuoteEntries
        | "296" -> ReadNoQuoteSets raw |> FIXField.NoQuoteSets
        | "297" -> ReadQuoteStatus raw |> FIXField.QuoteStatus
        | "298" -> ReadQuoteCancelType raw |> FIXField.QuoteCancelType
        | "299" -> ReadQuoteEntryID raw |> FIXField.QuoteEntryID
        | "300" -> ReadQuoteRejectReason raw |> FIXField.QuoteRejectReason
        | "301" -> ReadQuoteResponseLevel raw |> FIXField.QuoteResponseLevel
        | "302" -> ReadQuoteSetID raw |> FIXField.QuoteSetID
        | "303" -> ReadQuoteRequestType raw |> FIXField.QuoteRequestType
        | "304" -> ReadTotNoQuoteEntries raw |> FIXField.TotNoQuoteEntries
        | "305" -> ReadUnderlyingSecurityIDSource raw |> FIXField.UnderlyingSecurityIDSource
        | "306" -> ReadUnderlyingIssuer raw |> FIXField.UnderlyingIssuer
        | "307" -> ReadUnderlyingSecurityDesc raw |> FIXField.UnderlyingSecurityDesc
        | "308" -> ReadUnderlyingSecurityExchange raw |> FIXField.UnderlyingSecurityExchange
        | "309" -> ReadUnderlyingSecurityID raw |> FIXField.UnderlyingSecurityID
        | "310" -> ReadUnderlyingSecurityType raw |> FIXField.UnderlyingSecurityType
        | "311" -> ReadUnderlyingSymbol raw |> FIXField.UnderlyingSymbol
        | "312" -> ReadUnderlyingSymbolSfx raw |> FIXField.UnderlyingSymbolSfx
        | "313" -> ReadUnderlyingMaturityMonthYear raw |> FIXField.UnderlyingMaturityMonthYear
        | "315" -> ReadUnderlyingPutOrCall raw |> FIXField.UnderlyingPutOrCall
        | "316" -> ReadUnderlyingStrikePrice raw |> FIXField.UnderlyingStrikePrice
        | "317" -> ReadUnderlyingOptAttribute raw |> FIXField.UnderlyingOptAttribute
        | "318" -> ReadUnderlyingCurrency raw |> FIXField.UnderlyingCurrency
        | "320" -> ReadSecurityReqID raw |> FIXField.SecurityReqID
        | "321" -> ReadSecurityRequestType raw |> FIXField.SecurityRequestType
        | "322" -> ReadSecurityResponseID raw |> FIXField.SecurityResponseID
        | "323" -> ReadSecurityResponseType raw |> FIXField.SecurityResponseType
        | "324" -> ReadSecurityStatusReqID raw |> FIXField.SecurityStatusReqID
        | "325" -> ReadUnsolicitedIndicator raw |> FIXField.UnsolicitedIndicator
        | "326" -> ReadSecurityTradingStatus raw |> FIXField.SecurityTradingStatus
        | "327" -> ReadHaltReason raw |> FIXField.HaltReason
        | "328" -> ReadInViewOfCommon raw |> FIXField.InViewOfCommon
        | "329" -> ReadDueToRelated raw |> FIXField.DueToRelated
        | "330" -> ReadBuyVolume raw |> FIXField.BuyVolume
        | "331" -> ReadSellVolume raw |> FIXField.SellVolume
        | "332" -> ReadHighPx raw |> FIXField.HighPx
        | "333" -> ReadLowPx raw |> FIXField.LowPx
        | "334" -> ReadAdjustment raw |> FIXField.Adjustment
        | "335" -> ReadTradSesReqID raw |> FIXField.TradSesReqID
        | "336" -> ReadTradingSessionID raw |> FIXField.TradingSessionID
        | "337" -> ReadContraTrader raw |> FIXField.ContraTrader
        | "338" -> ReadTradSesMethod raw |> FIXField.TradSesMethod
        | "339" -> ReadTradSesMode raw |> FIXField.TradSesMode
        | "340" -> ReadTradSesStatus raw |> FIXField.TradSesStatus
        | "341" -> ReadTradSesStartTime raw |> FIXField.TradSesStartTime
        | "342" -> ReadTradSesOpenTime raw |> FIXField.TradSesOpenTime
        | "343" -> ReadTradSesPreCloseTime raw |> FIXField.TradSesPreCloseTime
        | "344" -> ReadTradSesCloseTime raw |> FIXField.TradSesCloseTime
        | "345" -> ReadTradSesEndTime raw |> FIXField.TradSesEndTime
        | "346" -> ReadNumberOfOrders raw |> FIXField.NumberOfOrders
        | "347" -> ReadMessageEncoding raw |> FIXField.MessageEncoding
        | "348" -> ReadEncodedIssuer raw strm|> FIXField.EncodedIssuer // len->string compound field
        | "350" -> ReadEncodedSecurityDesc raw strm|> FIXField.EncodedSecurityDesc // len->string compound field
        | "352" -> ReadEncodedListExecInst raw strm|> FIXField.EncodedListExecInst // len->string compound field
        | "354" -> ReadEncodedText raw strm|> FIXField.EncodedText // len->string compound field
        | "356" -> ReadEncodedSubject raw strm|> FIXField.EncodedSubject // len->string compound field
        | "358" -> ReadEncodedHeadline raw strm|> FIXField.EncodedHeadline // len->string compound field
        | "360" -> ReadEncodedAllocText raw strm|> FIXField.EncodedAllocText // len->string compound field
        | "362" -> ReadEncodedUnderlyingIssuer raw strm|> FIXField.EncodedUnderlyingIssuer // len->string compound field
        | "364" -> ReadEncodedUnderlyingSecurityDesc raw strm|> FIXField.EncodedUnderlyingSecurityDesc // len->string compound field
        | "366" -> ReadAllocPrice raw |> FIXField.AllocPrice
        | "367" -> ReadQuoteSetValidUntilTime raw |> FIXField.QuoteSetValidUntilTime
        | "368" -> ReadQuoteEntryRejectReason raw |> FIXField.QuoteEntryRejectReason
        | "369" -> ReadLastMsgSeqNumProcessed raw |> FIXField.LastMsgSeqNumProcessed
        | "371" -> ReadRefTagID raw |> FIXField.RefTagID
        | "372" -> ReadRefMsgType raw |> FIXField.RefMsgType
        | "373" -> ReadSessionRejectReason raw |> FIXField.SessionRejectReason
        | "374" -> ReadBidRequestTransType raw |> FIXField.BidRequestTransType
        | "375" -> ReadContraBroker raw |> FIXField.ContraBroker
        | "376" -> ReadComplianceID raw |> FIXField.ComplianceID
        | "377" -> ReadSolicitedFlag raw |> FIXField.SolicitedFlag
        | "378" -> ReadExecRestatementReason raw |> FIXField.ExecRestatementReason
        | "379" -> ReadBusinessRejectRefID raw |> FIXField.BusinessRejectRefID
        | "380" -> ReadBusinessRejectReason raw |> FIXField.BusinessRejectReason
        | "381" -> ReadGrossTradeAmt raw |> FIXField.GrossTradeAmt
        | "382" -> ReadNoContraBrokers raw |> FIXField.NoContraBrokers
        | "383" -> ReadMaxMessageSize raw |> FIXField.MaxMessageSize
        | "384" -> ReadNoMsgTypes raw |> FIXField.NoMsgTypes
        | "385" -> ReadMsgDirection raw |> FIXField.MsgDirection
        | "386" -> ReadNoTradingSessions raw |> FIXField.NoTradingSessions
        | "387" -> ReadTotalVolumeTraded raw |> FIXField.TotalVolumeTraded
        | "388" -> ReadDiscretionInst raw |> FIXField.DiscretionInst
        | "389" -> ReadDiscretionOffsetValue raw |> FIXField.DiscretionOffsetValue
        | "390" -> ReadBidID raw |> FIXField.BidID
        | "391" -> ReadClientBidID raw |> FIXField.ClientBidID
        | "392" -> ReadListName raw |> FIXField.ListName
        | "393" -> ReadTotNoRelatedSym raw |> FIXField.TotNoRelatedSym
        | "394" -> ReadBidType raw |> FIXField.BidType
        | "395" -> ReadNumTickets raw |> FIXField.NumTickets
        | "396" -> ReadSideValue1 raw |> FIXField.SideValue1
        | "397" -> ReadSideValue2 raw |> FIXField.SideValue2
        | "398" -> ReadNoBidDescriptors raw |> FIXField.NoBidDescriptors
        | "399" -> ReadBidDescriptorType raw |> FIXField.BidDescriptorType
        | "400" -> ReadBidDescriptor raw |> FIXField.BidDescriptor
        | "401" -> ReadSideValueInd raw |> FIXField.SideValueInd
        | "402" -> ReadLiquidityPctLow raw |> FIXField.LiquidityPctLow
        | "403" -> ReadLiquidityPctHigh raw |> FIXField.LiquidityPctHigh
        | "404" -> ReadLiquidityValue raw |> FIXField.LiquidityValue
        | "405" -> ReadEFPTrackingError raw |> FIXField.EFPTrackingError
        | "406" -> ReadFairValue raw |> FIXField.FairValue
        | "407" -> ReadOutsideIndexPct raw |> FIXField.OutsideIndexPct
        | "408" -> ReadValueOfFutures raw |> FIXField.ValueOfFutures
        | "409" -> ReadLiquidityIndType raw |> FIXField.LiquidityIndType
        | "410" -> ReadWtAverageLiquidity raw |> FIXField.WtAverageLiquidity
        | "411" -> ReadExchangeForPhysical raw |> FIXField.ExchangeForPhysical
        | "412" -> ReadOutMainCntryUIndex raw |> FIXField.OutMainCntryUIndex
        | "413" -> ReadCrossPercent raw |> FIXField.CrossPercent
        | "414" -> ReadProgRptReqs raw |> FIXField.ProgRptReqs
        | "415" -> ReadProgPeriodInterval raw |> FIXField.ProgPeriodInterval
        | "416" -> ReadIncTaxInd raw |> FIXField.IncTaxInd
        | "417" -> ReadNumBidders raw |> FIXField.NumBidders
        | "418" -> ReadBidTradeType raw |> FIXField.BidTradeType
        | "419" -> ReadBasisPxType raw |> FIXField.BasisPxType
        | "420" -> ReadNoBidComponents raw |> FIXField.NoBidComponents
        | "421" -> ReadCountry raw |> FIXField.Country
        | "422" -> ReadTotNoStrikes raw |> FIXField.TotNoStrikes
        | "423" -> ReadPriceType raw |> FIXField.PriceType
        | "424" -> ReadDayOrderQty raw |> FIXField.DayOrderQty
        | "425" -> ReadDayCumQty raw |> FIXField.DayCumQty
        | "426" -> ReadDayAvgPx raw |> FIXField.DayAvgPx
        | "427" -> ReadGTBookingInst raw |> FIXField.GTBookingInst
        | "428" -> ReadNoStrikes raw |> FIXField.NoStrikes
        | "429" -> ReadListStatusType raw |> FIXField.ListStatusType
        | "430" -> ReadNetGrossInd raw |> FIXField.NetGrossInd
        | "431" -> ReadListOrderStatus raw |> FIXField.ListOrderStatus
        | "432" -> ReadExpireDate raw |> FIXField.ExpireDate
        | "433" -> ReadListExecInstType raw |> FIXField.ListExecInstType
        | "434" -> ReadCxlRejResponseTo raw |> FIXField.CxlRejResponseTo
        | "435" -> ReadUnderlyingCouponRate raw |> FIXField.UnderlyingCouponRate
        | "436" -> ReadUnderlyingContractMultiplier raw |> FIXField.UnderlyingContractMultiplier
        | "437" -> ReadContraTradeQty raw |> FIXField.ContraTradeQty
        | "438" -> ReadContraTradeTime raw |> FIXField.ContraTradeTime
        | "441" -> ReadLiquidityNumSecurities raw |> FIXField.LiquidityNumSecurities
        | "442" -> ReadMultiLegReportingType raw |> FIXField.MultiLegReportingType
        | "443" -> ReadStrikeTime raw |> FIXField.StrikeTime
        | "444" -> ReadListStatusText raw |> FIXField.ListStatusText
        | "445" -> ReadEncodedListStatusText raw strm|> FIXField.EncodedListStatusText // len->string compound field
        | "447" -> ReadPartyIDSource raw |> FIXField.PartyIDSource
        | "448" -> ReadPartyID raw |> FIXField.PartyID
        | "451" -> ReadNetChgPrevDay raw |> FIXField.NetChgPrevDay
        | "452" -> ReadPartyRole raw |> FIXField.PartyRole
        | "453" -> ReadNoPartyIDs raw |> FIXField.NoPartyIDs
        | "454" -> ReadNoSecurityAltID raw |> FIXField.NoSecurityAltID
        | "455" -> ReadSecurityAltID raw |> FIXField.SecurityAltID
        | "456" -> ReadSecurityAltIDSource raw |> FIXField.SecurityAltIDSource
        | "457" -> ReadNoUnderlyingSecurityAltID raw |> FIXField.NoUnderlyingSecurityAltID
        | "458" -> ReadUnderlyingSecurityAltID raw |> FIXField.UnderlyingSecurityAltID
        | "459" -> ReadUnderlyingSecurityAltIDSource raw |> FIXField.UnderlyingSecurityAltIDSource
        | "460" -> ReadProduct raw |> FIXField.Product
        | "461" -> ReadCFICode raw |> FIXField.CFICode
        | "462" -> ReadUnderlyingProduct raw |> FIXField.UnderlyingProduct
        | "463" -> ReadUnderlyingCFICode raw |> FIXField.UnderlyingCFICode
        | "464" -> ReadTestMessageIndicator raw |> FIXField.TestMessageIndicator
        | "465" -> ReadQuantityType raw |> FIXField.QuantityType
        | "466" -> ReadBookingRefID raw |> FIXField.BookingRefID
        | "467" -> ReadIndividualAllocID raw |> FIXField.IndividualAllocID
        | "468" -> ReadRoundingDirection raw |> FIXField.RoundingDirection
        | "469" -> ReadRoundingModulus raw |> FIXField.RoundingModulus
        | "470" -> ReadCountryOfIssue raw |> FIXField.CountryOfIssue
        | "471" -> ReadStateOrProvinceOfIssue raw |> FIXField.StateOrProvinceOfIssue
        | "472" -> ReadLocaleOfIssue raw |> FIXField.LocaleOfIssue
        | "473" -> ReadNoRegistDtls raw |> FIXField.NoRegistDtls
        | "474" -> ReadMailingDtls raw |> FIXField.MailingDtls
        | "475" -> ReadInvestorCountryOfResidence raw |> FIXField.InvestorCountryOfResidence
        | "476" -> ReadPaymentRef raw |> FIXField.PaymentRef
        | "477" -> ReadDistribPaymentMethod raw |> FIXField.DistribPaymentMethod
        | "478" -> ReadCashDistribCurr raw |> FIXField.CashDistribCurr
        | "479" -> ReadCommCurrency raw |> FIXField.CommCurrency
        | "480" -> ReadCancellationRights raw |> FIXField.CancellationRights
        | "481" -> ReadMoneyLaunderingStatus raw |> FIXField.MoneyLaunderingStatus
        | "482" -> ReadMailingInst raw |> FIXField.MailingInst
        | "483" -> ReadTransBkdTime raw |> FIXField.TransBkdTime
        | "484" -> ReadExecPriceType raw |> FIXField.ExecPriceType
        | "485" -> ReadExecPriceAdjustment raw |> FIXField.ExecPriceAdjustment
        | "486" -> ReadDateOfBirth raw |> FIXField.DateOfBirth
        | "487" -> ReadTradeReportTransType raw |> FIXField.TradeReportTransType
        | "488" -> ReadCardHolderName raw |> FIXField.CardHolderName
        | "489" -> ReadCardNumber raw |> FIXField.CardNumber
        | "490" -> ReadCardExpDate raw |> FIXField.CardExpDate
        | "491" -> ReadCardIssNum raw |> FIXField.CardIssNum
        | "492" -> ReadPaymentMethod raw |> FIXField.PaymentMethod
        | "493" -> ReadRegistAcctType raw |> FIXField.RegistAcctType
        | "494" -> ReadDesignation raw |> FIXField.Designation
        | "495" -> ReadTaxAdvantageType raw |> FIXField.TaxAdvantageType
        | "496" -> ReadRegistRejReasonText raw |> FIXField.RegistRejReasonText
        | "497" -> ReadFundRenewWaiv raw |> FIXField.FundRenewWaiv
        | "498" -> ReadCashDistribAgentName raw |> FIXField.CashDistribAgentName
        | "499" -> ReadCashDistribAgentCode raw |> FIXField.CashDistribAgentCode
        | "500" -> ReadCashDistribAgentAcctNumber raw |> FIXField.CashDistribAgentAcctNumber
        | "501" -> ReadCashDistribPayRef raw |> FIXField.CashDistribPayRef
        | "502" -> ReadCashDistribAgentAcctName raw |> FIXField.CashDistribAgentAcctName
        | "503" -> ReadCardStartDate raw |> FIXField.CardStartDate
        | "504" -> ReadPaymentDate raw |> FIXField.PaymentDate
        | "505" -> ReadPaymentRemitterID raw |> FIXField.PaymentRemitterID
        | "506" -> ReadRegistStatus raw |> FIXField.RegistStatus
        | "507" -> ReadRegistRejReasonCode raw |> FIXField.RegistRejReasonCode
        | "508" -> ReadRegistRefID raw |> FIXField.RegistRefID
        | "509" -> ReadRegistDtls raw |> FIXField.RegistDtls
        | "510" -> ReadNoDistribInsts raw |> FIXField.NoDistribInsts
        | "511" -> ReadRegistEmail raw |> FIXField.RegistEmail
        | "512" -> ReadDistribPercentage raw |> FIXField.DistribPercentage
        | "513" -> ReadRegistID raw |> FIXField.RegistID
        | "514" -> ReadRegistTransType raw |> FIXField.RegistTransType
        | "515" -> ReadExecValuationPoint raw |> FIXField.ExecValuationPoint
        | "516" -> ReadOrderPercent raw |> FIXField.OrderPercent
        | "517" -> ReadOwnershipType raw |> FIXField.OwnershipType
        | "518" -> ReadNoContAmts raw |> FIXField.NoContAmts
        | "519" -> ReadContAmtType raw |> FIXField.ContAmtType
        | "520" -> ReadContAmtValue raw |> FIXField.ContAmtValue
        | "521" -> ReadContAmtCurr raw |> FIXField.ContAmtCurr
        | "522" -> ReadOwnerType raw |> FIXField.OwnerType
        | "523" -> ReadPartySubID raw |> FIXField.PartySubID
        | "524" -> ReadNestedPartyID raw |> FIXField.NestedPartyID
        | "525" -> ReadNestedPartyIDSource raw |> FIXField.NestedPartyIDSource
        | "526" -> ReadSecondaryClOrdID raw |> FIXField.SecondaryClOrdID
        | "527" -> ReadSecondaryExecID raw |> FIXField.SecondaryExecID
        | "528" -> ReadOrderCapacity raw |> FIXField.OrderCapacity
        | "529" -> ReadOrderRestrictions raw |> FIXField.OrderRestrictions
        | "530" -> ReadMassCancelRequestType raw |> FIXField.MassCancelRequestType
        | "531" -> ReadMassCancelResponse raw |> FIXField.MassCancelResponse
        | "532" -> ReadMassCancelRejectReason raw |> FIXField.MassCancelRejectReason
        | "533" -> ReadTotalAffectedOrders raw |> FIXField.TotalAffectedOrders
        | "534" -> ReadNoAffectedOrders raw |> FIXField.NoAffectedOrders
        | "535" -> ReadAffectedOrderID raw |> FIXField.AffectedOrderID
        | "536" -> ReadAffectedSecondaryOrderID raw |> FIXField.AffectedSecondaryOrderID
        | "537" -> ReadQuoteType raw |> FIXField.QuoteType
        | "538" -> ReadNestedPartyRole raw |> FIXField.NestedPartyRole
        | "539" -> ReadNoNestedPartyIDs raw |> FIXField.NoNestedPartyIDs
        | "540" -> ReadTotalAccruedInterestAmt raw |> FIXField.TotalAccruedInterestAmt
        | "541" -> ReadMaturityDate raw |> FIXField.MaturityDate
        | "542" -> ReadUnderlyingMaturityDate raw |> FIXField.UnderlyingMaturityDate
        | "543" -> ReadInstrRegistry raw |> FIXField.InstrRegistry
        | "544" -> ReadCashMargin raw |> FIXField.CashMargin
        | "545" -> ReadNestedPartySubID raw |> FIXField.NestedPartySubID
        | "546" -> ReadScope raw |> FIXField.Scope
        | "547" -> ReadMDImplicitDelete raw |> FIXField.MDImplicitDelete
        | "548" -> ReadCrossID raw |> FIXField.CrossID
        | "549" -> ReadCrossType raw |> FIXField.CrossType
        | "550" -> ReadCrossPrioritization raw |> FIXField.CrossPrioritization
        | "551" -> ReadOrigCrossID raw |> FIXField.OrigCrossID
        | "552" -> ReadNoSides raw |> FIXField.NoSides
        | "553" -> ReadUsername raw |> FIXField.Username
        | "554" -> ReadPassword raw |> FIXField.Password
        | "555" -> ReadNoLegs raw |> FIXField.NoLegs
        | "556" -> ReadLegCurrency raw |> FIXField.LegCurrency
        | "557" -> ReadTotNoSecurityTypes raw |> FIXField.TotNoSecurityTypes
        | "558" -> ReadNoSecurityTypes raw |> FIXField.NoSecurityTypes
        | "559" -> ReadSecurityListRequestType raw |> FIXField.SecurityListRequestType
        | "560" -> ReadSecurityRequestResult raw |> FIXField.SecurityRequestResult
        | "561" -> ReadRoundLot raw |> FIXField.RoundLot
        | "562" -> ReadMinTradeVol raw |> FIXField.MinTradeVol
        | "563" -> ReadMultiLegRptTypeReq raw |> FIXField.MultiLegRptTypeReq
        | "564" -> ReadLegPositionEffect raw |> FIXField.LegPositionEffect
        | "565" -> ReadLegCoveredOrUncovered raw |> FIXField.LegCoveredOrUncovered
        | "566" -> ReadLegPrice raw |> FIXField.LegPrice
        | "567" -> ReadTradSesStatusRejReason raw |> FIXField.TradSesStatusRejReason
        | "568" -> ReadTradeRequestID raw |> FIXField.TradeRequestID
        | "569" -> ReadTradeRequestType raw |> FIXField.TradeRequestType
        | "570" -> ReadPreviouslyReported raw |> FIXField.PreviouslyReported
        | "571" -> ReadTradeReportID raw |> FIXField.TradeReportID
        | "572" -> ReadTradeReportRefID raw |> FIXField.TradeReportRefID
        | "573" -> ReadMatchStatus raw |> FIXField.MatchStatus
        | "574" -> ReadMatchType raw |> FIXField.MatchType
        | "575" -> ReadOddLot raw |> FIXField.OddLot
        | "576" -> ReadNoClearingInstructions raw |> FIXField.NoClearingInstructions
        | "577" -> ReadClearingInstruction raw |> FIXField.ClearingInstruction
        | "578" -> ReadTradeInputSource raw |> FIXField.TradeInputSource
        | "579" -> ReadTradeInputDevice raw |> FIXField.TradeInputDevice
        | "580" -> ReadNoDates raw |> FIXField.NoDates
        | "581" -> ReadAccountType raw |> FIXField.AccountType
        | "582" -> ReadCustOrderCapacity raw |> FIXField.CustOrderCapacity
        | "583" -> ReadClOrdLinkID raw |> FIXField.ClOrdLinkID
        | "584" -> ReadMassStatusReqID raw |> FIXField.MassStatusReqID
        | "585" -> ReadMassStatusReqType raw |> FIXField.MassStatusReqType
        | "586" -> ReadOrigOrdModTime raw |> FIXField.OrigOrdModTime
        | "587" -> ReadLegSettlType raw |> FIXField.LegSettlType
        | "588" -> ReadLegSettlDate raw |> FIXField.LegSettlDate
        | "589" -> ReadDayBookingInst raw |> FIXField.DayBookingInst
        | "590" -> ReadBookingUnit raw |> FIXField.BookingUnit
        | "591" -> ReadPreallocMethod raw |> FIXField.PreallocMethod
        | "592" -> ReadUnderlyingCountryOfIssue raw |> FIXField.UnderlyingCountryOfIssue
        | "593" -> ReadUnderlyingStateOrProvinceOfIssue raw |> FIXField.UnderlyingStateOrProvinceOfIssue
        | "594" -> ReadUnderlyingLocaleOfIssue raw |> FIXField.UnderlyingLocaleOfIssue
        | "595" -> ReadUnderlyingInstrRegistry raw |> FIXField.UnderlyingInstrRegistry
        | "596" -> ReadLegCountryOfIssue raw |> FIXField.LegCountryOfIssue
        | "597" -> ReadLegStateOrProvinceOfIssue raw |> FIXField.LegStateOrProvinceOfIssue
        | "598" -> ReadLegLocaleOfIssue raw |> FIXField.LegLocaleOfIssue
        | "599" -> ReadLegInstrRegistry raw |> FIXField.LegInstrRegistry
        | "600" -> ReadLegSymbol raw |> FIXField.LegSymbol
        | "601" -> ReadLegSymbolSfx raw |> FIXField.LegSymbolSfx
        | "602" -> ReadLegSecurityID raw |> FIXField.LegSecurityID
        | "603" -> ReadLegSecurityIDSource raw |> FIXField.LegSecurityIDSource
        | "604" -> ReadNoLegSecurityAltID raw |> FIXField.NoLegSecurityAltID
        | "605" -> ReadLegSecurityAltID raw |> FIXField.LegSecurityAltID
        | "606" -> ReadLegSecurityAltIDSource raw |> FIXField.LegSecurityAltIDSource
        | "607" -> ReadLegProduct raw |> FIXField.LegProduct
        | "608" -> ReadLegCFICode raw |> FIXField.LegCFICode
        | "609" -> ReadLegSecurityType raw |> FIXField.LegSecurityType
        | "610" -> ReadLegMaturityMonthYear raw |> FIXField.LegMaturityMonthYear
        | "611" -> ReadLegMaturityDate raw |> FIXField.LegMaturityDate
        | "612" -> ReadLegStrikePrice raw |> FIXField.LegStrikePrice
        | "613" -> ReadLegOptAttribute raw |> FIXField.LegOptAttribute
        | "614" -> ReadLegContractMultiplier raw |> FIXField.LegContractMultiplier
        | "615" -> ReadLegCouponRate raw |> FIXField.LegCouponRate
        | "616" -> ReadLegSecurityExchange raw |> FIXField.LegSecurityExchange
        | "617" -> ReadLegIssuer raw |> FIXField.LegIssuer
        | "618" -> ReadEncodedLegIssuer raw strm|> FIXField.EncodedLegIssuer // len->string compound field
        | "620" -> ReadLegSecurityDesc raw |> FIXField.LegSecurityDesc
        | "621" -> ReadEncodedLegSecurityDesc raw strm|> FIXField.EncodedLegSecurityDesc // len->string compound field
        | "623" -> ReadLegRatioQty raw |> FIXField.LegRatioQty
        | "624" -> ReadLegSide raw |> FIXField.LegSide
        | "625" -> ReadTradingSessionSubID raw |> FIXField.TradingSessionSubID
        | "626" -> ReadAllocType raw |> FIXField.AllocType
        | "627" -> ReadNoHops raw |> FIXField.NoHops
        | "628" -> ReadHopCompID raw |> FIXField.HopCompID
        | "629" -> ReadHopSendingTime raw |> FIXField.HopSendingTime
        | "630" -> ReadHopRefID raw |> FIXField.HopRefID
        | "631" -> ReadMidPx raw |> FIXField.MidPx
        | "632" -> ReadBidYield raw |> FIXField.BidYield
        | "633" -> ReadMidYield raw |> FIXField.MidYield
        | "634" -> ReadOfferYield raw |> FIXField.OfferYield
        | "635" -> ReadClearingFeeIndicator raw |> FIXField.ClearingFeeIndicator
        | "636" -> ReadWorkingIndicator raw |> FIXField.WorkingIndicator
        | "637" -> ReadLegLastPx raw |> FIXField.LegLastPx
        | "638" -> ReadPriorityIndicator raw |> FIXField.PriorityIndicator
        | "639" -> ReadPriceImprovement raw |> FIXField.PriceImprovement
        | "640" -> ReadPrice2 raw |> FIXField.Price2
        | "641" -> ReadLastForwardPoints2 raw |> FIXField.LastForwardPoints2
        | "642" -> ReadBidForwardPoints2 raw |> FIXField.BidForwardPoints2
        | "643" -> ReadOfferForwardPoints2 raw |> FIXField.OfferForwardPoints2
        | "644" -> ReadRFQReqID raw |> FIXField.RFQReqID
        | "645" -> ReadMktBidPx raw |> FIXField.MktBidPx
        | "646" -> ReadMktOfferPx raw |> FIXField.MktOfferPx
        | "647" -> ReadMinBidSize raw |> FIXField.MinBidSize
        | "648" -> ReadMinOfferSize raw |> FIXField.MinOfferSize
        | "649" -> ReadQuoteStatusReqID raw |> FIXField.QuoteStatusReqID
        | "650" -> ReadLegalConfirm raw |> FIXField.LegalConfirm
        | "651" -> ReadUnderlyingLastPx raw |> FIXField.UnderlyingLastPx
        | "652" -> ReadUnderlyingLastQty raw |> FIXField.UnderlyingLastQty
        | "654" -> ReadLegRefID raw |> FIXField.LegRefID
        | "655" -> ReadContraLegRefID raw |> FIXField.ContraLegRefID
        | "656" -> ReadSettlCurrBidFxRate raw |> FIXField.SettlCurrBidFxRate
        | "657" -> ReadSettlCurrOfferFxRate raw |> FIXField.SettlCurrOfferFxRate
        | "658" -> ReadQuoteRequestRejectReason raw |> FIXField.QuoteRequestRejectReason
        | "659" -> ReadSideComplianceID raw |> FIXField.SideComplianceID
        | "660" -> ReadAcctIDSource raw |> FIXField.AcctIDSource
        | "661" -> ReadAllocAcctIDSource raw |> FIXField.AllocAcctIDSource
        | "662" -> ReadBenchmarkPrice raw |> FIXField.BenchmarkPrice
        | "663" -> ReadBenchmarkPriceType raw |> FIXField.BenchmarkPriceType
        | "664" -> ReadConfirmID raw |> FIXField.ConfirmID
        | "665" -> ReadConfirmStatus raw |> FIXField.ConfirmStatus
        | "666" -> ReadConfirmTransType raw |> FIXField.ConfirmTransType
        | "667" -> ReadContractSettlMonth raw |> FIXField.ContractSettlMonth
        | "668" -> ReadDeliveryForm raw |> FIXField.DeliveryForm
        | "669" -> ReadLastParPx raw |> FIXField.LastParPx
        | "670" -> ReadNoLegAllocs raw |> FIXField.NoLegAllocs
        | "671" -> ReadLegAllocAccount raw |> FIXField.LegAllocAccount
        | "672" -> ReadLegIndividualAllocID raw |> FIXField.LegIndividualAllocID
        | "673" -> ReadLegAllocQty raw |> FIXField.LegAllocQty
        | "674" -> ReadLegAllocAcctIDSource raw |> FIXField.LegAllocAcctIDSource
        | "675" -> ReadLegSettlCurrency raw |> FIXField.LegSettlCurrency
        | "676" -> ReadLegBenchmarkCurveCurrency raw |> FIXField.LegBenchmarkCurveCurrency
        | "677" -> ReadLegBenchmarkCurveName raw |> FIXField.LegBenchmarkCurveName
        | "678" -> ReadLegBenchmarkCurvePoint raw |> FIXField.LegBenchmarkCurvePoint
        | "679" -> ReadLegBenchmarkPrice raw |> FIXField.LegBenchmarkPrice
        | "680" -> ReadLegBenchmarkPriceType raw |> FIXField.LegBenchmarkPriceType
        | "681" -> ReadLegBidPx raw |> FIXField.LegBidPx
        | "682" -> ReadLegIOIQty raw |> FIXField.LegIOIQty
        | "683" -> ReadNoLegStipulations raw |> FIXField.NoLegStipulations
        | "684" -> ReadLegOfferPx raw |> FIXField.LegOfferPx
        | "685" -> ReadLegOrderQty raw |> FIXField.LegOrderQty
        | "686" -> ReadLegPriceType raw |> FIXField.LegPriceType
        | "687" -> ReadLegQty raw |> FIXField.LegQty
        | "688" -> ReadLegStipulationType raw |> FIXField.LegStipulationType
        | "689" -> ReadLegStipulationValue raw |> FIXField.LegStipulationValue
        | "690" -> ReadLegSwapType raw |> FIXField.LegSwapType
        | "691" -> ReadPool raw |> FIXField.Pool
        | "692" -> ReadQuotePriceType raw |> FIXField.QuotePriceType
        | "693" -> ReadQuoteRespID raw |> FIXField.QuoteRespID
        | "694" -> ReadQuoteRespType raw |> FIXField.QuoteRespType
        | "695" -> ReadQuoteQualifier raw |> FIXField.QuoteQualifier
        | "696" -> ReadYieldRedemptionDate raw |> FIXField.YieldRedemptionDate
        | "697" -> ReadYieldRedemptionPrice raw |> FIXField.YieldRedemptionPrice
        | "698" -> ReadYieldRedemptionPriceType raw |> FIXField.YieldRedemptionPriceType
        | "699" -> ReadBenchmarkSecurityID raw |> FIXField.BenchmarkSecurityID
        | "700" -> ReadReversalIndicator raw |> FIXField.ReversalIndicator
        | "701" -> ReadYieldCalcDate raw |> FIXField.YieldCalcDate
        | "702" -> ReadNoPositions raw |> FIXField.NoPositions
        | "703" -> ReadPosType raw |> FIXField.PosType
        | "704" -> ReadLongQty raw |> FIXField.LongQty
        | "705" -> ReadShortQty raw |> FIXField.ShortQty
        | "706" -> ReadPosQtyStatus raw |> FIXField.PosQtyStatus
        | "707" -> ReadPosAmtType raw |> FIXField.PosAmtType
        | "708" -> ReadPosAmt raw |> FIXField.PosAmt
        | "709" -> ReadPosTransType raw |> FIXField.PosTransType
        | "710" -> ReadPosReqID raw |> FIXField.PosReqID
        | "711" -> ReadNoUnderlyings raw |> FIXField.NoUnderlyings
        | "712" -> ReadPosMaintAction raw |> FIXField.PosMaintAction
        | "713" -> ReadOrigPosReqRefID raw |> FIXField.OrigPosReqRefID
        | "714" -> ReadPosMaintRptRefID raw |> FIXField.PosMaintRptRefID
        | "715" -> ReadClearingBusinessDate raw |> FIXField.ClearingBusinessDate
        | "716" -> ReadSettlSessID raw |> FIXField.SettlSessID
        | "717" -> ReadSettlSessSubID raw |> FIXField.SettlSessSubID
        | "718" -> ReadAdjustmentType raw |> FIXField.AdjustmentType
        | "719" -> ReadContraryInstructionIndicator raw |> FIXField.ContraryInstructionIndicator
        | "720" -> ReadPriorSpreadIndicator raw |> FIXField.PriorSpreadIndicator
        | "721" -> ReadPosMaintRptID raw |> FIXField.PosMaintRptID
        | "722" -> ReadPosMaintStatus raw |> FIXField.PosMaintStatus
        | "723" -> ReadPosMaintResult raw |> FIXField.PosMaintResult
        | "724" -> ReadPosReqType raw |> FIXField.PosReqType
        | "725" -> ReadResponseTransportType raw |> FIXField.ResponseTransportType
        | "726" -> ReadResponseDestination raw |> FIXField.ResponseDestination
        | "727" -> ReadTotalNumPosReports raw |> FIXField.TotalNumPosReports
        | "728" -> ReadPosReqResult raw |> FIXField.PosReqResult
        | "729" -> ReadPosReqStatus raw |> FIXField.PosReqStatus
        | "730" -> ReadSettlPrice raw |> FIXField.SettlPrice
        | "731" -> ReadSettlPriceType raw |> FIXField.SettlPriceType
        | "732" -> ReadUnderlyingSettlPrice raw |> FIXField.UnderlyingSettlPrice
        | "733" -> ReadUnderlyingSettlPriceType raw |> FIXField.UnderlyingSettlPriceType
        | "734" -> ReadPriorSettlPrice raw |> FIXField.PriorSettlPrice
        | "735" -> ReadNoQuoteQualifiers raw |> FIXField.NoQuoteQualifiers
        | "736" -> ReadAllocSettlCurrency raw |> FIXField.AllocSettlCurrency
        | "737" -> ReadAllocSettlCurrAmt raw |> FIXField.AllocSettlCurrAmt
        | "738" -> ReadInterestAtMaturity raw |> FIXField.InterestAtMaturity
        | "739" -> ReadLegDatedDate raw |> FIXField.LegDatedDate
        | "740" -> ReadLegPool raw |> FIXField.LegPool
        | "741" -> ReadAllocInterestAtMaturity raw |> FIXField.AllocInterestAtMaturity
        | "742" -> ReadAllocAccruedInterestAmt raw |> FIXField.AllocAccruedInterestAmt
        | "743" -> ReadDeliveryDate raw |> FIXField.DeliveryDate
        | "744" -> ReadAssignmentMethod raw |> FIXField.AssignmentMethod
        | "745" -> ReadAssignmentUnit raw |> FIXField.AssignmentUnit
        | "746" -> ReadOpenInterest raw |> FIXField.OpenInterest
        | "747" -> ReadExerciseMethod raw |> FIXField.ExerciseMethod
        | "748" -> ReadTotNumTradeReports raw |> FIXField.TotNumTradeReports
        | "749" -> ReadTradeRequestResult raw |> FIXField.TradeRequestResult
        | "750" -> ReadTradeRequestStatus raw |> FIXField.TradeRequestStatus
        | "751" -> ReadTradeReportRejectReason raw |> FIXField.TradeReportRejectReason
        | "752" -> ReadSideMultiLegReportingType raw |> FIXField.SideMultiLegReportingType
        | "753" -> ReadNoPosAmt raw |> FIXField.NoPosAmt
        | "754" -> ReadAutoAcceptIndicator raw |> FIXField.AutoAcceptIndicator
        | "755" -> ReadAllocReportID raw |> FIXField.AllocReportID
        | "756" -> ReadNoNested2PartyIDs raw |> FIXField.NoNested2PartyIDs
        | "757" -> ReadNested2PartyID raw |> FIXField.Nested2PartyID
        | "758" -> ReadNested2PartyIDSource raw |> FIXField.Nested2PartyIDSource
        | "759" -> ReadNested2PartyRole raw |> FIXField.Nested2PartyRole
        | "760" -> ReadNested2PartySubID raw |> FIXField.Nested2PartySubID
        | "761" -> ReadBenchmarkSecurityIDSource raw |> FIXField.BenchmarkSecurityIDSource
        | "762" -> ReadSecuritySubType raw |> FIXField.SecuritySubType
        | "763" -> ReadUnderlyingSecuritySubType raw |> FIXField.UnderlyingSecuritySubType
        | "764" -> ReadLegSecuritySubType raw |> FIXField.LegSecuritySubType
        | "765" -> ReadAllowableOneSidednessPct raw |> FIXField.AllowableOneSidednessPct
        | "766" -> ReadAllowableOneSidednessValue raw |> FIXField.AllowableOneSidednessValue
        | "767" -> ReadAllowableOneSidednessCurr raw |> FIXField.AllowableOneSidednessCurr
        | "768" -> ReadNoTrdRegTimestamps raw |> FIXField.NoTrdRegTimestamps
        | "769" -> ReadTrdRegTimestamp raw |> FIXField.TrdRegTimestamp
        | "770" -> ReadTrdRegTimestampType raw |> FIXField.TrdRegTimestampType
        | "771" -> ReadTrdRegTimestampOrigin raw |> FIXField.TrdRegTimestampOrigin
        | "772" -> ReadConfirmRefID raw |> FIXField.ConfirmRefID
        | "773" -> ReadConfirmType raw |> FIXField.ConfirmType
        | "774" -> ReadConfirmRejReason raw |> FIXField.ConfirmRejReason
        | "775" -> ReadBookingType raw |> FIXField.BookingType
        | "776" -> ReadIndividualAllocRejCode raw |> FIXField.IndividualAllocRejCode
        | "777" -> ReadSettlInstMsgID raw |> FIXField.SettlInstMsgID
        | "778" -> ReadNoSettlInst raw |> FIXField.NoSettlInst
        | "779" -> ReadLastUpdateTime raw |> FIXField.LastUpdateTime
        | "780" -> ReadAllocSettlInstType raw |> FIXField.AllocSettlInstType
        | "781" -> ReadNoSettlPartyIDs raw |> FIXField.NoSettlPartyIDs
        | "782" -> ReadSettlPartyID raw |> FIXField.SettlPartyID
        | "783" -> ReadSettlPartyIDSource raw |> FIXField.SettlPartyIDSource
        | "784" -> ReadSettlPartyRole raw |> FIXField.SettlPartyRole
        | "785" -> ReadSettlPartySubID raw |> FIXField.SettlPartySubID
        | "786" -> ReadSettlPartySubIDType raw |> FIXField.SettlPartySubIDType
        | "787" -> ReadDlvyInstType raw |> FIXField.DlvyInstType
        | "788" -> ReadTerminationType raw |> FIXField.TerminationType
        | "789" -> ReadNextExpectedMsgSeqNum raw |> FIXField.NextExpectedMsgSeqNum
        | "790" -> ReadOrdStatusReqID raw |> FIXField.OrdStatusReqID
        | "791" -> ReadSettlInstReqID raw |> FIXField.SettlInstReqID
        | "792" -> ReadSettlInstReqRejCode raw |> FIXField.SettlInstReqRejCode
        | "793" -> ReadSecondaryAllocID raw |> FIXField.SecondaryAllocID
        | "794" -> ReadAllocReportType raw |> FIXField.AllocReportType
        | "795" -> ReadAllocReportRefID raw |> FIXField.AllocReportRefID
        | "796" -> ReadAllocCancReplaceReason raw |> FIXField.AllocCancReplaceReason
        | "797" -> ReadCopyMsgIndicator raw |> FIXField.CopyMsgIndicator
        | "798" -> ReadAllocAccountType raw |> FIXField.AllocAccountType
        | "799" -> ReadOrderAvgPx raw |> FIXField.OrderAvgPx
        | "800" -> ReadOrderBookingQty raw |> FIXField.OrderBookingQty
        | "801" -> ReadNoSettlPartySubIDs raw |> FIXField.NoSettlPartySubIDs
        | "802" -> ReadNoPartySubIDs raw |> FIXField.NoPartySubIDs
        | "803" -> ReadPartySubIDType raw |> FIXField.PartySubIDType
        | "804" -> ReadNoNestedPartySubIDs raw |> FIXField.NoNestedPartySubIDs
        | "805" -> ReadNestedPartySubIDType raw |> FIXField.NestedPartySubIDType
        | "806" -> ReadNoNested2PartySubIDs raw |> FIXField.NoNested2PartySubIDs
        | "807" -> ReadNested2PartySubIDType raw |> FIXField.Nested2PartySubIDType
        | "808" -> ReadAllocIntermedReqType raw |> FIXField.AllocIntermedReqType
        | "810" -> ReadUnderlyingPx raw |> FIXField.UnderlyingPx
        | "811" -> ReadPriceDelta raw |> FIXField.PriceDelta
        | "812" -> ReadApplQueueMax raw |> FIXField.ApplQueueMax
        | "813" -> ReadApplQueueDepth raw |> FIXField.ApplQueueDepth
        | "814" -> ReadApplQueueResolution raw |> FIXField.ApplQueueResolution
        | "815" -> ReadApplQueueAction raw |> FIXField.ApplQueueAction
        | "816" -> ReadNoAltMDSource raw |> FIXField.NoAltMDSource
        | "817" -> ReadAltMDSourceID raw |> FIXField.AltMDSourceID
        | "818" -> ReadSecondaryTradeReportID raw |> FIXField.SecondaryTradeReportID
        | "819" -> ReadAvgPxIndicator raw |> FIXField.AvgPxIndicator
        | "820" -> ReadTradeLinkID raw |> FIXField.TradeLinkID
        | "821" -> ReadOrderInputDevice raw |> FIXField.OrderInputDevice
        | "822" -> ReadUnderlyingTradingSessionID raw |> FIXField.UnderlyingTradingSessionID
        | "823" -> ReadUnderlyingTradingSessionSubID raw |> FIXField.UnderlyingTradingSessionSubID
        | "824" -> ReadTradeLegRefID raw |> FIXField.TradeLegRefID
        | "825" -> ReadExchangeRule raw |> FIXField.ExchangeRule
        | "826" -> ReadTradeAllocIndicator raw |> FIXField.TradeAllocIndicator
        | "827" -> ReadExpirationCycle raw |> FIXField.ExpirationCycle
        | "828" -> ReadTrdType raw |> FIXField.TrdType
        | "829" -> ReadTrdSubType raw |> FIXField.TrdSubType
        | "830" -> ReadTransferReason raw |> FIXField.TransferReason
        | "831" -> ReadAsgnReqID raw |> FIXField.AsgnReqID
        | "832" -> ReadTotNumAssignmentReports raw |> FIXField.TotNumAssignmentReports
        | "833" -> ReadAsgnRptID raw |> FIXField.AsgnRptID
        | "834" -> ReadThresholdAmount raw |> FIXField.ThresholdAmount
        | "835" -> ReadPegMoveType raw |> FIXField.PegMoveType
        | "836" -> ReadPegOffsetType raw |> FIXField.PegOffsetType
        | "837" -> ReadPegLimitType raw |> FIXField.PegLimitType
        | "838" -> ReadPegRoundDirection raw |> FIXField.PegRoundDirection
        | "839" -> ReadPeggedPrice raw |> FIXField.PeggedPrice
        | "840" -> ReadPegScope raw |> FIXField.PegScope
        | "841" -> ReadDiscretionMoveType raw |> FIXField.DiscretionMoveType
        | "842" -> ReadDiscretionOffsetType raw |> FIXField.DiscretionOffsetType
        | "843" -> ReadDiscretionLimitType raw |> FIXField.DiscretionLimitType
        | "844" -> ReadDiscretionRoundDirection raw |> FIXField.DiscretionRoundDirection
        | "845" -> ReadDiscretionPrice raw |> FIXField.DiscretionPrice
        | "846" -> ReadDiscretionScope raw |> FIXField.DiscretionScope
        | "847" -> ReadTargetStrategy raw |> FIXField.TargetStrategy
        | "848" -> ReadTargetStrategyParameters raw |> FIXField.TargetStrategyParameters
        | "849" -> ReadParticipationRate raw |> FIXField.ParticipationRate
        | "850" -> ReadTargetStrategyPerformance raw |> FIXField.TargetStrategyPerformance
        | "851" -> ReadLastLiquidityInd raw |> FIXField.LastLiquidityInd
        | "852" -> ReadPublishTrdIndicator raw |> FIXField.PublishTrdIndicator
        | "853" -> ReadShortSaleReason raw |> FIXField.ShortSaleReason
        | "854" -> ReadQtyType raw |> FIXField.QtyType
        | "855" -> ReadSecondaryTrdType raw |> FIXField.SecondaryTrdType
        | "856" -> ReadTradeReportType raw |> FIXField.TradeReportType
        | "857" -> ReadAllocNoOrdersType raw |> FIXField.AllocNoOrdersType
        | "858" -> ReadSharedCommission raw |> FIXField.SharedCommission
        | "859" -> ReadConfirmReqID raw |> FIXField.ConfirmReqID
        | "860" -> ReadAvgParPx raw |> FIXField.AvgParPx
        | "861" -> ReadReportedPx raw |> FIXField.ReportedPx
        | "862" -> ReadNoCapacities raw |> FIXField.NoCapacities
        | "863" -> ReadOrderCapacityQty raw |> FIXField.OrderCapacityQty
        | "864" -> ReadNoEvents raw |> FIXField.NoEvents
        | "865" -> ReadEventType raw |> FIXField.EventType
        | "866" -> ReadEventDate raw |> FIXField.EventDate
        | "867" -> ReadEventPx raw |> FIXField.EventPx
        | "868" -> ReadEventText raw |> FIXField.EventText
        | "869" -> ReadPctAtRisk raw |> FIXField.PctAtRisk
        | "870" -> ReadNoInstrAttrib raw |> FIXField.NoInstrAttrib
        | "871" -> ReadInstrAttribType raw |> FIXField.InstrAttribType
        | "872" -> ReadInstrAttribValue raw |> FIXField.InstrAttribValue
        | "873" -> ReadDatedDate raw |> FIXField.DatedDate
        | "874" -> ReadInterestAccrualDate raw |> FIXField.InterestAccrualDate
        | "875" -> ReadCPProgram raw |> FIXField.CPProgram
        | "876" -> ReadCPRegType raw |> FIXField.CPRegType
        | "877" -> ReadUnderlyingCPProgram raw |> FIXField.UnderlyingCPProgram
        | "878" -> ReadUnderlyingCPRegType raw |> FIXField.UnderlyingCPRegType
        | "879" -> ReadUnderlyingQty raw |> FIXField.UnderlyingQty
        | "880" -> ReadTrdMatchID raw |> FIXField.TrdMatchID
        | "881" -> ReadSecondaryTradeReportRefID raw |> FIXField.SecondaryTradeReportRefID
        | "882" -> ReadUnderlyingDirtyPrice raw |> FIXField.UnderlyingDirtyPrice
        | "883" -> ReadUnderlyingEndPrice raw |> FIXField.UnderlyingEndPrice
        | "884" -> ReadUnderlyingStartValue raw |> FIXField.UnderlyingStartValue
        | "885" -> ReadUnderlyingCurrentValue raw |> FIXField.UnderlyingCurrentValue
        | "886" -> ReadUnderlyingEndValue raw |> FIXField.UnderlyingEndValue
        | "887" -> ReadNoUnderlyingStips raw |> FIXField.NoUnderlyingStips
        | "888" -> ReadUnderlyingStipType raw |> FIXField.UnderlyingStipType
        | "889" -> ReadUnderlyingStipValue raw |> FIXField.UnderlyingStipValue
        | "890" -> ReadMaturityNetMoney raw |> FIXField.MaturityNetMoney
        | "891" -> ReadMiscFeeBasis raw |> FIXField.MiscFeeBasis
        | "892" -> ReadTotNoAllocs raw |> FIXField.TotNoAllocs
        | "893" -> ReadLastFragment raw |> FIXField.LastFragment
        | "894" -> ReadCollReqID raw |> FIXField.CollReqID
        | "895" -> ReadCollAsgnReason raw |> FIXField.CollAsgnReason
        | "896" -> ReadCollInquiryQualifier raw |> FIXField.CollInquiryQualifier
        | "897" -> ReadNoTrades raw |> FIXField.NoTrades
        | "898" -> ReadMarginRatio raw |> FIXField.MarginRatio
        | "899" -> ReadMarginExcess raw |> FIXField.MarginExcess
        | "900" -> ReadTotalNetValue raw |> FIXField.TotalNetValue
        | "901" -> ReadCashOutstanding raw |> FIXField.CashOutstanding
        | "902" -> ReadCollAsgnID raw |> FIXField.CollAsgnID
        | "903" -> ReadCollAsgnTransType raw |> FIXField.CollAsgnTransType
        | "904" -> ReadCollRespID raw |> FIXField.CollRespID
        | "905" -> ReadCollAsgnRespType raw |> FIXField.CollAsgnRespType
        | "906" -> ReadCollAsgnRejectReason raw |> FIXField.CollAsgnRejectReason
        | "907" -> ReadCollAsgnRefID raw |> FIXField.CollAsgnRefID
        | "908" -> ReadCollRptID raw |> FIXField.CollRptID
        | "909" -> ReadCollInquiryID raw |> FIXField.CollInquiryID
        | "910" -> ReadCollStatus raw |> FIXField.CollStatus
        | "911" -> ReadTotNumReports raw |> FIXField.TotNumReports
        | "912" -> ReadLastRptRequested raw |> FIXField.LastRptRequested
        | "913" -> ReadAgreementDesc raw |> FIXField.AgreementDesc
        | "914" -> ReadAgreementID raw |> FIXField.AgreementID
        | "915" -> ReadAgreementDate raw |> FIXField.AgreementDate
        | "916" -> ReadStartDate raw |> FIXField.StartDate
        | "917" -> ReadEndDate raw |> FIXField.EndDate
        | "918" -> ReadAgreementCurrency raw |> FIXField.AgreementCurrency
        | "919" -> ReadDeliveryType raw |> FIXField.DeliveryType
        | "920" -> ReadEndAccruedInterestAmt raw |> FIXField.EndAccruedInterestAmt
        | "921" -> ReadStartCash raw |> FIXField.StartCash
        | "922" -> ReadEndCash raw |> FIXField.EndCash
        | "923" -> ReadUserRequestID raw |> FIXField.UserRequestID
        | "924" -> ReadUserRequestType raw |> FIXField.UserRequestType
        | "925" -> ReadNewPassword raw |> FIXField.NewPassword
        | "926" -> ReadUserStatus raw |> FIXField.UserStatus
        | "927" -> ReadUserStatusText raw |> FIXField.UserStatusText
        | "928" -> ReadStatusValue raw |> FIXField.StatusValue
        | "929" -> ReadStatusText raw |> FIXField.StatusText
        | "930" -> ReadRefCompID raw |> FIXField.RefCompID
        | "931" -> ReadRefSubID raw |> FIXField.RefSubID
        | "932" -> ReadNetworkResponseID raw |> FIXField.NetworkResponseID
        | "933" -> ReadNetworkRequestID raw |> FIXField.NetworkRequestID
        | "934" -> ReadLastNetworkResponseID raw |> FIXField.LastNetworkResponseID
        | "935" -> ReadNetworkRequestType raw |> FIXField.NetworkRequestType
        | "936" -> ReadNoCompIDs raw |> FIXField.NoCompIDs
        | "937" -> ReadNetworkStatusResponseType raw |> FIXField.NetworkStatusResponseType
        | "938" -> ReadNoCollInquiryQualifier raw |> FIXField.NoCollInquiryQualifier
        | "939" -> ReadTrdRptStatus raw |> FIXField.TrdRptStatus
        | "940" -> ReadAffirmStatus raw |> FIXField.AffirmStatus
        | "941" -> ReadUnderlyingStrikeCurrency raw |> FIXField.UnderlyingStrikeCurrency
        | "942" -> ReadLegStrikeCurrency raw |> FIXField.LegStrikeCurrency
        | "943" -> ReadTimeBracket raw |> FIXField.TimeBracket
        | "944" -> ReadCollAction raw |> FIXField.CollAction
        | "945" -> ReadCollInquiryStatus raw |> FIXField.CollInquiryStatus
        | "946" -> ReadCollInquiryResult raw |> FIXField.CollInquiryResult
        | "947" -> ReadStrikeCurrency raw |> FIXField.StrikeCurrency
        | "948" -> ReadNoNested3PartyIDs raw |> FIXField.NoNested3PartyIDs
        | "949" -> ReadNested3PartyID raw |> FIXField.Nested3PartyID
        | "950" -> ReadNested3PartyIDSource raw |> FIXField.Nested3PartyIDSource
        | "951" -> ReadNested3PartyRole raw |> FIXField.Nested3PartyRole
        | "952" -> ReadNoNested3PartySubIDs raw |> FIXField.NoNested3PartySubIDs
        | "953" -> ReadNested3PartySubID raw |> FIXField.Nested3PartySubID
        | "954" -> ReadNested3PartySubIDType raw |> FIXField.Nested3PartySubIDType
        | "955" -> ReadLegContractSettlMonth raw |> FIXField.LegContractSettlMonth
        | "956" -> ReadLegInterestAccrualDate raw |> FIXField.LegInterestAccrualDate
        |  _  -> failwith "FIXField invalid tag" 
    fld

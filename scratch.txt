// taken from http://stackoverflow.com/questions/26605506/fastest-way-to-compare-two-byte-arrays-in-f
let Compare (x:byte[]) (y:byte[]) =
    let xlen = x.Length
    let ylen = y.Length
    let len = if xlen<ylen then xlen else ylen
    let mutable i = 0
    let mutable result = 0
    while i<len do
        let c = (int (x.[i])) - int (y.[i])
        if c <> 0 then
            i <- len+1 // breaks out of the loop, and signals that result is valid
            result <- c
        else
            i <- i + 1
    if i>len then result else (xlen - ylen)


let eqCmp = { 
    new System.Collections.Generic.IEqualityComparer<byte[]> with
        member x.Equals(bs1, bs2) = (Compare bs1 bs2) = 0
        member x.GetHashCode(bs:byte[]) = bs |> Array.sum |> int
   }

let readMap = System.Collections.Generic.Dictionary<byte[], int->byte[]->int*FIXField>(eqCmp)



let inline readFuncAdaptor (rf:int->byte[]->int*'t) (tc:'t->FIXField) : (int->byte[]->int*FIXField) =
    fun pos bs -> 
        let pos, tt = rf pos bs
        pos, (tc tt)


readMap.Add ("1"B, readFuncAdaptor ReadAccount FIXField.Account)
readMap.Add ("2"B, readFuncAdaptor ReadAdvId FIXField.AdvId)
readMap.Add ("3"B, readFuncAdaptor ReadAdvRefID FIXField.AdvRefID)
readMap.Add ("4"B, readFuncAdaptor ReadAdvSide FIXField.AdvSide)
readMap.Add ("5"B, readFuncAdaptor ReadAdvTransType FIXField.AdvTransType)


----

let writeMap = System.Collections.Generic.Dictionary<System.Type, byte[]->int->FIXField->int>()


let writeFuncAdaptor (wf:byte[]->int->'t->int) (tc:FIXField->'t) : byte[]->int->FIXField->int =
    fun (bs:byte[]) (nextFreeIdx:int) (fld:FIXField) ->
        let rawField =  tc fld
        wf bs nextFreeIdx rawField

writeMap.Add(FIXField.Account.GetType(), WriteAccount)



let WriteField2 dest nextFreeIdx fixField =
    let tp = fixField.GetType()
    let writeFunc = writeMap.[tp]
    writeFunc dest nextFreeIdx fixField


	THE TYPE OF THE FIXField input is not known to be a specific instance of a type


----



let calcCheckSum (arr:byte[]) (endPos:int) =
    let mutable (sum:byte) = 0uy
    for ctr = 0 to (endPos-1) do
        sum <- sum + arr.[ctr]
    int (sum)


// tag: A
let WriteLogon (dest:byte []) (nextFreeIdx:int) (beginString:BeginString) (bodyLength:BodyLength) (msgType:MsgType) (senderCompID:SenderCompID) (targetCompID:TargetCompID) (msgSeqNum:MsgSeqNum) (sendingTime:SendingTime) (xx:Logon) =
	// write the body - body length and checksum are required for the header, so these must be calculated first
	// simpler just to write the body first, then rearrange when copying to the socket buffer

    let nextFreeIdx = WriteEncryptMethod dest nextFreeIdx xx.EncryptMethod
    let nextFreeIdx = WriteHeartBtInt dest nextFreeIdx xx.HeartBtInt
    let nextFreeIdx = Option.fold (WriteRawDataLength dest) nextFreeIdx xx.RawDataLength
    let nextFreeIdx = Option.fold (WriteRawData dest) nextFreeIdx xx.RawData
    let nextFreeIdx = Option.fold (WriteResetSeqNumFlag dest) nextFreeIdx xx.ResetSeqNumFlag
    let nextFreeIdx = Option.fold (WriteNextExpectedMsgSeqNum dest) nextFreeIdx xx.NextExpectedMsgSeqNum
    let nextFreeIdx = Option.fold (WriteMaxMessageSize dest) nextFreeIdx xx.MaxMessageSize
    // group (apologies for this nested fold code, will refactor when I think of something better)
    let nextFreeIdx = Option.fold (fun innerNextFreeIdx (gs:NoMsgTypesGrp list) ->
                                        let numGrps = gs.Length
                                        let innerNextFreeIdx2 = WriteNoMsgTypes dest innerNextFreeIdx (Fix44.Fields.NoMsgTypes numGrps) // write the 'num group repeats' field
                                        List.fold (fun accFreeIdx gg -> WriteNoMsgTypesGrp dest accFreeIdx gg) innerNextFreeIdx2 gs  ) // returns the accumulated nextFreeIdx
                                  nextFreeIdx
                                  xx.NoMsgTypesGrp  // end Option.fold
    let nextFreeIdx = Option.fold (WriteTestMessageIndicator dest) nextFreeIdx xx.TestMessageIndicator
    let nextFreeIdx = Option.fold (WriteUsername dest) nextFreeIdx xx.Username
    let nextFreeIdx = Option.fold (WritePassword dest) nextFreeIdx xx.Password

	// write the header
    let bodyLength = nextFreeIdx - 1
    let startHeader = nextFreeIdx
    let checksum = calcCheckSum dest nextFreeIdx
    let nextFreeIdx = WriteBeginString dest nextFreeIdx beginString
    let nextFreeIdx = WriteBodyLength dest nextFreeIdx (BodyLength.BodyLength bodyLength)
    let nextFreeIdx = WriteMsgType dest nextFreeIdx MsgType.Logon
    let nextFreeIdx = WriteSenderCompID dest nextFreeIdx senderCompID
    let nextFreeIdx = WriteTargetCompID dest nextFreeIdx targetCompID
    let nextFreeIdx = WriteMsgSeqNum dest nextFreeIdx msgSeqNum
    let nextFreeIdx = WriteSendingTime dest nextFreeIdx sendingTime

	// write the trailer
    let startTrailer = nextFreeIdx
    let strCheckSum = CheckSum.CheckSum (checksum.ToString("0:000")) // checksum is always a three digit number
    let nextFreeIdx = WriteCheckSum dest nextFreeIdx strCheckSum
    let endTrailer = nextFreeIdx
    startHeader, startTrailer, endTrailer



let ReadLogon (src:System.IO.Stream) (xx:Logon) =
    let logonMsg:Fix44.Messages.Logon = {
        EncryptMethod = EncryptMethod.NoneOther
        HeartBtInt = HeartBtInt.HeartBtInt 30
        RawDataLength = RawDataLength.RawDataLength 128 |> Option.Some
        RawData = RawData.RawData "some data, some more data" |> Option.Some
        ResetSeqNumFlag = ResetSeqNumFlag.ResetSeqNumFlag false |> Option.Some
        NextExpectedMsgSeqNum = NextExpectedMsgSeqNum.NextExpectedMsgSeqNum 99 |> Option.Some
        MaxMessageSize = MaxMessageSize.MaxMessageSize 256 |> Option.Some
        NoMsgTypesGrp = Option.None
        TestMessageIndicator = TestMessageIndicator.TestMessageIndicator true |> Option.Some
        Username = Option.None
        Password = Option.None
        }
    Logon







//let rec compareInner (indent:string) (objA:System.Object) (objB:System.Object) =
//    let bindingFlags = 
//        BindingFlags.Public     ||| 
//        BindingFlags.NonPublic  |||
//        BindingFlags.Instance   ||| 
//        BindingFlags.Static     |||
//        BindingFlags.DeclaredOnly
//
//    let ty = objA.GetType()
//    let fields = ty.GetFields(bindingFlags)
//
//    let compStrs = 
//        fields |> Array.map (fun fi ->
//            let vA = fi.GetValue objA
//            let vB = fi.GetValue objB
//            if vA <> vB then
//                let ft = fi.FieldType
//                let fieldsInner = ft.GetFields(bindingFlags)
//                if fieldsInner.Length > 1 then
//                    let indent2 = sprintf "    %s" indent
//                    compareInner indent2 vA vB
//                else
//                    sprintf "%s >>>>>>>> %s: %O <> %O" indent fi.Name vA vB
//            else
//               sprintf "%s: %O <> %O" fi.Name vA vB
//            )
// 
//    System.String.Join("\n", compStrs)
//
//
//let compare (objA:System.Object) (objB:System.Object) = 
//    let ss = compareInner "" objA objB
//    printf "%s" ss